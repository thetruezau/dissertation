\chapter{Background}
\label{c:background}

% In this chapter, we intend to take the example of formalising some theory about the $\Lam$-calculus as a motivation to display some core aspects involved in the more elaborate formalisations ahead.

This chapter introduces essential background for the reading of this dissertation.
First, we introduce the well-known simply typed $\Lam$-calculus.
Then, we delve into a known variation of the introduced $\Lam$-calculus theory using de~Bruijn indices, that has known facilities when it comes to mechanisation.
Lastly, we present and explain a mechanisation of the simply typed $\Lam$-calculus in the \textit{Rocq Prover}.
% These concepts are introduced and motivated by the task of formalising the $\Lam$-calculus system introduced.

\section{Simply typed $\Lam$-calculus}

For the basic concepts and basic theory of the untyped $\Lam$-calculus we refer to \cite{Barendregt1987}.
For what types and the simply typed $\Lam$-calculus is about we refer to \cite{Barendregt2013} and \cite{Hindley1997}.

\subsection{Syntax}

\begin{definition}[$\Lam$-terms]
  The $\Lam$-terms are defined by the following grammar:
  \[ M, N \ ::= \ x \ | \ (\lambda x . M) \ | \ (M N) , \]
  where $x$ denotes a (term) variable.
\end{definition}

\begin{remark} \hfill
  \begin{enumerate}
  \item A denumerable set of variables is assumed and letters $x, y, z$ range over this set.
  \item An abstraction is a $\Lam$-term of the kind $(\lambda x. M)$, that will bind occurrences of $x$ in the term $M$ (also called scope of the abstraction), much like a function $x \mapsto M$.
  \item An application is a $\Lam$-term of the kind $(M_1 M_2)$, where $M_1$ has the role of function and $M_2$ has the role of argument.
  \end{enumerate}
\end{remark}

\begin{notation}
  We shall assume the usual notational conventions on $\Lam$-terms:

  \begin{enumerate}
  \item Outermost parentheses are omitted.
  \item Multiple abstractions can be abbreviated as $\lambda x y z . M$ instead of  $\lambda x . (\lambda y . (\lambda z . M))$.
  \item Multiple applications can be abbreviated as $M N_1 N_2$ instead of $(M N_1) N_2$.
  \end{enumerate}
\end{notation}

Now we may define some syntactic notions.

\begin{definition}[Bound/free occurrence]
  We say that the variable $x$ occurs bound when it occurs in the scope of an abstraction $\lambda x$ and say that it occurs free otherwise.
\end{definition}

As an illustration of the previous concept, consider the term $M = x (\lambda x . x)$.
The variable $x$ occurs both free and bound in this term.

We can easily calculate the set of free variables for a given term.

\begin{definition}[Free variables]
  For every $\Lam$-term $M$, we recursively define the set of free variables in $M$, $FV(M)$, as follows:  
  \begin{align*}
    & FV( x ) = \{ x \}, \\
    & FV( \lambda x . M ) = FV(M) - \{ x \}, \\
    & FV( M N ) = FV(M) \cup FV(N).
  \end{align*}
\end{definition}

Now, we will consider a sequence of steps taken from~\cite{Barendregt1987}, in order to define a substitution operation that avoids the capture of free variables, that is, a substitution operation that does not swap free variables for bound variables.

\begin{definition}[Renaming of bound variables]
 A renaming of bound variables in a $\Lam$-term $M$ is the replacement of a part $\lambda x . N$ of $M$ by $\lambda y . N \langle x:=y \rangle$, where $y$ does not occur at all in $N$ and $N \langle x:=y \rangle$ denotes the naive substitution operation.
 
 Observe that $N \langle x:=y \rangle$ is capture-avoiding as $y$ is carefully chosen to not occur in $N$.
\end{definition}

\begin{definition}[$\alpha$-congruence]
  Given $\Lam$-terms $M, N$, we say that $M$ is $\alpha$-congruent with $N$, namely $M \equiv_\alpha N$, when they are equal up to a series of renamings of bound variables.
\end{definition}
As an example, we can see that 
$\lambda x. \lambda y. x \equiv_\alpha
 \lambda z. \lambda y. z \equiv_\alpha
 \lambda z. \lambda x. z \equiv_\alpha
 \lambda y. \lambda x. y$.

Given this notion, we will prefer to identify $\alpha$-congruent $\Lam$-terms.
Moreover, we are now able to introduce the variable convention that is proposed in~\cite{Barendregt1987}.

\begin{convention} 
  % We will use the \textit{variable convention} introduced in \cite{Barendregt1987}.
  % Without loss of generality, every $\Lam$-term that we refer from now on is chosen (via $\alpha$-equality) to have different names for bound and free occurrences of variables.
  If some $\Lam$-terms $M, M', \dots$ occur in a certain mathematical context (of a definition, or proof, etc...), then all bound variables in these terms are chosen to be different from the free variables. 
\end{convention}

\begin{definition}[Substitution]
  For every $\Lam$-term $M$, we recursively define the substitution of $N$ for the free occurrences of $x$ in $M$, $M[x := N]$, as follows:
  \begin{align*}
    & x[x := N] = N; \\
    & y[x := N] = y, \ \text{with $x \neq y$}; \\
    & (\lambda y . M_1)[x := N] = \lambda y . (M_1[x := N]); \\
    & (M_1 M_2)[x := N] = (M_1[x := N]) (M_2[x := N]).
  \end{align*}
  
  In the third equation, there is no need to say that $y \neq x$ and that $y \not \in FV(N)$ as this is the case by the variable convention.
\end{definition}

\begin{comment}
\begin{remark}
  Is is important to notice that by variable convention, the substitution operation described is capture-avoiding: the free variables in $N$ will not be affected by the binders in $M$, as they are chosen to have different names. 
\end{remark}
\end{comment}

At last, we introduce some standard notions related to the $\beta$-reduction.

\begin{definition}[Compatible Relation]
  Let $R$ be a binary relation on $\Lam$-terms.
  We say that $R$ is compatible if it satisfies:
  \[
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (\lambda x . M_1, \lambda x . M_2) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (N M_1, N M_2) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (M_1 N, M_2 N) \in R }
    \end{prooftree}
  \]
\end{definition}

\begin{notation}
  Given a binary relation $R$ on $\Lam$-terms, we define:
  \begin{align*}
    & \to_R \text{as the compatible closure of $R$} ; \\
    & \twoheadrightarrow_R \text{as the reflexive and transitive closure of $\to_R$}.
    % & =_R \text{as the equivalence relation generated by $\twoheadrightarrow_R$}.
  \end{align*}
\end{notation}

\begin{definition}[$\beta$-reduction]
  \label{beta-reduction}
  Consider the following binary relation on $\Lam$-terms:  
  \[
    \beta = \{ ((\lambda x . M) N, M[x := N]) \
                | \ \text{$x$ is a term variable and $M, N$ are $\Lam$-terms} \}.
  \]  
  We call one step $\beta$-reduction to the relation $\to_\beta$ and multistep $\beta$-reduction to the relation $\twoheadrightarrow_\beta$.
\end{definition}

% ---

Now, a brief introduction of $\beta$-normal forms is given.

\begin{definition}[$\beta$-normal form]
  We say that a $\Lam$-term $t$ is in $\beta$-normal form (or irreducible by $\to_\beta$) when there exists no $\Lam$-term $t'$ such that
  \[ t \to_\beta t' . \]
\end{definition}

\begin{definition}% [$\beta$-normal forms]
  \label{beta_nfs}
  We inductively define the sets of $\Lam$-terms NF and NA as follows:
  \[
    \begin{prooftree}
      \infer0{ x \in \text{NA} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ M_1 \in \text{NA} }
      \hypo{ M_2 \in \text{NF} }            
      \infer2{ M_1 M_2 \in \text{NA} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ M \in \text{NA} }
      \infer1{ M \in \text{NF} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ M \in \text{NF} }
      \infer1{ \lambda x . M \in \text{NF} } 
    \end{prooftree}
  \]
\end{definition}

\begin{claim}
  \label{beta_nfs_claim}
  Given a $\Lam$-term $M$, the following are equivalent:

  (i) $M \in \text{NF}$.

  (ii) $M$ is in $\beta$-normal form.
\end{claim}

We leave this claim here, but we will show the mechanised proof for $\boxed{\text{(i)} \Rightarrow \text{(ii)}}$ in the last section of this chapter.
The proof for $\boxed{\text{(ii)} \Rightarrow \text{(i)}}$ can be found in the script repository of our development.

% --- 

Finally, we state a classical result about $\beta$-reduction --- the confluence of $\twoheadrightarrow_\beta$ (also called Church-Rosser theorem).
Many proofs of this result can be found, either in print \cite{Barendregt1987, CurryHoward} or in a proof assistant \cite{Copello2017}.
Therefore, a proof for confluence is not provided here because we are only interested in deriving the confluence of other systems from this one.
In \cref{c:isomorphism}, from proving an isomorphism with the $\Lam$-calculus, we prove the confluence of another system using the fact that the $\Lam$-calculus is confluent.

\begin{theorem}[Confluence]
  \label{confluence}
  For every $\Lam$-terms $M, M_1, M_2$ such that $M \twoheadrightarrow_\beta M_1$ and $M \twoheadrightarrow_\beta M_2$, there exists a $\Lam$-term $N$ such that $M_1 \twoheadrightarrow_\beta N$ and $M_2 \twoheadrightarrow_\beta N$.

  % We may see this with the following diagram:
  \[\begin{tikzcd}
      & M \arrow[ld, two heads, "\beta"] \arrow[rd, two heads, "\beta"] & \\
      M_1 \arrow[rd, two heads, dashed, "\beta"] && M_2 \arrow[ld, two heads, dashed, "\beta"] \\
      & \exists N & 
    \end{tikzcd}\]
\end{theorem}

\subsection{Types}

\begin{definition}[Simple Types]
  The simple types are defined by the following grammar:  
  \[
    A, B, C ::= p \ | \ (A \supset B),
  \]
  where $p$ denotes a type variable.
\end{definition}

\begin{remark} \hfill
  \begin{enumerate}
  \item A denumerable set of type variables is assumed and letters $p, q, r$ range over this set.
  \item Notice that we use the symbol $\supset$, coming from logic, to denote implication.
    This is motivated by the well-known correspondence between function types and implicational proposition, through the Curry-Howard isomorphism.
  \end{enumerate}
\end{remark}

\begin{notation}
  We will assume the usual notational conventions on simple types. 
  \begin{enumerate}
  \item Outermost parentheses are omitted.
  \item Types associate to the right. Therefore, the type $A \supset (B \supset C)$ may often be written simply as $A \supset B \supset C$.
  \end{enumerate}
\end{notation}

\begin{definition}[Type-assignment]
  A type-assignment~$M : A$ is a pair of a $\Lam$-term and a simple type.
  We call subject to the $\Lam$-term $M$ and predicate to the simple type $A$.
\end{definition}

\begin{definition}[Context]
  A context~$\Gamma, \Delta, \dots$ is a finite (possibly empty) set of type-assignments whose subjects are term variables and which is consistent.
  By consistent we mean that no variable is the subject of more than one type-assignment.
\end{definition}

\begin{notation} We may simplify the set notation of contexts as follows:
  \begin{align*}
    x:A, \dots, y:B         \quad &\text{for} \quad \{ x:A, \dots, y:B \} \\
    x:A, \dots, y:B, \Gamma \quad &\text{for} \quad \{ x:A, \dots, y:B \} \cup \Gamma.
  \end{align*}
\end{notation}

\begin{definition}[Sequent]
  A sequent~$\Gamma \vdash M:A$ is a triple of a context, a $\Lam$-term and a simple type.
\end{definition}

\begin{definition}[Typing rules for $\Lam$-terms]
  \label{typing_rules}
  The following typing rules inductively define the notion of derivable sequent.
  \[
    \begin{prooftree}
      \infer0[Var]{ x:A, \Gamma \vdash x:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ x:A, \Gamma \vdash M:B }
      \infer1[Abs]{ \Gamma \vdash \lambda x . M : A \supset B  } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash M : A \supset B }
      \hypo{ \Gamma \vdash N : A }	
      \infer2[App]{ \Gamma \vdash M N : B } 
    \end{prooftree}
  \]
  A sequent is derivable when it is at the root of a tree constructed by the successive application of the typing rules and whose leaves are instances of the Var-rule.  
\end{definition}

% ---
% 123
% ---

\section{$\Lam$-calculus with de~Bruijn syntax}

In the late 1960s, Nicolaas de Bruijn started working on the \textit{Automath} proof checker and proposed a simplified syntax to deal with generic binders \cite{deBruijn}.
This approach is claimed by the author to be good for meta-lingual discussion and for implementation in computer programmes.
In contrast, this syntax is further away from the human reader.
This section will serve as an intermediate step to the mechanised version of the simply typed $\Lam$-calculus described in the next section.

The main idea behind de~Bruijn syntax (or sometimes called de~Bruijn indices) is to treat variables as natural numbers (or indices) and to interpret these numbers as the distance to the respective binder.
Therefore, we will call these terms \textit{nameless}. 

\begin{definition}[Nameless $\Lam$-terms]
  The nameless $\Lam$-terms are defined by the following grammar:
  \[ M, N \ ::= \ i \ | \ \lambda . M \ | \ M N \ , \]  
  where $i$ ranges over the natural numbers.
\end{definition}

\begin{remark}
  Nameless $\Lam$-terms have no $\alpha$-conversion since there is no freedom to choose the names of bound variables.
\end{remark}

We show below some examples that illustrate the connection of ordinary and nameless syntax for $\Lam$-terms.
\begin{align*}
  \lambda x . x &\rightsquigarrow \lambda . 0 \\
% (\lambda x . xx)(\lambda x . xx) &\rightsquigarrow (\lambda . 00)(\lambda .00) \\
  \lambda x . \lambda y . y &\rightsquigarrow \lambda . \lambda . 0 \\
  \lambda x . \lambda y . x &\rightsquigarrow \lambda . \lambda . 1
\end{align*}

Now, we will present a different formulation for the concept of substitution, adequate to deal with nameless $\Lam$-terms.
\begin{definition}[Substitution and renaming]
  A substitution $\sigma, \tau, \dots$ over nameless $\Lam$-terms is a function mapping natural numbers (indices) to nameless $\Lam$-terms.

  A renaming $\xi, \zeta, \dots$ is the particular case of a substitution that maps indices to indices (a function $\mathbb{N} \to \mathbb{N}$). 
\end{definition}

Here are some examples of useful substitutions.
\begin{align*}
  id(k)       &= k \\
  \uparrow(k) &= k+1 \\
  (M \cdot \sigma)(k)
              &=
                \begin{cases}
                  M & \ \text{if $k = 0$} \\
                  \sigma(k-1) & \ \text{if $k > 0$}
                \end{cases}
\end{align*}

% We may also use the name of renamings for the particular cases of substitutions mapping indices to indices.
From these examples, we can see that $id$ and $\uparrow$ are renamings.
Furthermore, given a renaming $\xi$, a substitution $(i \cdot \xi)$ is also a renaming.

In order to instantiate a nameless $\Lam$-term under a substitution we first define the simpler case of instantiation under a renaming.

\begin{definition}[Instantiation under a renaming]
  The operation of instantiating a nameless $\Lam$-term $M$ under a renaming $\xi$, $M\{ \xi \}$, is recursively defined by the following equations:
  \begin{align*}
    & i\{ \xi \} = \xi(i); \\
    & (\lambda . M_1)\{ \xi \} = \lambda . (M_1 \{ 0 \cdot (\uparrow \circ \ \xi) \}); \\
    & (M_1 M_2)\{ \xi \} = (M_1\{ \xi \}) (M_2\{ \xi \}).
  \end{align*}
\end{definition}

\begin{remark}
  Notice that, in the abstraction equation, the substitution $0 \cdot (\uparrow \circ \ \xi)$ is indeed a renaming.
  This is the case because the composition operation for renamings is the usual composition of functions $\mathbb{N} \to \mathbb{N}$.
  From this follows that $\ \uparrow \circ \ \xi$ is a renaming, which in turn implies that $0 \cdot (\uparrow \circ \ \xi)$ is a renaming.
\end{remark}

As an example of the instantiation of a nameless $\Lam$-term under a renaming, we give a detailed computation of $(\lambda . \lambda . 7 1)\{ \uparrow \}$.

For simplification, let $\xi_1 = 0 \cdot (\uparrow \circ \uparrow)$ and $\xi_2 = 0 \cdot (\uparrow \circ \ \xi_1)$.
First, let us calculate $\xi_2(7)$ and $\xi_2(1)$.
\[ \xi_2(7) = (\uparrow \circ \xi_1)(6) = \uparrow(\xi_1(6)) = \uparrow((\uparrow \circ \uparrow)(5)) = \uparrow(\uparrow(\uparrow(5))) = \uparrow(\uparrow(6)) = \dots = 8 \]
\[ \xi_2(1) = (\uparrow \circ \xi_1)(0) = \uparrow(\xi_1(0)) = \uparrow(0) = 1 \]

Therefore,
\[ (\lambda . \lambda . 7 1)\{ \uparrow \} = \lambda . (\lambda . 7 1)\{ \xi_1 \} 
  = \lambda . \lambda . (7 1)\{ \xi_2 \} = \lambda . \lambda . 7\{ \xi_2 \} 1\{ \xi_2 \} 
  = \lambda . \lambda . \xi_2(7) \xi_2(1) = \lambda . \lambda . 8 1
  . \]

\begin{definition}[Composition of a renaming with a substitution]
  We define the substitution resulting of the composition of a renaming $\xi$ and a substitution $\sigma$ by
  \[ (\xi \circ \sigma)(k) = \sigma(k)\{ \xi \} . \]
\end{definition}

Given the previous definition for composition, we can use it to define the instantiation of terms under general substitutions as follows.

\begin{definition}[Instantiation under a substitution]
  The operation of instantiating a nameless $\Lam$-term $M$ under a substitution $\sigma$, $M[\sigma]$, is recursively defined by the following equations:
  \begin{align*}
    & i[\sigma] = \sigma(i); \\
    & (\lambda . M_1)[\sigma] = \lambda . (M_1[0 \cdot (\uparrow \circ \ \sigma)]); \\
    & (M_1 M_2)[\sigma] = (M_1[\sigma]) (M_2[\sigma]).
  \end{align*}
\end{definition}

This definition for instantiation describes a capture-avoiding substitution operation that replaces all free variables simultaneously.
Thus, we may also refer to these substitutions as parallel substitutions.
It is based on the ideas introduced in~\cite{AutosubstSchafer} and is very close to the actual mechanisation done using the \textit{Autosubst} library.

Using the previous definition of substitution, we could now define the $\beta$-reduction rule as
\[ (\lambda . M) N \to M[N \cdot id]. \]

For example, let us calculate the reduction of the term $((\lambda . \lambda . 1) N_1) N_2$, known as the first projection.
\begin{align*}
  ((\lambda . \lambda . 1) N_1) N_2 &\to ((\lambda . 1)[N_1 \cdot id]) N_2 = ((\lambda . 1)[N_1 \cdot id]) N_2 \\
                                    &= (\lambda . (1[0 \cdot (\uparrow \circ (N_1 \cdot id))])) N_2
                                      = (\lambda . ((\uparrow \circ (N_1 \cdot id))(0))) N_2 \\
  = (\lambda . N_1 \{ \uparrow \}) N_2 & \to (N_1 \{ \uparrow \}) [N_2 \cdot id]
                                         = \dots = N_1 \{ \uparrow \}
\end{align*}

As the term $N_1 \{ \uparrow \}$ has no occurrences of $0$ as a free variable, we see that the instantiation of substitution $(N_1 \{ \uparrow \}) [N_2 \cdot id]$ can be simplified as $N_1 \{ \uparrow \}$.
It is also interesting to notice that the resulting nameless $\Lam$-term is the same up to a renaming of free variables, and, obviously we have $N_1 \{ \uparrow \} = N_1$ when $N_1$ is a closed term.

Having introduced the instantiation of terms under substitutions, we are able to complete our sequence of definitions by providing a definition for the composition of substitutions.

\begin{definition}[Composition of substitutions]
  We define the composition of substitutions as
  \[ (\sigma \circ \tau)(k) = \tau(k)[\sigma] . \]
\end{definition}

Another variation we may encounter when formalising $\Lam$-terms using a nameless syntax is the typing system.
A similar approach to our modification of the typing system can be found in~\cite[Chapter~7]{AndrewAdams}.
We formulate the definition of context and derivable sequents in the nameless setting as follows.

\begin{definition}[Nameless context]
  A nameless context \ $\Gamma, \Delta, \dots$ is a finite (possibly empty) sequence of simple types.
\end{definition}

\begin{notation} \hfill
  
  $| \Gamma |$ is used to denote the length of a context \ $\Gamma$;

  $\Gamma_i$ is used to denote the $(i+1)$th element of a context \ $\Gamma$, given $i < | \Gamma |$.
\end{notation}

\begin{definition}[Typing rules for nameless $\Lam$-terms]
  \label{nameless_typing_rules}
  \[
    \begin{prooftree}
      \hypo{ \Gamma_i = A }
      \infer1[Var]{ \Gamma \vdash i:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ A, \Gamma \vdash M:B }
      \infer1[Abs]{ \Gamma \vdash \lambda . M : A \supset B  } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash M : A \supset B }
      \hypo{ \Gamma \vdash N : A }	
      \infer2[App]{ \Gamma \vdash M N : B } 
    \end{prooftree}
  \]
\end{definition}

Given the typing rules for nameless $\Lam$-terms, below is an example of a proof tree that gives the type $A$ to the term $((\lambda . \lambda . 1) N_1) N_2$ in a context $B, A, \Gamma$, provided that $\Gamma \vdash N_1:A$ and $\Gamma \vdash N_2:B$.

\[
  \begin{prooftree}    
    \infer0[Var]{ B, A, \Gamma \vdash 1 : A } 
    \infer1[Abs]{ A, \Gamma \vdash \lambda . 1 : B \supset A } 
    \infer1[Abs]{ \Gamma \vdash \lambda . \lambda . 1 : A \supset (B \supset A) } 
    \hypo{ \Gamma \vdash N_1 : A }
    \infer2[App]{ \Gamma \vdash (\lambda . \lambda . 1) N_1 : B \supset A } 
    \hypo{ \Gamma \vdash N_2 : B }	
    \infer2[App]{ \Gamma \vdash ((\lambda . \lambda . 1) N_1) N_2 : A } 
  \end{prooftree}
\]
  
\begin{claim}
  \label{nameless_typing_claim}  
  Structural rules of weakening, contraction and exchange are admissible in this setting.
\end{claim}

We look at the particular case of the weakening rule that corresponds to the incrementation of every index of the nameless $\Lam$-term.
\[
  \begin{prooftree}
    \hypo{ \Gamma \vdash M:A }
    \infer1[Weakening]{ B, \Gamma \vdash M[\uparrow]:A } 
  \end{prooftree}
\]

% ---
% 123
% ---

\section{Mechanising metatheory in \textit{Rocq}}

In this section we discuss basic questions arising in the formalisation of syntax with binders, and introduce a \textit{Rocq} library that helps with such task.
Additionally, we illustrate how to formalise basic concepts of the simply typed $\Lam$-calculus.
This will help to understand our main decisions on the mechanisation of metatheory developed in this dissertation.
The multiary versions of the $\Lam$-calculus that we are going to introduce will follow closely the basic approach described here with the corresponding adaptations.

\subsection{The \textit{Rocq Prover}}

The \textit{Rocq Prover} (former \textit{Coq Proof Assistant}) \cite{RocqManual} is an interactive theorem prover based on the expressive formal language called the Polymorphic, Cumulative Calculus of Inductive Constructions.
This is a tool that helps in the formalisation of mathematical results and that can interact with a human to generate machine-verified proofs.
\textit{Rocq} encodes propositions as types and proofs for these propositions as programs in $\Lam$-calculus, in line with the Curry-Howard isomorphism \cite{CurryHoward}.

It is arguably a great tool for mechanising metatheory as it was widely used in solutions for the \textit{POPLmark} challenge \cite{POPLmark}.
Also, this proof assistant provides many libraries to deal with the issue of variable binding, like \textit{Autosubst}, as we will see in the next sections.

We illustrate two examples of simple inductive definitions in \textit{Rocq}: the natural numbers and polymorphic lists.

\subsubsection{Natural numbers}
The natural numbers can be inductively defined as either zero or a successor of a natural number.
\begin{lstlisting}[language=Coq]
Inductive nat : Type :=
| O
| S (n: nat).
\end{lstlisting}

For example, the number $0$ is represented by the constructor \lst$O$ and number $2$ is represented as \lst$S (S O)$.
Of course this serves as an internal representation and we will not refer to natural numbers using these constructors.
We can also check the induction principle that \textit{Rocq} generates for the natural numbers.
\begin{lstlisting}[language=Coq]
  nat_ind
     : forall P : nat -> Prop,
       P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n
\end{lstlisting}

Therefore, if we want to prove that the sum of natural numbers is associative, we can do it using this induction principle as follows.
\begin{lstlisting}[language=Coq]
Theorem sum_associativity :
  forall a b c, a+(b+c) = (a+b)+c.
  Proof.
    intros.
    induction a.
    - (* 0+(b+c) = 0+b+c *)
      simpl.       (* simplify equation *)
      reflexivity. (* now both sides are equal *)        
    - (* (a+1)+(b+c) = (a+1)+b+c *)
      simpl.       (* simplify equation *)
      rewrite IHa. (* rewrite with induciton hypothesis *)
      reflexivity. (* now both sides are equal *)
Qed.
\end{lstlisting}

\subsubsection{Polymorphic lists}
Polymorphic lists are lists whose items have no predefined type.
The inductive definition for these lists is available in the \textit{Rocq} standard library (\lst$Library Stdlib.Lists.List$) along with many operations and properties.
Their definition is as follows: 

\begin{lstlisting}[language=Coq]
Inductive list (A: Type) : Type :=
| nil
| cons (u: A) (l: list A).
\end{lstlisting}

For example, if we wanted to have a type for lists of natural numbers, we could just invoke the type \lst$list nat$.
The list \lst$[0,2,1]$ is then represented as \lst$cons 0 (cons 2 (cons 1 nil))$.

Here is an useful lemma on lists provided by the \textit{Rocq} library:
\begin{lstlisting}[language=Coq]
Lemma map_app f : forall l l', map f (l++l') = (map f l)++(map f l').
\end{lstlisting}

This lemma relates two operations on lists:
\begin{enumerate}
\item \lst$app$ (abbreviated as \lst$++$): appends two lists (ex: \lst$[1,2,3]++[4,5] = [1,2,3,4,5]$);
\item \lst$map$: applies a function to every element on the list (ex: \lst$map f [x,y] = [f x, f y]$).
\end{enumerate}
Given their widespread utility, these operations will be often used in parts of our mechanisation.

\subsection{Syntax with binders}

% If we were to formalise such a system like the $\Lam$-calculus introduced above, we would probably create an inductive type like the following, in \textit{Coq}.
A direct formalisation of the grammar of $\Lam$-terms in \textit{Rocq} results in an inductive definition like:
\begin{lstlisting}[language=Coq]
Inductive term : Type :=
| Var (x: var)
| Lam (x: var) (t: term)
| App (s: term) (t: term).
\end{lstlisting}

The question that this and any similar definition raises is: how do we define the \lst$var$ type? Following the usual pen-and-paper approach, this type would be a subset of a "string type", where a variable is just a placeholder for a name.

Of course this is fine when dealing with proofs and definitions in a paper.
To simplify this, we can even take advantage of conventions, like the one referenced above (by Barendregt).
However, this approach to define the \lst$var$ type becomes rather exhausting when it comes to rigorously define the required syntactical ingredients, including substitution operations.

There are several alternative approaches described in the literature.
The \textit{POPLmark} challenge \cite{POPLmark} points to the topic of binding as central for discussing the potential of modern-day proof assistants and lists many options available.
From these many alternatives, we chose to follow the nameless syntax proposed by de~Bruijn because of its extensive use in the mechanisation of metatheory.

\subsection{\textit{Autosubst} library}

The \textit{Autosubst} library~\cite{AutosubstSchafer,AutosubstManual} for the \textit{Rocq Prover} facilitates the formalisation of syntax with binders.
It provides the \textit{Rocq Prover} with two kinds of tactics:
\begin{enumerate}
  \item \lst$derive$ tactics that automatically define substitution (and boilerplate definitions for substitution) over an inductively defined syntax;
  \item \lst$asimpl$ and \lst$autosubst$ tactics that provide simplification and direct automation for proofs dealing with substitution lemmas.
\end{enumerate}

The library makes use of some ideas we have already covered up: de~Bruijn syntax and parallel substitutions.
There is also a more subtle third ingredient: the theory of explicit substitution \cite{Abadi}.
This theory is particularly relevant to the implementation of the \lst$asimpl$ and \lst$autosubst$ tactics and we will not digress much on it.
Essentially, our calculus with parallel substitutions forms a model of the $\sigma$-calculus \cite{Abadi} and we may simplify our terms with substitutions using the convergent rewriting equations described by this theory.

Taking the naive example of an inductive definition of the $\Lam$-terms in \textit{Rocq}, we now display a definition using \textit{Autosubst}.

\begin{lstlisting}[language=Coq]
Inductive term: Type :=
| Var (x: var)
| Lam (t: {bind term})
| App (s: term) (t: term) .
\end{lstlisting}

In the above definition, there are two different annotations: the \lst$var$ and \lst${bind term}$ types.
We write these annotations to mark our constructors with variables and binders, respectively, in the syntax we want to mechanise.
They play an important role in the internal development of the automated \lst$derive$ tactics.

We invoke the \textit{Autosubst} classes, automatically deriving the desired instances as follows.

\begin{lstlisting}[language=Coq]
Instance Ids_term : Ids term. derive. Defined.
Instance Rename_term : Rename term. derive. Defined.
Instance Subst_term : Subst term. derive. Defined.
Instance SubstLemmas_term : SubstLemmas term. derive. Defined.
\end{lstlisting}

The first three lines derive the operations necessary to define the (parallel) substitution over a term.
\begin{enumerate}
\item Defining the \lst$ids$ function that maps every index to the corresponding variable term ($i \mapsto $ \lst$(Var i)$).
\item Defining the \lst$rename$ function that instantiates a term under a variable renaming.
\item Defining the \lst$subst$ function that instantiates a term under a parallel substitution (using the already defined \lst$rename$ and \lst$ids$).
\end{enumerate}

Finally, there is also the proof for the substitution lemmas.
Here, we see the power of this library, as the proofs for these lemmas (for fairly simple syntaxes) can also be generated automatically with the aid of the \lst$derive$ tactic. 

% exemplos de provas que usem asimpl ou autosubst?

\subsection{Mechanising the simply typed $\Lam$-calculus}

For this dissertation, we provide our own mechanisation of the simply typed $\Lam$-calculus, as we will need it in~\cref{c:isomorphism}.
The mechanisation is very straightforward and follows closely the examples given in~\cite{AutosubstManual,AutosubstSchafer}.

\subsubsection{\lst$SimpleTypes.v$}

This module only contains the definition for simple types using a unique base type for simplicity.
This definition is isolated because it will be used by multiple modules.
\begin{lstlisting}[language=Coq]
Inductive type: Type :=
| Base
| Arr (A B: type): type.
\end{lstlisting}

\subsubsection{\lst$Lambda.v$}

This module contains the definitions we need for the formalisation dealing with the simply typed $\Lam$-calculus.
The syntax for terms and \textit{Autosubst} definitions were already presented and explained in the prior subsection.

The module then includes the definition for the one step $\beta$-reduction (recall~\cref{beta-reduction}).
This inductive definition mechanises the $\beta$-reduction altogether with the compatibility closure steps ($\to_\beta$).
\begin{lstlisting}[language=Coq]
Inductive step : relation term :=
| Step_Beta s s' u : s' = s.[u.:ids] ->
  step (App (Lam s) u) s'
| Step_Abs s s' : step s s' ->
  step (Lam s) (Lam s')
| Step_App1 s s' t: step s s' ->
  step (App s t) (App s' t)
| Step_App2 s t t': step t t' ->
  step (App s t) (App s t').
\end{lstlisting}

In this definition we already give use to the substitution operation defined using \textit{Autosubst} (found in the \lst$Step_Beta$ constructor).
The syntax \lst$s.[u.:ids]$ is just notation for the defined instantiation of term $s$ under a parallel substitution \lst$u.:ids$.
This substitution corresponds to the example of substitution shown in the previous section $(u \cdot id)$.

The type for \lst$step$ is \lst$relation term$ (an alias for \lst$term->term->Prop$), as we are using the \lst$Relations$ library found in the \textit{Rocq} standard library containing definitions and lemmas for binary relations.

We also have a definition for the mutually inductive predicate mechanising $\beta$-normal forms (recall~\cref{beta_nfs}).
\begin{lstlisting}[language=Coq]
Inductive normal: term -> Prop :=
| nLam s : normal s -> normal (Lam s)
| nApps s : apps s -> normal s  
with apps: term -> Prop :=
| nVar x : apps (Var x)
| nApp s t : apps s -> normal t -> apps (App s t).
\end{lstlisting}

As before, we do not define directly a set NF of $\Lam$-terms, but rather an inductive predicate that $\Lam$-terms $t \in \text{NF}$ satisfy.
This will be our standard approach when mechanising subsets, as the subset itself is the extension of the defined predicate.

However, we have to be careful using mutually inductive predicates (we refer to~\cite[Chapter~14.1]{CoqArt} for a detailed overview on mutually inductive types and their induction principles).
If we want to prove certain propositions that proceed by induction on the structure of a normal term, we need to have a simultaneous induction principle and prove two propositions simultaneously.
\begin{lstlisting}[language=Coq]
Scheme sim_normal_ind := Induction for normal Sort Prop
  with sim_apps_ind := Induction for apps Sort Prop.
Combined Scheme mut_normal_ind from sim_normal_ind, sim_apps_ind.
\end{lstlisting}

We can generate two new induction principles using the \lst$Scheme$ command.
Then, we can combine both induction principles using the \lst$Combined Scheme$ command.
We will often use the combined induction principles in our proofs, as mutually inductive types will appear often. 

Here follows an example of the proof for~\cref{beta_nfs_claim} using the combined induction principle.
We will prove not only the desired claim but also a proposition over the set of normal applications, NA.

\begin{lstlisting}[language=Coq]
Theorem nfs_are_irreducible :
  (forall s, normal s -> ~exists t, step s t)
  /\
  (forall s, apps s -> ~exists t, step s t).
Proof.
  apply mut_normal_ind ; intros.
  (* applying the combined induction principle *)
  - intro.
    apply H.
    destruct H0 as [t Ht].
    inversion Ht.
    now exists s'.
  - intro.
    apply H.
    destruct H0 as [t Ht].
    now exists t.
  - intro.
    now destruct H.
  - intro.
    destruct H1 as [t0 Ht0].
    inversion Ht0 ; subst.
    + inversion a.
    + apply H. now exists s'.
    + apply H0. now exists t'.
Qed.
\end{lstlisting}

The proof uses a couple of tactics that we will not cover in detail.
It serves more of an example of how we easily prove a result using the mechanised concepts of one step $\beta$-reduction and normal forms.

The last thing our module contains is the typing rules for the $\Lam$-terms (recall~\cref{typing_rules} and \cref{nameless_typing_rules}).

\begin{lstlisting}[language=Coq]
Inductive sequent (Gamma: var->type) : term -> type -> Prop := 
| Ax (x: var) (A: type) :
  Gamma x = A -> sequent Gamma (Var x) A
| Intro (t: term) (A B: type) :
  sequent (A.:Gamma) t B -> sequent Gamma (Lam t) (Arr A B)
| Elim (s t: term) (A B: type) :
  sequent Gamma s (Arr A B) -> sequent Gamma t A -> sequent Gamma (App s t) B.
\end{lstlisting}

We directly mechanise the derivability of a sequents using an inductively defined predicate (instead of defining sequents \textit{a priori}).

Furthermore, following the approach in \cite{AutosubstManual}, we use infinite contexts (contexts as infinite sequences).
That way we can mechanise contexts as functions \lst$var->type$ (the type of a parallel substitution object over \lst$type$) and take more advantage of the \textit{Autosubst} definitions and tactics.
Of course, in any typing derivation, only a finite part of the (infinite) context is used.

A small illustration of the versatility of this option is in the \lst$Intro$ rule, where one can find the context \lst$(A.:Gamma)$.
This is the same function we encountered when defining the substitution operation for the $\beta$-contractum \lst$s.[u.:ids]$.

As claimed (\cref{nameless_typing_claim}) upon the definition of the typing rules for the nameless terms, we can show admissibility for the structural rules of weakening, contraction and exchange.
We do this by proving the preservation of renamings (also an idea from~\cite{AutosubstManual}), as the mentioned structural rules can be seen as a particular case of ``index renaming'' (as we have illustrated with the weakening case).

\begin{lstlisting}[language=Coq]
Lemma type_renaming : forall (Gamma: var->type) t A, sequent Î“ t A ->
  forall (Delta: var->type) (xi: var->var), Gamma = (xi>>>Delta) -> sequent Delta t.[ren xi] A.
\end{lstlisting}

The lemma \lst$type_renaming$ captures this idea of preservation of types when renaming a term.
We reorder the context $\Delta$ according to a rename $\xi$ by declaring that \lst$Gamma = (xi >>> Delta)$, where \lst$>>>$ denotes forward composition (this is a composition operation defined by \textit{Autosubst}), that is the infinite \mbox{context/function} \lst$Gamma(i) = Delta(xi(i)), forall (i:var)$.
Also notice that the keyword \lst$ren$ is simply an operation that transforms a renaming $\xi$ of type \lst$var->var$ in a substitution \lst$ren xi$ of type \lst$var -> term$.


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
