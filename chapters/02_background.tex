\chapter{Background}
\label{c:background}

% In this chapter, we intend to take the example of formalising some theory about the $\Lam$-calculus as a motivation to display some core aspects involved in the more elaborate formalisations ahead.

This chapter introduces essential background for the reading of this dissertation.
% It will take the scheme used in the subsequent chapters:
% a first part of theoretical presentation and a second part of mechanisation.
First, we introduce the well-known simply typed $\Lam$-calculus.
Then, we delve into a known variation of the introduced $\Lam$-calculus theory using de~Bruijn indices, that has known facilities when it comes to mechanisation.
Lastly, we present and explain a mechanisation of the simply typed $\Lam$-calculus in the \textit{Rocq Prover}.
% These concepts are introduced and motivated by the task of formalising the $\Lam$-calculus system introduced.

\section{Simply typed $\Lam$-calculus}

For the basic concepts and basic theory of the untyped $\Lam$-calculus we refer to \cite{Barendregt1987}.
For what types and the simply typed lambda calculus is about we refer to \cite{Barendregt2013} and \cite{Hindley1997}.

\subsection{Syntax}

\begin{definition}[$\Lam$-terms]
  The $\Lam$-terms are defined by the following grammar:
  \[ M, N \ ::= \ x \ | \ (\lambda x . M) \ | \ (M N) , \]
  where $x$ denotes a variable.
\end{definition}

\begin{remark} \hfill
  \begin{enumerate}
  \item A denumerable set of variables is assumed and letters $x, y, z$ range over this set.
  \item An abstraction is a $\Lam$-term of the kind $(\lambda x. M)$, that will bind occurrences of $x$ in the term $M$, much like a function $x \mapsto M$.
  \item An application is a $\Lam$-term of the kind $(M_1 M_2)$, where $M_1$ has the role of function and $M_2$ has the role of argument.
  \end{enumerate}
\end{remark}

\begin{notation}
  We shall assume the usual notational conventions on $\Lam$-terms:

  \begin{enumerate}
  \item Outermost parentheses are omitted.
  \item Multiple abstractions can be abbreviated as $\lambda x y z . M$ instead of  $\lambda x . (\lambda y . (\lambda z . M))$.
  \item Multiple applications can be abbreviated as $M N_1 N_2$ instead of $(M N_1) N_2$.
  \end{enumerate}
\end{notation}

\begin{comment}
\begin{definition}[Free variables]
  For every $\Lam$-term $M$, we recursively define the set of free variables in $M$, $FV(M)$, as follows:  
  \begin{align*}
    & FV( x ) = \{ x \}, \\
    & FV( \lambda x . M ) = FV(M) - \{ x \}, \\
    & FV( M N ) = FV(M) \cup FV(N).
  \end{align*}
\end{definition}
\end{comment}

\begin{definition}[Free/bound occurrence]
  We say that the variable $x$ occurs bound when it occurs in the scope of an abstraction $\lambda x$ and say that it occurs free otherwise.
\end{definition}

As an illustration of the previous concepts take the term $M = x (\lambda x . x)$.
The variable $x$ occurs both free and bound in this term.

\begin{definition}[$\alpha$-equality]
  We say that two $\Lam$-terms are $\alpha$-equal when they only differ by the name of their variable that occur bound.
\end{definition}

\begin{remark}
  The previous informal definition lets us take advantage of a variable naming convention introduced below.
  With this notion of $\alpha$-equality, the definition of substitution over $\Lam$-terms and meta-discussion of our syntax will be simplified.
  After defining the substitution operation we will rigorously introduce the definition for $\alpha$-equivalence.
\end{remark}

\begin{convention} 
  We will use the \textit{variable convention} introduced in \cite{Barendregt1987}.
  Without loss of generality, every $\Lam$-term that we refer from now on is chosen (via $\alpha$-equality) to have different names for bound and free occurrences of variables.
\end{convention}

\begin{definition}[Substitution]
  For every $\Lam$-term $M$, we recursively define the substitution of $N$ for the free occurrences of $x$ in $M$, $M[x := N]$, as follows:
  \begin{align*}
    & x[x := N] = N; \\
    & y[x := N] = y, \ \text{with $x \neq y$}; \\
    & (\lambda y . M_1)[x := N] = \lambda y . (M_1[x := N]); \\
    & (M_1 M_2)[x := N] = (M_1[x := N]) (M_2[x := N]).
  \end{align*}
\end{definition}


\begin{remark}
  Is is important to notice that by variable convention, the substitution operation described is capture-avoiding: the free variables in $N$ will not be affected by the binders in $M$, as they are chosen to have different names. 
\end{remark}


\begin{definition}[Compatible Relation]
  Let $R$ be a binary relation on $\Lam$-terms.
  We say that $R$ is compatible if it satisfies:
  \[
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (\lambda x . M_1, \lambda x . M_2) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (N M_1, N M_2) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (M_1 N, M_2 N) \in R }
    \end{prooftree}
  \]
\end{definition}


\begin{notation}
  Given a binary relation $R$ on $\Lam$-terms, we define:
  \begin{align*}
    & \to_R \text{as the compatible closure of $R$} ; \\
    & \twoheadrightarrow_R \text{as the reflexive and transitive closure of $\to_R$} ; \\
    & =_R \text{as the equivalence relation generated by $\twoheadrightarrow_R$}.
  \end{align*}
\end{notation}


\begin{definition}[$\alpha$-equivalence]
  Consider the following binary relation on $\Lam$-terms:  
  \[
    \alpha = \{ (\lambda x . M, \lambda y . M[x := y]) \
                | \ \text{for every $\Lam$-term $M$ and variable $y$ not occurring in $M$} \}.
  \]  
  We call $\alpha$-equivalence to the equivalence relation $=_\alpha$.
\end{definition}


\begin{definition}[$\beta$-reduction]
  \label{beta-reduction}
  Consider the following binary relation on $\Lam$-terms:  
  \[
    \beta = \{ ((\lambda x . M) N, M[x := N]) \
                | \ \text{for every variable $x$ and $\Lam$-terms $M, N$} \}.
  \]  
  We call one step $\beta$-reduction to the relation $\to_\beta$ and multistep $\beta$-reduction to the relation $\twoheadrightarrow_\beta$.
\end{definition}


\begin{definition}[($\beta$-)irreducible]
  We say that a $\Lam$-term $t$ is irreducible by $\to_\beta$ when there exists no $\Lam$-term $t'$ such that
  \[ t \to_\beta t' . \]
\end{definition}


\begin{definition}[$\beta$-normal forms]
  \label{beta_nfs}
  We inductively define the sets of $\Lam$-terms in $\beta$-normal form, NF, and of normal applications, NA, as follows:
  \[
    \begin{prooftree}
      \infer0{ x \in \text{NA} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ M_1 \in \text{NA} }
      \hypo{ M_2 \in \text{NF} }            
      \infer2{ M_1 M_2 \in \text{NA} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ M \in \text{NA} }
      \infer1{ M \in \text{NF} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ M \in \text{NF} }
      \infer1{ \lambda x . M \in \text{NF} } 
    \end{prooftree}
  \]
\end{definition}

\begin{claim}
  \label{beta_nfs_claim}
  Given a $\Lam$-term $M$, the following are equivalent:

  (i) $M \in \text{NF}$;

  (ii) $M$ is irreducible by $\to_\beta$.
\end{claim}

We leave this claim here, but we will show the mechanised proof for $\boxed{\text{(i)} \Rightarrow \text{(ii)}}$ in the last section of this chapter.
The proof for $\boxed{\text{(ii)} \Rightarrow \text{(i)}}$ is also mechanised in the script repository of our development.

% --- 

\subsection{Types}

\begin{definition}[Simple Types]
  The simple types are defined by the following grammar:  
  \[
    A, B, C ::= p \ | \ (A \supset B),
  \]
  where $p$ denotes a type variable.
\end{definition}

\begin{remark} \hfill
  \begin{enumerate}
  \item A denumerable set of atomic variables is assumed and letters $p, q, r$ range over this set.
  \item Notice that we use the symbol $\supset$, coming from logic, to denote implication.
    This is motivated by the well-known correspondence between function types and implicational proposition, through the Curry-Howard isomrphism.
  \end{enumerate}
\end{remark}

\begin{notation}
  We will assume the usual notational conventions on simple types. 
  \begin{enumerate}
  \item Outermost parentheses are omitted.
  \item Types associate to the right. Therefore, the type $A \supset (B \supset C)$ may often be written simply as $A \supset B \supset C$.
  \end{enumerate}
\end{notation}

\begin{definition}[Type-assignment]
  A type-assignment~$M : A$ is a pair of a $\Lam$-term and a simple type.
  We call subject to the $\Lam$-term $M$ and predicate to the simple type $A$.
\end{definition}

\begin{definition}[Context]
  A context~$\Gamma, \Delta, \dots$ is a finite (possibly empty) set of type-assignments whose subjects are variables of $\Lam$-terms and which is consistent. By consistent we mean that no variable is the subject of more than one type-assignment.
\end{definition}

\begin{notation} We may simplify the set notation of contexts as follows:
  \begin{align*}
    x:A, \dots, y:B         \quad &\text{for} \quad \{ x:A, \dots, y:B \} \\
    x:A, \dots, y:B, \Gamma \quad &\text{for} \quad \{ x:A, \dots, y:B \} \cup \Gamma.
  \end{align*}
\end{notation}

\begin{definition}[Sequent]
  A sequent~$\Gamma \vdash M:A$ is a triple of a context, a $\Lam$-term and a simple type.
\end{definition}

\begin{definition}[Typing rules for $\Lam$-terms]
  \label{typing_rules}
  The following typing rules inductively define the notion of derivable sequent.
  \[
    \begin{prooftree}
      \infer0[Var]{ x:A, \Gamma \vdash x:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ x:A, \Gamma \vdash M:B }
      \infer1[Abs]{ \Gamma \vdash \lambda x . M : A \supset B  } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash M : A \supset B }
      \hypo{ \Gamma \vdash N : A }	
      \infer2[App]{ \Gamma \vdash M N : B } 
    \end{prooftree}
  \]
  A sequent is derivable when it it at the root of a tree constructed by the successive application of the typing rules and whose leaves are instances of the Var-rule.  
\end{definition}

% ---
% 123
% ---

\section{$\Lam$-calculus with de~Bruijn syntax}

In the 1970s, de Bruijn started working on the \textit{Automath} proof assistant and proposed a simplified syntax to deal with generic binders \cite{deBruijn}.
This approach is claimed by the author to be good for meta-lingual discussion and for implementation in computer programmes.
In contrast, this syntax is further away from the human reader.
This section will serve as an intermediate step to the mechanised version of the simply typed $\Lam$-calculus described in the next section.

The main idea behind de~Bruijn syntax (or sometimes called de~Bruijn indices) is to treat variables as natural numbers (or indices) and to interpret these numbers as the distance to the respective binder.
Therefore, we will call these terms \textit{nameless}. 

\begin{definition}[Nameless $\Lam$-terms]
  The nameless $\Lam$-terms are defined by the following grammar:
  \[ M, N \ ::= \ i \ | \ \lambda . M \ | \ M N \ , \]  
  where $i$ ranges over the natural numbers.
\end{definition}

\begin{remark}
  Nameless $\Lam$-terms have no $\alpha$-conversion since there is no freedom to choose the names of bound variables.
\end{remark}

We show below some examples that illustrate the connection of ordinary and nameless syntax for $\Lam$-terms.
\begin{align*}
  \lambda x . x &\rightsquigarrow \lambda . 0 \\
% (\lambda x . xx)(\lambda x . xx) &\rightsquigarrow (\lambda . 00)(\lambda .00) \\
  \lambda x . \lambda y . x &\rightsquigarrow \lambda . \lambda . 0 \\
  \lambda x . \lambda y . x &\rightsquigarrow \lambda . \lambda . 1
\end{align*}

Now, we will present a different formulation for the concept of substitution, adequate to deal with nameless $\Lam$-terms.
\begin{definition}[Substitution]
  A substitution $\sigma, \tau, \dots$ over nameless $\Lam$-terms is a function mapping natural numbers (indices) to nameless $\Lam$-terms.
\end{definition}

Here are some examples of useful substitutions.
\begin{align*}
  id(k) &= k \\
  \uparrow(k) &= k+1 \\
  (M \cdot \sigma)(k) &=
                        \begin{cases}
                          M & \ \text{if $k = 0$} \\
                          \sigma(k-1) & \ \text{if $k > 0$}
                        \end{cases}
\end{align*}

\begin{definition}[Instantiation and composition]
  The operation of instantiating a nameless $\Lam$-term $M$ under a substitution $\sigma$, $M[\sigma]$, is recursively defined by the following equations:
  \begin{align*}
    & i[\sigma] = \sigma(i); \\
    & (\lambda . M)[\sigma] = \lambda . (M[0 \cdot (\uparrow \circ \ \sigma)]); \\
    & (M_1 M_2)[\sigma] = (M_1[\sigma]) (M_2[\sigma]);
  \end{align*}

  where the composition of two substitutions is mutually defined as $(\tau \circ \ \sigma)(k) = \sigma(k)[\tau]$.
\end{definition}

This definition for instantiation describes a capture-avoiding substitution operation that replaces all free variables simultaneously.
Thus, we may also refer to these substitutions as parallel substitutions.
It is based on the ideas introduced in~\cite{AutosubstSchafer} and is very close to the actual mechanisation done using the \textit{Autosubst} library.

Another variation we may encounter when formalising $\Lam$-terms using a nameless syntax is the typing system.
A similar aproach to our modification of the typing system can be found in~\cite[Chapter~7]{AndrewAdams}.
We formulate the definition of context and derivable sequents in the nameless setting as follows.

\begin{definition}[Nameless context]
  A nameless context~$\Gamma, \Delta, \dots$ is a finite (possibly empty) sequence of simple types.
\end{definition}

\begin{notation} \hfill
  
  $| \Gamma |$ is used to denote the length of context $\Gamma$;

  $\Gamma_i$ is used to denote the $i$th element of a context $\Gamma$, given $i < | \Gamma |$.
\end{notation}

\begin{definition}[Typing rules for nameless $\Lam$-terms]
  \label{nameless_typing_rules}
  \[
    \begin{prooftree}
      \hypo{ \Gamma_i = A }
      \infer1[Var]{ \Gamma \vdash i:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ A, \Gamma \vdash M:B }
      \infer1[Abs]{ \Gamma \vdash \lambda . M : A \supset B  } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash M : A \supset B }
      \hypo{ \Gamma \vdash N : A }	
      \infer2[App]{ \Gamma \vdash M N : B } 
    \end{prooftree}
  \]
\end{definition}

\begin{comment}
\begin{remark}
  \label{nameless_typing_remark}
  For such strict definitions of contexts and typing rules we would require admissibility for structural rules (like the weakening rule shown below).
  \[
    \begin{prooftree}
      \hypo{ \Gamma \vdash M:A }
      \infer1[Weakening]{ B, \Gamma \vdash M[\uparrow]:A } 
    \end{prooftree}
  \]
  That way, we show that our contexts as sequences may behave as multisets (as expected).
\end{remark}
\end{comment}

\begin{claim}
  \label{nameless_typing_claim}  
  Structural rules of weakening, contraction and exchange are admissible in this setting.
\end{claim}

We look at the particular case of the weakening rule that corresponds to the incrementation of every index of the nameless $\Lam$-term.
\[
  \begin{prooftree}
    \hypo{ \Gamma \vdash M:A }
    \infer1[Weakening]{ B, \Gamma \vdash M[\uparrow]:A } 
  \end{prooftree}
\]

% ---
% 123
% ---

\section{Mechanising meta-theory in \textit{Rocq}}

In this section we discuss basic questions arising in the formalisation of syntax with binders, and introduce a \textit{Rocq} library that helps with such task.
Additionally, we illustrate how to formalise basic concepts of the simply typed lambda calculus.
This will help to understand our main decisions on the mechanisation of meta-theory developed in this dissertation.
The multiary versions of the $\Lam$-calculus that we are going to introduce will follow closely the basic approach described here with the corresponding adaptations.

\subsection{The \textit{Rocq Prover}}

The \textit{Rocq Prover} (former \textit{Coq Proof Assistant}) \cite{RocqManual} is an interactive theorem prover based on the expressive formal language called the Polymorphic, Cumulative Calculus of Inductive Constructions.
This is a tool that helps in the formalisation of mathematical results and that can interact with a human to generate machine-verified proofs.
\textit{Rocq} encode propositions as types and proofs for these propositions as programs in $\Lam$-calculus, in line with the Curry-Howard isomorphism.

It is arguably a great tool for mechanising meta-theory as it was widely used in the \textit{POPLmark} challenge \cite{POPLmark}.
Also, this proof assistant provides many libraries to deal with the issue of variable binding, like \textit{Autosubst}, as we will see in the next sections.

We illustrate two examples of simple inductive definitions in \textit{Rocq}: the natural numbers and polymorphic lists.

\subsubsection{Natural numbers}
The natural numbers can be inductively defined as either zero or a successor of a natural number.
\begin{lstlisting}[language=Coq]
Inductive nat : Type :=
| O
| S (n: nat).
\end{lstlisting}

For example, the number $0$ is represented by the constructor \lst$O$ and number $2$ is represented as \lst$S (S O)$.
Of course this serves as an internal representation and we will not refer to natural numbers using these constructors.
We can also check the induction principle that \textit{Rocq} generates for the natural numbers.
\begin{lstlisting}[language=Coq]
  nat_ind
     : forall P : nat -> Prop,
       P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n
\end{lstlisting}

Therefore, if we want to prove that the sum of natural numbers is associative, we can do it using this induction principle as follows.
\begin{lstlisting}[language=Coq]
Theorem sum_associativity :
  forall a b c, a+(b+c) = (a+b)+c.
  Proof.
    intros.
    induction a.
    - (* 0+(b+c) = 0+b+c *)
      simpl.       (* simplify equation *)
      reflexivity. (* now both sides are equal *)        
    - (* (a+1)+(b+c) = (a+1)+b+c *)
      simpl.       (* simplify equation *)
      rewrite IHa. (* rewrite with induciton hypothesis *)
      reflexivity. (* now both sides are equal *)
Qed.
\end{lstlisting}

\subsubsection{Polymorphic lists}
Polymorphic lists are lists whose items have no predefined type.
The inductive definition for these lists is available in the \textit{Rocq} standard library (\lst$Library Stdlib.Lists.List$) along with many operations and properties.
Their definition is as follows: 

\begin{lstlisting}[language=Coq]
Inductive list (A: Type) : Type :=
| nil
| cons (u: A) (l: list A).
\end{lstlisting}

For example, if we wanted to have a type for lists of natural numbers, we could just invoke the type \lst$list nat$.
The list \lst$[0,2,1]$ is then represented as \lst$cons 0 (cons 2 (cons 1 nil))$.

Here is an useful lemma on lists provided by the \textit{Rocq} library:
\begin{lstlisting}[language=Coq]
Lemma map_app f : forall l l', map f (l++l') = (map f l)++(map f l').
\end{lstlisting}

This lemma relates two operations on lists:
\begin{enumerate}
\item \lst$app$ (abreviated as \lst$++$): appends two lists (ex: \lst$[1,2,3]++[4,5] = [1,2,3,4,5]$);
\item \lst$map$: applies a function to every element on the list (ex: \lst$map f [x,y] = [f x, f y]$).
\end{enumerate}
Given their widespread utility, these operations will be often used in parts of our mechanisation.

\subsection{Syntax with binders}

% If we were to formalise such a system like the $\Lam$-calculus introduced above, we would probably create an inductive type like the following, in \textit{Coq}.
A direct formalisation of the grammar of $\Lam$-terms in \textit{Rocq} results in an inductive definition like:
\begin{lstlisting}[language=Coq]
Inductive term : Type :=
| Var (x: var)
| Lam (x: var) (t: term)
| App (s: term) (t: term).
\end{lstlisting}

The question that this and any similar definition raises is: how do we define the \lst$var$ type? Following the usual pen-and-paper approach, this type would be a subset of a "string type", where a variable is just a placeholder for a name.

Of course this is fine when dealing with proofs and definitions in a paper.
To simplify this, we can even take advantage of conventions, like the one referenced above (by Barendregt).
However, this approach to define the \lst$var$ type becomes rather exhausting when it comes to rigorously define the required syntactical ingredients, including substitution operations.

There are several alternative approaches described in the literature of mechanisation of meta-theory. 
The \textit{POPLmark} challenge \cite{POPLmark} points to the topic of binding as central for discussing the potential of modern-day proof assistants.
From the many alternatives, we chose to follow the nameless syntax proposed by de~Bruijn.
This is because this approach seemed widely used in the mechanisation of meta-theory.

\subsection{Autosubst library}

The \textit{Autosubst} library~\cite{AutosubstSchafer,AutosubstManual} for the \textit{Rocq Prover} facilitates the formalisation of syntax with binders.
It provides the \textit{Rocq Prover} with two kinds of tactics:
\begin{enumerate}
  \item \lst$derive$ tactics that automatically define substitution (and boilerplate definitions for substitution) over an inductively defined syntax;
  \item \lst$asimpl$ and \lst$autosubst$ tactics that provide simplification and direct automation for proofs dealing with substitution lemmas.
\end{enumerate}

The library makes use of some ideas we have already covered up: de~Bruijn syntax and parallel substitutions.
There is also a more subtle third ingredient: the theory of explicit substitution \cite{Abadi}.
This theory is particularly relevant to the implementation of the \lst$asimpl$ and \lst$autosubst$ tactics and we will not digress much on it.
Essentially, our calculus with parallel substitutions forms a model of the $\sigma$-calculus and we may simplify our terms with substitutions using the convergent rewriting equations described by this theory.

Taking the naive example of an inductive definition of the $\Lam$-terms in \textit{Rocq}, we now display a definition using \textit{Autosubst}.

\begin{lstlisting}[language=Coq]
Inductive term: Type :=
| Var (x: var)
| Lam (t: {bind term})
| App (s: term) (t: term) .
\end{lstlisting}

In the above definition, there are two different annotations: the \lst$var$ and \lst${bind term}$ types.
We write these annotations to mark our constructors with variables and binders, respectively, in the syntax we want to mechanise.
They play an important role in the internal development of the automated \lst$derive$ tactics.

We invoke the \textit{Autosubst} classes, automatically deriving the desired instances as follows.

\begin{lstlisting}[language=Coq]
Instance Ids_term : Ids term. derive. Defined.
Instance Rename_term : Rename term. derive. Defined.
Instance Subst_term : Subst term. derive. Defined.
Instance SubstLemmas_term : SubstLemmas term. derive. Defined.
\end{lstlisting}

The first three lines derive the operations necessary to define the (parallel) substitution over a term.
\begin{enumerate}
\item Defining the \lst$ids$ function that maps every index into the corresponding variable term ($i \mapsto $ \lst$(Var i)$).
\item Defining the \lst$rename$ function that instantiates a term under a variable renaming.
\item Defining the \lst$subst$ function that instantiates a term under a parallel substitution over (making use of the already \lst$rename$ and $ids$).
\end{enumerate}

Finally, there is also the proof for the substitution lemmas.
Here, we see the power of this library, as the proofs for these lemmas (for fairly simple syntaxes) can be generated automatically through the \lst$derive$ tactic. 

% exemplos de provas que usem asimpl ou autosubst?

\subsection{Mechanising the simply typed $\Lam$-calculus}

For this dissertation, we provide our own mechanisation of the simply typed $\Lam$-calculus, as we will need it in~\cref{c:isomorphism}.
The mechanisation is very straightforward and follows closely the examples given in~\cite{AutosubstManual,AutosubstSchafer}.

\subsubsection{\lst$SimpleTypes.v$}

This module only contains the definition for simple types using a unique base type for simplicity.
This definition is isolated because it will be used by multiple modules.
\begin{lstlisting}[language=Coq]
Inductive type: Type :=
| Base
| Arr (A B: type): type.
\end{lstlisting}

\subsubsection{\lst$Lambda.v$}

This module contains the definitions we need for the formalisations dealing with the simply typed $\Lam$-calculcus.
The syntax for terms and \textit{Autosubst} definitions were already presented and explained in the prior subsection.

The module then includes the definition for the one step $\beta$-relation (recall~\cref{beta-reduction}).
This inductive definition mechanises the $\beta$ relation altogether with the compatibility closure ($\to_\beta$).
\begin{lstlisting}[language=Coq]
Inductive step : relation term :=
| Step_Beta s s' u : s' = s.[u.:ids] ->
step (App (Lam s) t) s'
| Step_Abs s s' : step s s' ->
step (Lam s) (Lam s')
| Step_App1 s s' t: step s s' ->
step (App s t) (App s' t)
| Step_App2 s t t': step t t' ->
step (App s t) (App s t').
\end{lstlisting}

In this definition we already give use to the substitution operation defined using \textit{Autosubst} (found in the \lst$Step_Beta$ constructor).
The syntax \lst$s.[u.:ids]$ is just notation for the defined instantiation of term $s$ under a parallel substitution \lst$u.:ids$.
This substitution corresponds to the example of substitution shown in the previous section $(u \cdot id)$.

The type for \lst$step$ is \lst$relation term$ (an alias for \lst$term->term->Prop$), as we are using the \lst$Relations$ library found in the \textit{Rocq} standard library containing definitions and lemmas for binary relations.

We also have a definition for the mutually inductive predicate mechanising $\beta$-normal forms (recall~\cref{beta_nfs}).
\begin{lstlisting}[language=Coq]
Inductive normal: term -> Prop :=
| nLam s : normal s -> normal (Lam s)
| nApps s : apps s -> normal s  
with apps: term -> Prop :=
| nVar x : apps (Var x)
| nApp s t : apps s -> normal t -> apps (App s t).
\end{lstlisting}

As before, we do not define directly a set NF of $\Lam$-terms, but rather an inductive predicate that $\Lam$-terms $t \in \text{NF}$ satisfy.
This will be our standard aproach when mechanising subsets, as the subset itself is the extension of the defined predicate.

However, we have to be careful using mutually inductive predicates (we refer to~\cite[Chapter~14.1]{CoqArt} for a detailed overview on mutually inductive types and their induction principles).
If we want to prove certain propositions that proceed by indcution on the structure of a normal term, we need to have a simultaneous induction principle and prove two propositions simultaneously.
\begin{lstlisting}[language=Coq]
Scheme sim_normal_ind := Induction for normal Sort Prop
  with sim_apps_ind := Induction for apps Sort Prop.
Combined Scheme mut_normal_ind from sim_normal_ind, sim_apps_ind.
\end{lstlisting}

We can generate two new induction principles using the \lst$Scheme$ command.
Then, we can combine both induction principles using the \lst$Combined Scheme$ command.
We will often use the combined induction principles in our proofs, as mutually inductive types will appear often. 

Here follows an example of the proof for~\cref{beta_nfs_claim} using the combined induction principle.
We will prove not only the desired claim but also a proposition over the set of normal applications, NA.

\begin{lstlisting}[language=Coq]
Theorem nfs_are_irreducible :
  (forall s, normal s -> ~exists t, step s t)
  /\
  (forall s, apps s -> ~exists t, step s t).
Proof.
  apply mut_normal_ind ; intros.
  (* applying the combined induction principle *)
  - intro.
    apply H.
    destruct H0 as [t Ht].
    inversion Ht.
    now exists s'.
  - intro.
    apply H.
    destruct H0 as [t Ht].
    now exists t.
  - intro.
    now destruct H.
  - intro.
    destruct H1 as [t0 Ht0].
    inversion Ht0 ; subst.
    + inversion a.
    + apply H. now exists s'.
    + apply H0. now exists t'.
Qed.
\end{lstlisting}

The proof uses a couple of tactics that we will not cover in detail.
It serves more of an example of how we easily prove a result using the mechanised concepts of one step $\beta$-reduction and normal forms.

The last thing our module contains is the typing rules for the $\Lam$-terms (recall~\cref{typing_rules} and \cref{nameless_typing_rules}).

\begin{lstlisting}[language=Coq]
Inductive sequent (Gamma: var->type) : term -> type -> Prop := 
| Ax (x: var) (A: type) :
  Gamma x = A -> sequent Gamma (Var x) A
| Intro (t: term) (A B: type) :
  sequent (A.:Gamma) t B -> sequent Gamma (Lam t) (Arr A B)
| Elim (s t: term) (A B: type) :
  sequent Gamma s (Arr A B) -> sequent Gamma t A -> sequent Gamma (App s t) B.
\end{lstlisting}

We directly mechanise the derivability of a sequents using an inductively defined predicate (instead of defining sequents \textit{a priori}).

Furthermore, following the approach in \cite{AutosubstManual}, we use infinite contexts (contexts as infinite sequences).
That way we can mechanise contexts as functions \lst$var->type$ (the type of a parallel substitution object over \lst$type$) and take more advantage of the \textit{Autosubst} definitions and tactics.
Of course, in any typing derivation, only a finite part of the (infinite) context is used.

A small illustration of the versatility of this option is in the \lst$Intro$ rule, where one can find the context \lst$(A.:Gamma)$.
This is the same function we encountered when defining the substitution operation for the $\beta$-contractum \lst$s.[u.:ids]$.

As claimed (\cref{nameless_typing_claim}) upon the definition of the typing rules for the nameless terms, we can show admissibility for the structural rules of weakening, contraction and exchange.
We do this by proving the preservation of renamings (also an idea from~\cite{AutosubstManual}), as the mentioned structural rules can be seen as a particular case of index renaming (as we have illustrated with the weakening case).

\begin{lstlisting}[language=Coq]
Lemma type_renaming : forall Gamma t A, sequent Î“ t A ->
  forall Delta xi, Gamma = (xi >>> Delta) -> sequent Delta t.[ren xi] A
\end{lstlisting}
  
%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
