\chapter{Background}
\label{c:background}

% In this chapter, we intend to take the example of formalising some theory about the $\Lam$-calculus as a motivation to display some core aspects involved in the more elaborate formalisations ahead.

The following chapter introduces essential background to aid the reading of this dissertation.
% It will take the scheme used in the subsequent chapters:
% a first part of theoretical presentation and a second part of mechanisation.
First, we introduce the well-known simply typed $\Lam$-calculus.
Then, we delve into the theory on mechanisation of meta-theory, specifically in the context of our work.
These concepts are introduced and motivated by the task of formalising the $\Lam$-calculus system introduced.

\section{Lambda Calculus}

\subsection{Syntax}

\cite{Hindley1997} \cite{Barendregt1987}

\begin{definition}[$\Lam$-terms]
  The $\Lam$-terms are defined by the following grammar:
  \[ M, N \ ::= \ x \ | \ (\lambda x . M) \ | \ (M N) \]
  where $x$ denotes any variable, typically in the range of $x, y, z$.
\end{definition}

\begin{notation}
  We shall assume the usual notation conventions on $\Lam$-terms:

  \begin{enumerate}
  \item Outermost parenthesis are omitted.
  \item Multiple abstractions can be abreviated as $\lambda x y z . M$ instead of  $\lambda x . (\lambda y . (\lambda z . M))$.
  \item Multiple applications can be abreviated as $M N_1 N_2$ instead of $(M N_1) N_2$.
  \end{enumerate}
\end{notation}

\begin{definition}[Free variables]
  For every $\Lam$-term $M$, we recursively define the set of free variables in $M$, $FV(M)$, as follows:  
  \begin{align*}
    & FV( x ) = \{ x \}, \\
    & FV( \lambda x . M ) = FV(M) - \{ x \}, \\
    & FV( M N ) = FV(M) \cup FV(N).
  \end{align*}

  When a variable occurring in a term is not free it is said to be bound.
\end{definition}

% \begin{remark}
%   Informally, abstractions will behave as functions.
%   As so, we do not care about the names of bound variables. 
%   This idea is formally introduced next.
% \end{remark}

\begin{definition}[$\alpha$-equality]
  We say that two $\Lam$-terms are $\alpha$-equal when they only differ in the name of their bound variables.
\end{definition}

\begin{remark}
  The previous informal definition lets us take advantage of a variable naming convention.
  With this notion of $\alpha$-equality, the definition of substitution over $\Lam$-terms and meta-discussion of our syntax will be simplified.
  % After defining the substitution operation we may introduce a better and more formal definition of the $\alpha$-conversion.
  After defining the substitution operation we will rigorously introduce the definition for $\alpha$-conversion.
\end{remark}

\begin{convention} 
  We will use the \textit{variable convention} introduced in \cite{Barendregt1987}.
  Every $\Lam$-term that we refer from now on is chosen (via $\alpha$-equality) to have bound variables with different names from free variables.
\end{convention}

\begin{definition}[Substitution]
  For every $\Lam$-term $M$, we recursively define the substitution of the free variable $x$ by $N$ in $M$, $M[x := N]$, as follows:
  \begin{align*}
    & x[x := N] = N; \\
    & y[x := N] = y \text{, with } x \neq y; \\
    & (\lambda y . M_1)[x := N] = \lambda y . (M_1[x := N]); \\
    & (M_1 M_2)[x := N] = (M_1[x := N]) (M_2[x := N]).
  \end{align*}
\end{definition}

\begin{remark}
  Is is important to notice that by variable convention, the substitution operation described is capture-avoiding
  - bound variables will not be substituted ($x \in FV(M)$) and the free variables in $N$ will not be affected by the binders in $M$, as they are chosen to have different names. 
\end{remark}

\begin{definition}[Compatible Relation]
  Let $R$ be a binary relation on $\Lam$-terms.
  We say that $R$ is compatible if it satisfies:
  \[
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (\lambda x . M_1, \lambda x . M_2) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (N M_1, N M_2) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (M_1 N, M_2 N) \in R }
    \end{prooftree}
  \]
\end{definition}


\begin{notation}
  Given a binary relation $R$ on $\Lam$-terms, we define:
  \begin{align*}
    & \to_R \text{as the compatible closure of $R$} ; \\
    & \twoheadrightarrow_R \text{as the reflexive and transitive closure of $\to_R$} ; \\
    & =_R \text{as the equivalence relation generated by $\twoheadrightarrow_R$}.
  \end{align*}
\end{notation}


\begin{definition}[$\alpha$-conversion]
  Consider the following binary relation on $\Lam$-terms:  
  \[
    \alpha = \{ (\lambda x . M, \lambda y . M[x := y]) \
                | \ \text{for every $y$ not occurring in $M$} \}.
  \]  
  We call $\alpha$-conversion to the generated $=_\alpha$ relation.
\end{definition}


\begin{definition}[$\beta$-reduction]
  Consider the following binary relation on $\Lam$-terms:  
  \[
    \alpha = \{ ((\lambda x . M) N, M[x := N]) \
                | \ \text{for every $M, N$} \}.
  \]  
  We call one step $\beta$-reduction to the relation $\to_\beta$ and multistep $\beta$-reduction to the relation $\twoheadrightarrow_\beta$.
\end{definition}


\begin{definition}[$\beta$-normal forms]
  We inductively define the set of $\Lam$-terms in $\beta$-normal form, NF, and normal applications, NA, as follows:
  \[
    \begin{prooftree}
      \infer0{ x \in \text{NA} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ M_1 \in \text{NA} }
      \hypo{ M_2 \in \text{NF} }            
      \infer2{ M_1 M_2 \in \text{NA} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ M \in \text{NA} }
      \infer1{ M \in \text{NF} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ M \in \text{NF} }
      \infer1{ \lambda x . M \in \text{NF} } 
    \end{prooftree}
  \]
  These $\Lam$-terms are irreducible according to $\to_\beta$.
\end{definition}

% --- 

\subsection{Types}

\cite{Barendregt2013}

\begin{definition}[Simple Types]
  The simple types are defined by the following grammar:  
  \[
    A, B, C ::= p \ | \ (A \supset B)
  \]
  where $p$ denotes any atomic variable, typically in the range of $p, q, r$.
\end{definition}

\begin{notation}
  We will assume the usual notation conventions on simple types. 
  \begin{enumerate}
  \item Outermost parenthesis are omitted.
  \item Types associate to the right. Therefore, the type $A \supset (B \supset C)$ may often be written simply as $A \supset B \supset C$.
  \end{enumerate}
\end{notation}

\begin{definition}[Context]
  A context, $\Gamma, \Delta, \dots$, is a partial function from the variables of $\Lam$-terms to simple types.
\end{definition}

\begin{notation} \hfill
  \begin{enumerate}
  \item We may often refer to the partial function of as the set of pairs $(x, A)$ written as $x:A$.
  \item We will also simplify the set notation of contexts as follows:
    \begin{align*}
      &\mapsto \{ \} \\
      x:A         &\mapsto \{ x:A \} \\
      x:A, \Gamma &\mapsto \{ x:A \} \cup \Gamma
    \end{align*}
  \end{enumerate}
\end{notation}

\begin{definition}[Typing Rules for $\Lam$-terms]
  A type-assignment or sequent is a triple, $\Gamma \vdash M:A$, that is inductively defined by the following inference rules (or typing rules):
  \[
    \begin{prooftree}
      \infer0[Var]{ x:A, \Gamma \vdash x:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ x:A, \Gamma \vdash M:B }
      \infer1[Abs]{ \Gamma \vdash \lambda x . M : A \supset B  } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash M : A \supset B }
      \hypo{ \Gamma \vdash N : A }	
      \infer2[App]{ \Gamma \vdash M N : B } 
    \end{prooftree}
  \]
\end{definition}

% ---

\section{Mechanising Meta-theory in \textit{Rocq}}

Having introduced the ordinary $\Lam$-calculus, we take it as an object of formalisation.
This helps motivating the main decisions behind our mechanisations.

% The mechanisation done is dependent on the theory provided by the \textit{Rocq Prover} - the Calculus of Inductive Constructions.
% We will follow assuming a basic knowledge on \textit{Rocq} and its syntax. % to define inductive types and proof techniques.

\subsection{The \textit{Rocq Prover}}

(calculus of inductive constructions)

(Check Kathrin Stark introduction)

(Exemplo do tipo inductivo para inteiros?)

(Tipos mutuamente inductivos? Combined Schemes?)

\subsection{Syntax with Binders}

% If we were to formalise such a system like the $\Lam$-calculus introduced above, we would probably create an inductive type like the following, in \textit{Coq}.
Formalising the $\Lam$-calculus in \textit{Rocq} would generate an inductive definition similar to:

\begin{lstlisting}[language=Coq]
  Inductive term : Type :=
  | Var (x: var)
  | Lam (x: var) (t: term)
  | App (s: term) (t: term).
\end{lstlisting}

The question that every similar definition imposes is the definition of the $var$ type. Following the usual pen and paper approach, this type would be a subset of a string type, where a variable is just a placeholder for a name.

Of course this is fine when dealing with pen and paper proofs and definitions. To simplify this, we can even take advantage of conventions, like the one referenced above (by Barendregt). 
However, this variable definition can get rather exhausting  when it comes to rigorously define all this syntactical aspects and substitution operations.

There are several alternatives described in the literature of mechanisation of meta-theory. 
% This topic of binding was \sout{even} proposed in the POPLmark challenge \cite{POPLmark} as a way to discuss the potential of proof assistants.
The POPLmark challenge \cite{POPLmark} points to the topic of binding as central for discussing the potential of modern-day proof assistants.

% Among the available solutions for the \textit{Coq} proof assistant, the \textit{AUTOSUBST} library .
The \textit{Autosubst} library for the \textit{Rocq Prover} stood out as a great solution for our case. 
This library uses a combination of de Bruijn indices and explicit parallel substitutions to \sout{tackle this "problem"}.

% POPl Mark
% falar de substituicoes ???

\subsection{De Bruijn Syntax}

\cite{deBruijn} \cite{AutosubstSchafer}

In the 1970s, de Bruijn started working on the \textit{Automath} proof assistant and proposed a simplified syntax to deal with generic binders \cite{deBruijn}.
This approach is claimed to be good for meta-lingual discussion and for the computer and computer programme. In contrast, this syntax is further away from the human reader.

The main idea is to treat variables as indices (represented by natural numbers) and to interpret these indices as the distance to the respective binder.
Therefore, we will call these terms nameless. 
% $\Lam$-terms the nameless $\Lam$-terms.

\begin{definition}[nameless $\Lam$-terms]
  The nameless $\Lam$-terms are defined by the following grammar:

  \[ M, N \ ::= \ i \ | \ \lambda . M \ | \ M N \]

  where $i$ ranges over the natural numbers.
\end{definition}

\begin{remark}
  Nameless $\Lam$-terms have no $\alpha$-conversion since there is no freedom to choose the names of bound variables.
\end{remark}

% Referir ainda parallel substitutions

\begin{comment}
\subsection{Explicit Parallel Substitutions}

\cite{AutosubstSchafer}

We refer to explicit substitutions \cite{Abadi} when the substitution operation is part of the syntax calculus.
Often, substitutions are dealt at a meta level.
However, a definition of capture-avoiding substitution over nameless $\Lam$-terms will require manipulations over substitution objects \cite{deBruijn}.

Furthermore, having a reserved syntax for substitution helps us generalising this notion.
Previously, a substitution  was a term that was going to replace some free variable.
A parallel substitution generalizes this concept for every free variable. 

Now, we present a calculus with explicit parallel substitutions.
We can think of a parallel substitution as a sequence of terms, $\sigma = (M_i)_{i \in \mathbb{N}}$, where the term $M_i$ will replace the variable with index $i$.

\begin{definition}[$\Lam \sigma$-terms]
  The (nameless) $\Lam \sigma$-terms are defined by the following grammar:  
  \begin{align*}
    M, N         &::= \ 0 \ | \ \lambda . M \ | \ M N \ | \ M[\sigma] \\
    \sigma, \tau &::= \ id \ | \ \uparrow \ | \ M \cdot \sigma \ | \ \sigma \circ \tau
  \end{align*}
\end{definition}

\begin{remark} \hfill
	\begin{enumerate}
		\item $id$ is the identity substitution, this is, $id = (i)_{i \in \mathbb{N}}$,
		\item $\uparrow$ is the successor substitution, this is, $\uparrow = (i+1)_{i \in \mathbb{N}}$,
		\item $M \cdot \sigma$ is the cons substitution, this is, $M \cdot \sigma = (M, N_0, N_1, N_2, \dots)$ where $\sigma = (N_i)_{i \in \mathbb{N}}$,
		\item $\sigma \circ \tau$ is the composition substitution that satisfies
		\[ M[\sigma \circ \tau] = M[\sigma][\tau], \]
		\item $M[\sigma]$ is the instantiation of the parallel substitution $\sigma$ over the term $M$
		\item We only need the index 0 in our term syntax, as we can represent every index $i$ as $0[\underbrace{\uparrow \circ \dots \circ \uparrow}_{\text{$i$ times}}]$.
	\end{enumerate}
\end{remark}

% \begin{definition}[Rewriting System of $\sigma$-calculus]
Having an explicit notation for substitution, we can define the $\beta$-reduction step as 
\[ (\lambda . M) N \to_\beta M[N \cdot id]. \]

This is almost what we want. 
In most cases, we want to calculate our term $M[N \cdot id]$ modulo explicit substitutions, recovering the expected result for the substitution. We want to describe reduction rules for substitutions.
	
\begin{definition}[Rewriting rules for substitutions]
	\begin{align*}
		& 0[id] = 0 \qquad
		& id \circ s = s \\
		& 0[M \cdot \sigma] = M \qquad
		& \uparrow \circ \ id = \ \uparrow \\
		& (M N)[\sigma] = (M[\sigma])(N[\sigma]) \qquad
		& \uparrow \circ \ (M \cdot \sigma) = \sigma \\
		& (\lambda . M)[\sigma] = \lambda . (M[0 \cdot (\sigma \ \circ \uparrow)]) \qquad
		& (M \cdot \sigma) \circ \tau = M[\tau] \cdot (\sigma \circ \tau) \\
		& M[\sigma \circ \tau] = M[\sigma][\tau] \qquad
		& (\sigma_1 \circ \sigma_2) \circ \sigma_3 = \sigma_1 \circ (\sigma_2 \circ \sigma_3)
	\end{align*}
\end{definition}

In \cite{Abadi}, it is proved that these rules provide a complete rewriting system to eliminate terms of the form $M[\sigma]$.
\end{comment}

\subsection{The Autosubst Library}
\cite{AutosubstSchafer}

The \textit{Autosubst} library for the \textit{Rocq Prover} simplifies the formalisation of syntax with binders.
% This is obtained using the theory of explicit substitutions to fragment and clarify the description of substitution operations.
It provides the \textit{Rocq Prover} with tactics to define substitution over an inductively defined syntax.
Furthermore, it even offers some automation for proofs dealing with substitution lemmas.

It is supported over three main ingredients:
\begin{enumerate}
\item nameless (de Bruijn) syntax ;
\item parallel substitutions ;
\item explicit substitutions for automation.
\end{enumerate}

\vspace{2em} \hrule \vspace{2em}

Taking the naive example of an inductive definition of the $\Lam$-terms in \textit{Rocq}, we now display a definition using \textit{Autosubst}.

\begin{lstlisting}[language=Coq]
  Inductive term: Type :=
  | Var (x: var )
  | Lam (t: {bind term} )
  | App (s: term ) (t: term ) .
\end{lstlisting}

Here, the annotation ${bind term}$ is as alias of the type term.
We write this annotation in order to mark our binders in the syntax we want to formalise.  

This way, we may invoke the \textit{Autosubst} classes, automatically deriving the desired instances.

\begin{lstlisting}[language=Coq]
  Instance Ids_term : Ids term. derive. Defined.
  Instance Rename_term : Rename term. derive. Defined.
  Instance Subst_term : Subst term. derive. Defined.
  Instance SubstLemmas_term : SubstLemmas term. derive. Defined.
\end{lstlisting}

The first three lines derive the operations necessary to define the (parallel) substitution over a term.
\begin{enumerate}
\item Defining the function that maps every index into the corresponding variable term ($i \mapsto (Var \ i)$).
\item Defining the recursive function that instantiates a variable renaming over a term.
\item Defining the recursive function that instantiates a parallel substitution over a term (using the already defined renamings).
\end{enumerate}

Finally, there is also the proof of the substitution lemmas. 
Here, we see the power of this library: this process is done automatically, using the provided $derive$ tactic.

\subsection{On the Mechanisation of the $\Lam$-calculus}

We define the one step $\beta$ reduction altogether with the compatibility steps:
\begin{lstlisting}[language=Coq]
  Inductive step : relation term :=
  | Step_Beta s s' t : s' = s.[t .: ids] ->
                       step (App (Lam s) t) s'
  | Step_Abs s s' : step s s' ->
                    step (Lam s) (Lam s')
  | Step_App1 s s' t: step s s' ->
                      step (App s t) (App s' t)
  | Step_App2 s t t': step t t' ->
                      step (App s t) (App s t').
\end{lstlisting}

\vspace{2em} \hrule \vspace{2em}

Formalising the typing system:

\begin{lstlisting}[language=Coq]
  Inductive sequent (gamma: var->type) : term -> type -> Prop := 
  | Ax (x: var) (A: type) :
    gamma x = A -> sequent gamma (Var x) A
  | Intro (t: term) (A B: type) :
    sequent (A .:gamma) t B -> sequent gamma (Lam t) (Arr A B)
  | Elim (s t: term) (A B: type) :
    sequent gamma s (Arr A B) -> sequent gamma t A -> sequent gamma (App s t) B.
\end{lstlisting}

\begin{enumerate}
\item Contextos infinitos?
\end{enumerate}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
