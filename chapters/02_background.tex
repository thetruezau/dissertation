\chapter{Background}
\label{c:background}

% In this chapter, we intend to take the example of formalising some theory about the $\lambda$-calculus as a motivation to display some core aspects involved in the more elaborate formalisations ahead.

In the following chapter we will introduce some background to aid the reading of this dissertation.
% It will take the scheme used in the subsequent chapters:
%   a first part of theoretical presentation and a second part of mechanisation. 
First, we introduce the $\lambda$-calculus and some basic knowledge around it. Then, we introduce some theory related to the mechanisation part of this work. These concepts are introduced and motivated by the task of formalising the $\lambda$-calculus system introduced.

\section{Lambda Calculus}

\subsection{Syntax}

\cite{Hindley1997} \cite{Barendregt1987}

\begin{definition}[$\lambda$-terms]
  The $\lambda$-terms are defined by the following grammar:

  \[ M, N \ ::= \ x \ | \ (\lambda x . M) \ | \ (M N) \]

  where $x$ denotes any variable, typically in the range of $x, y, z$.
\end{definition}

\begin{notation}
  We will assume the usual notation conventions on $\lambda$-terms:

  \begin{enumerate}
  \item Outermost parenthesis are omitted.
  \item Multiple abstractions can be abreviated as $\lambda x y z . M$ instead of  $\lambda x . (\lambda y . (\lambda z . M))$.
  \item Multiple applications can be abreviated as $M N_1 N_2$ instead of $(M N_1) N_2$.
  \end{enumerate}
\end{notation}

\begin{definition}[Free variables]
  For every $\lambda$-term $M$, we recursively define the set of free variables in $M$, $FV(M)$, as follows:
  
  \begin{enumerate}
  \item $FV( x ) = \{ x \}$
  \item $FV( \lambda x . M ) = FV(M) - \{ x \}$
  \item $FV( M N ) = FV(M) \cup FV(N)$
  \end{enumerate}

  When a variable occurring in a term is not free it is said to be bound.
\end{definition}

% \begin{remark}
%   Informally, abstractions will behave as functions.
%   As so, we do not care about the names of bound variables. 
%   This idea is formally introduced next.
% \end{remark}

\begin{definition}[$\alpha$-equality]
  We say that two $\lambda$-terms are $\alpha$-equal when they only differ in the name of their bound variables.
\end{definition}

\begin{remark}
  The previous informal definition lets us take advantage of a variable naming convention.
  With this convention, the definition of substitution over $\lambda$-terms and meta-discussion of our syntax will be simplified.
  After defining the substitution operation we may introduce later a better and formal definition of this $\alpha$-equality.
\end{remark}

\begin{convention} 
  We will use the \textit{variable convention} introduced in \cite{Barendregt1987}, using only $\lambda$-terms that are chosen (via $\alpha$-equality) to have bound variables with different names from free variables.
\end{convention}

\begin{definition}[Substitution]
  For every $\lambda$-term $M$, we recursively define the substitution of the free variable $x$ by $N$ in $M$, $M[x := N]$, as follows:
  
  \begin{enumerate}
  \item $x[x := N] = N$
  \item $y[x := N] = y \quad$ (when $x \neq y$)
  \item $(\lambda y . M)[x := N] = \lambda y . (M[x := N]$)
  \item $(M_1 M_2)[x := N] = (M_1[x := N]) (M_2[x := N]$)
  \end{enumerate}

\end{definition}

\begin{definition}[Compatible Relation]
  We say that a binary relation in $\lambda$-terms, $R$, is compatible if it satisfies:

  \[
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (\lambda x . M_1, \lambda x . M_2) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (N M_1, N M_2) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (M_1, M_2) \in R }
      \infer1{ (M_1 N, M_2 N) \in R } 
    \end{prooftree}
  \] 
\end{definition}

\begin{definition}[$\alpha$-conversion]
\end{definition}

\begin{definition}[$\beta$-reduction]
\end{definition}

% examples , Reflexive Transitive closure of a relation , \alpha equality and \beta equality

\subsection{Types}

\cite{Barendregt2013}

\begin{definition}[Simple Types]  
\end{definition}

\begin{definition}[Tipification Rules]
\end{definition}

% ---

\section{Mechanising Meta-theory in \textit{Coq}}

The formalisation we aim at is dependent on the theory provided by the \textit{Coq} proof assistant - the Calculus of Inductive Constructions.
We will follow assuming a basic knowledge on \textit{Coq} and its syntax to define inductive types and proof techniques.

\subsection{How to Denote Variables?}

If we were to formalise such a system like the $\lambda$-calculus introduced above, maybe we would create an inductive type like the following, in \textit{Coq}.

\begin{lstlisting}[language=Coq]
  Inductive term : Type :=
  | Var (x: var)
  | Lam (x: var) (t: term)
  | App (s: term) (t: term).
\end{lstlisting}

The question that every similar definition imposes is the definition of the $var$ type. Following the usual pen and paper aproach, this type would be something similar to a subset of the string type, where a variable is just a placeholder for a name.

Of course this is fine when dealing with pen and paper proofs and definitions. Even, we can take advantage of conventions, like the one referenced above by Barendregt. However, this is becomes rather exhausting  when it comes to rigorously defining all this syntactical aspects.

% falar de substituicoes ???

\subsection{De Bruijn Syntax}

% definicao rigorosa de syntax de Bruijn?

In the 1970s, de Bruijn started working on the \textit{AUTOMATH} proof assistant and proposed a simplified syntax to deal with generic binders \cite{deBruijn}.
This approach is claimed to be good for meta-lingual discussion and for the computer and computer programme. In contrast, this syntax is farther away from the human reader.

The main idea is to treat variables as indices (represented by natural numbers) and to interpret these indices as the distance to the respective binder.
% In de Bruijn syntax for $\lambda$-terms, we only have one representative for the identity terms $\lambda x.x$, $\lambda y.y$, $\lambda z.z$ \dots, that is, $\lambda .0$.
This way, we do not decide the names for the bound variables in a term - we are obliged to use the specific indices that bind a variable to a certain binder.

\begin{definition}[nameless $\lambda$-terms]
  The nameless $\lambda$-terms are defined by the following grammar:

  \[ M, N \ ::= \ i \ | \ (\lambda . M) \ | \ (M N) \]

  where $i$ ranges over the natural numbers.
\end{definition}

\subsection{Explicit Substitutions and the Sigma Calculus}



\subsection{The \textit{Autosubst} Library}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
