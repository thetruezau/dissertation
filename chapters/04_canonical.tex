\chapter{Canonical $\Lam$-calculus}
\label{c:canonical}

% ideias:
% este canonical lambda calculus e uma versao autocontida do canonical subsistema (sem referencias ao lambda m)
% no capitulo 5 vamos demonstrar que este sistema 'e isomorfo ao lambda calculus
% este canonical lambda calculus corresponde a um lambda calculus vectorial (dai a sua notacao!)
% estas duas ideais justificam a terminologia

% continue (in the same paragraph) with the ideas of the initial sentence of the following paragraph, and the last paragraph of this introduction; something like: The naming of this system is justified by two reasons. On the one hand, it is isomorphic to the canonical subsystem of lambdam seen in the previous chapter. On the other hand, it is also isomorphic to the STLC. 
% Then, start a new paragraph, like: The system $\vect lambda$ is a self-contained ...
% Don't forget to include in this second paragraph the last sentence of the last paragraph of the introduction (on the formalisation of the isomorphism with STLC).

In this chapter we present a system that we give the name of canonical $\Lam$-calculus ($\LamV$).
The naming of this system is motivated by two reasons.
On the one hand, it is isomorphic to the canonical subsystem of $\LamM$ seen in the previous chapter.
On the other hand, it is also isomorphic to the simply typed $\Lam$-calculus.

The system $\LamV$ is a self-contained representation of the canonical subsystem (one can notice the similarities between the definitions for system $\LamM$).
We will give a complete proof for this isomorphism in the second section of this chapter.
In the third section we give the proof for the theorem of conservativeness, stating that $\LamM$ is a conservative extension of $\LamV$. 
The isomorphism between system $\LamV$ and the simply typed $\Lam$-calculus is left for \cref{c:isomorphism}.

\section{The system $\LamV$}

\begin{definition}[$\LamV$-expressions]
  The $\LamV$-terms are simultaneously defined with $\LamV$-lists by the following grammar:  
  \begin{align*} 
    (\LamV \text{-terms}) && t, u &::= \ var(x) \ | \ \lambda x.t \ | \ app_{v}(x, u, l) \ | \ app_{\lambda} (x.t, u, l) \\
    (\LamV \text{-lists}) && l    &::= \ [] \  | \ u :: l.
  \end{align*}
  We will refer to the union of $\LamV$-terms and $\LamV$-lists as $\LamV$-expressions.
\end{definition}

\begin{remark}
  The $\LamV$-terms have two different binding constructors: $\lambda x.t$ and $app_{\lambda} (x.t, u, l)$.
  In both constructors, every occurrence of the variable $x$ in subterms $var(x)$ of the term $t$ is bound (and not free).
  System $\LamV$ has in $app_{\lambda} (x.t, u, l)$ a dedicated constructor for the multiary application $(\lambda x.t)(u, l)$ of system $\LamM$.  
\end{remark}

\begin{definition}
  Given $\LamV$-terms $t, u$ and a $\LamV$-list $l$, the operation $t@(u, l)$ calculates a $\LamV$-term defined by the following equations:
  \begin{align*}
    var(x)@(u, l)                    &= app_v(x, u, l), \\
    (\lambda x. t)@(u, l)            &= app_\lambda (x. t, u, l), \\ 
    app_v(x, u', l')@(u, l)          &= app_v(x, u', l'+(u::l)) \\
    app_\lambda (x. t, u', l')@(u, l) &= app_\lambda (x. t, u', l'+(u::l)),
  \end{align*}
  where the list append, $l + l'$, has the expected bahaviour (as in $\LamM$).
\end{definition}

Now follows a ``strange'' definition for the substitution operation, which needs to be careful when dealing with a substitution over a constructor $app_v$.

\begin{definition}[Substitution for $\LamV$-expressions]
  \label{canonical_substitution}
  The substitution of a variable $x$ by a $\LamV$-term $u$ is mutually defined by recursion over $\LamV$-expressions as follows:  
  \begin{align*}
  & var(x)[x := u] = u ; \\
  & var(y)[x := u] = var(y) \text{, with } x \neq y ; \\
  & (\lambda y . t)[x := u] = \lambda y . (t[x := u]) ; \\
  & app_v(x, u', l)[x := u] = u @ (u'[x := u], l[x := u]) ; \\
  & app_v(y, u', l)[x := u] = app_v(y, u'[x := u], l[x := u]) \text{, with } x \neq y ; \\
  & app_\lambda (y . t, u', l)[x := u] = app_\lambda (y . t[x := u], u'[x := u], l[x := u]) ; \\
  & [][x := u] = [] ; \\
  & (v::l)[x := u] = v[x := u] :: l[x := u] .
  \end{align*}
\end{definition}

\begin{definition}[Reduction rules for $\LamV$-terms]  
  \begin{align*}
    (\beta_1) & \qquad app_\lambda (x . t, u, []) \to t[x := u] \\
    (\beta_2) & \qquad app_\lambda (x . t, u, v::l) \to t[x := u]@(v, l)
  \end{align*}
  % By abuse of notation, we introduce reduction rules with the notation of their compatible closure ($\to_R$).
  As before, we look at the previous rules as binary relations on $\LamV$-terms and define a relation $\beta = \beta_1 \cup \beta_2$.
\end{definition}

% ---

Now, we make a small detour dedicated to compatible relations in the context of this system.

\begin{definition}[Compatible relation]
  Let $R$ and $R'$ be two binary relations on $\LamV$-terms and $\LamV$-lists respectively.
  We say they are compatible when they satisfy:
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (\lambda x . t, \lambda x . t') \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (app_\lambda (x.t, u, l), app_\lambda (x.t', u, l)) \in R } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (app_\lambda (x.t, u, l), app_\lambda (x.t, u', l)) \in R }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (app_\lambda (x.t, u, l), app_\lambda (x.t, u, l')) \in R } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (app_v (x, u, l), app_v (x, u', l)) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (app_v (x, u, l), app_v (x, u, l')) \in R } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (u::l, u'::l) \in R' } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (u::l, u::l') \in R' } 
    \end{prooftree}
  \]
\end{definition}

\begin{notation}
  Again, we will be using the same notation for relations that was used in the previous chapters.
  The compatible closure of a binary relation on $\LamV$-terms $R$ is denoted as $\to_R$.
  The reflexive transitive closure of $\to_R$ is denoted as $\twoheadrightarrow_R$.
\end{notation}

\begin{lemma}[Compatibility lemmas]
  \label{compatibility_lemmas}
  Let $R$ and $R'$ be two binary relations on $\LamV$-terms and $\LamV$-lists respectively.
  If $R$ and $R'$ are compatible, then they satisfy:
    \[
    \begin{prooftree}
      \hypo{ (l_1, l_1') \in R' }
      \infer1{ (l_1+l_2, l_1'+l_2) \in R' } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l_2, l_2') \in R' }
      \infer1{ (l_1+l_2, l_1+l_2') \in R' }
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (t@(u,l), t'@(u,l)) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (t@(u,l), t@(u',l)) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (t@(u,l), t@(u,l')) \in R } 
    \end{prooftree}
  \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by induction on lists for the append cases.
  For the compatibility cases of @ operation, proof follows by inspection of the principle argument and application of the append cases.
\end{proof}

% ---

We now make some considerations about $\beta$-normal forms in this system.

\begin{definition}[$\beta$-normal form]
  We say that a $\LamV$-term $t$ is in $\beta$-normal form when there exists no $\LamV$-term $t'$ such that \[ t \to_\beta t' . \]
\end{definition}

\begin{definition}%[$\beta$-normal forms]
  \label{beta_nfs_can}
  We inductively define the sets of $\LamV$-terms and $\LamV$-lists, respectively NT and NL, as follows:
  \[
    \begin{prooftree}
      \infer0{ var(x) \in \text{NT} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ t \in \text{NT} }
      \infer1{ \lambda x . t \in \text{NT} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in \text{NT} } 
      \hypo{ l \in \text{NL} }
      \infer2{ app_v (x, u, l) \in \text{NT} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \infer0{ [] \in \text{NL} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in \text{NT} }
      \hypo{ l \in \text{NL} }
      \infer2{ u::l \in \text{NL} }
    \end{prooftree}.
  \]
\end{definition}

\begin{claim}
  \label{beta_nfs_can_claim}  
  Given a $\LamV$-term $t$, the following are equivalent:

  (i) $t \in \text{NT}$.

  (ii) $t$ is in $\beta$-normal form.
\end{claim}

\begin{remark}
  One could simply describe the $\beta$-normal forms of $\LamV$ as the terms and lists with no occurrences of the constructor $app_{\lambda}$.
  This description is similar to idea of cut-elimination from sequent calculus (where the normal forms are the expressions not using cuts) and is one of the motivations for working with such systems.
  % proof search
  This system offers thus an advantage in comparison to the $\Lam$-calculus, where a description of $\beta$-normal forms is more elaborated.
\end{remark}

We will not prove this claim here.
However, we will come back to this claim in the next chapter to provide an alternative argument for the bijection between $\beta$-normal forms of $\Lam$-terms and $\LamV$-terms.

We conclude the description of system $\LamV$ by presenting its typing system.

\begin{definition}[Sequent]
  A sequent on terms~$\Gamma \vdash t:A$ is a triple of a context, a $\LamV$-term and a simple type.
  A sequent on lists~$\Gamma;A \vdash l:B$ is a quadruple of a context, a simple type, a $\LamV$-list and another simple type.
\end{definition}

\begin{definition}[Typing rules for $\LamV$-expressions]
  \[
    \begin{prooftree}
      \infer0[Var]{ x:A, \Gamma \vdash var(x):A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ x:A, \Gamma \vdash t:B }
      \infer1[Abs]{ \Gamma \vdash \lambda x . t : A \supset B  } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ \Gamma, x:A \supset B \vdash u:A}
      \hypo{ \Gamma, x:A \supset B ; B \vdash l:C }	
      \infer2[App$_v$]{ \Gamma, x:A \supset B \vdash app_v (x, u, l) : C } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ \Gamma, x:A \vdash t:B }
      \hypo{ \Gamma \vdash u:A }
      \hypo{ \Gamma ; B \vdash l : C }	
      \infer3[App$_\lambda$]{ \Gamma \vdash app_\lambda (x . t, u, l) : C } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \infer0[Nil]{ \Gamma ; A \vdash []:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash u:A }
      \hypo{ \Gamma ; B \vdash l:C }
      \infer2[Cons]{ \Gamma ; A \supset B \vdash  u::l : C } 
    \end{prooftree}
  \]
\end{definition}

% ---
% 123
% ---

\section{$\LamV$ vs the canonical subsystem of $\LamM$}

In this section we prove an isomorphism between $\LamV$ and the canonical subsystem in $\LamM$. 
We start by defining two functions that play a key role in this isomorphism.

\begin{definition}
  Consider the following map $i : \LamV \text{-terms} \to Can$, recursively defined as follows:
  \begin{align*}
    i(var(x))                  &= x \\
    i(\lambda x . t)           &= \lambda x . i(t) \\
    i(app_v(x, u, l))          &= x(i(u), i(l)) \\
    i(app_\lambda(x. t, u, l)) &= (\lambda x . i(t))(i(u), i(l)) \\
    i([])                     &= [] \\
    i(u::l)                   &= i(u)::i(l).
  \end{align*}
\end{definition}

\begin{definition}
  Consider the following map $p : \LamM \text{-terms} \to \LamV \text{-terms}$, recursively defined as follows:
  \begin{align*}
    p(x)           &= var(x) \\
    p(\lambda x.t) &= \lambda x . p(t) \\
    p(t(u, l))     &= p(t)@(p(u), p(l)) \\
    p([])          &= [] \\
    p(u::l)        &= p(u)::p(l).                                
  \end{align*}
\end{definition}

The following diagram summarizes the connection between the defined maps and map $h$ defined in \cref{c:multiary}.

% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZARgBoAGAXVJADcBDAGwFcYkQAdDtAWwCNgXRvX5R6AAh4BfEFNLpMufIRRli1Ok1bsuvAQGF6YGXIXY8BIuVLqaDFm0Sdu-QR1owAxuKEi+Ykw0YKABzeCJQADMAJwgeJGsQHAgkMhBhPhhGAAVFCxV0mEicEDstRxAAC1l5EBi4pAAmGmTUsod2LFL0+kycvOV2aKwQypLTOtj4xETWxGbNDqc0boys3PNBp2HR8copIA
\[
  \begin{tikzcd}
    & \pmb{\lambda m} \arrow[d, "h"] \arrow[ld, "p"'] \\
    \pmb{\vec \lambda} \arrow[r, "i"'] & Can                                      
  \end{tikzcd}
\]

% We show some useful lemmas for the following results.
We begin by proving that the diagram shown is commutative.
This will require the following auxiliary result.

\begin{lemma}
  \label{i_app_comm}
  Given $\LamV$-terms $t,u$ and $\LamV$-list $l$, 
  \[ i(t@(u,l)) = app(i(t), i(u), i(l)). \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by inspection of the $\LamV$-term $t$. 
\end{proof}

\begin{theorem}
  \label{comm_i_p_h}
  \[ i \circ p = h \]
\end{theorem}
\begin{proof}
  The equality is proved easily by induction on the structure of $\LamM$-expressions, using~\cref{i_app_comm} in the application case.
\end{proof}

% We now see that the defined maps establish a bijection between the $\LamV$-terms and the subsyntax of $\LamM$-terms in the set $Can$.

\subsection{Bijection at the level of terms}

\begin{corollary}
  \label{inversion_ip}
  \[ i \circ p|_{Can} = id_{Can} \]
\end{corollary}
\begin{proof}
  The equality is obtained via rewriting with~\cref{h_fixpoints} and then using~\cref{comm_i_p_h}.
\end{proof}

\begin{theorem}
  \label{inversion_pi}
  \[ p \circ i = id_{\LamV \text{-terms}} \]
\end{theorem}
\begin{proof}
  The proof proceeds easily by induction on the structure of the $\LamV$-expressions. 
\end{proof}

% ---

\subsection{Isomorphism at the level of reduction}

In our subsytem of canonical terms, the substitution is not closed for the substitution operation.
We have the following result that relates the two notions of substitution.

\begin{lemma}
  \label{i_subst_pres}
  For every $\LamV$-term $t$,
  \[ i(t[x := u]) = h(i(t)[x := i(u)]) . \]
  % and also, for every $\LamV$-term $u$ and $\LamV$-list $l$,
  % \[ i'(l[x := u]) = h'(i'(l)[x := i(u)]). \]
\end{lemma}
\begin{proof}
  The proof proceeds by induction on the structure of the $\LamV$-term $t$.

  For the case where $t = app_v (x, u, l)$, we use~\cref{i_app_comm} to rewrite the term $i(t[x := v]) = i(v@(u,l))$ as $app(i(v), i(u), i(l))$.
\end{proof}

\begin{lemma}
  \label{p_subst_pres}
  For every $\LamM$-terms $t$,
  \[ p(t[x := u]) = p(t)[x := p(u)]. \]
  % and also, for every $\LamM$-term $u$ and $\LamM$-list $l$,
  % \[ p'(l[x := u]) = p'(l)[x := p(u)]. \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by induction on the structure of the $\LamM$-term $t$.
\end{proof}

The following technical lemma says that we can derive the compatibilty rules of the system $\LamV$ given the canonoical closure of a compatible relation on $\LamM$.

\begin{lemma}
  \label{step_can_is_compatible}
  Let $R$ and $R'$ be two binary relations on $\LamM$-terms and $\LamM$-lists respectively.

  The following binary relations are compatible in $\LamV$:
  \begin{align*}
    I &= \{ (t, t') \ | \ i(t) \ ({\to_R})_c \ i(t'), \text{for $\LamV$-terms $t, t'$} \} \\
    I' &= \{ (l, l') \ | \ i(l) \ ({\to_{R'}})_c \ i(l'), \text{for $\LamV$-lists $l, l'$} \}
  \end{align*}
\end{lemma}
\begin{proof}
  We detail the proof of one of the compatibility cases:
  \[ \begin{prooftree}
      \hypo{ (t, t') \in I }
      \infer1{ (app_\lambda (x.t, u, l), app_\lambda (x.t', u, l)) \in I }
    \end{prooftree} . \]

  From the definition of $I$, $(t, t') \in I \implies i(t) \ ({\to_R})_c \ i(t')$.

  Then, from the definition of the canonical closure relation, we have that there exist $\LamM$-terms $t_1$ and $t_2$ such that $h(t_1) = i(t)$ and $h(t_2) = i(t')$ and $t_1 \to_R t_2$.

  We have:
  \[
    \begin{prooftree}
      \hypo{ t_1 \to_R t_2 }
      \infer1[\text{(compatibility of $\to_R$)}]{ \lambda x.t_1 \to_R \lambda x.t_2 }
      \infer1[\text{(compatibility of $\to_R$)}]{ (\lambda x.t_1)(i(u), i(l)) \to_R (\lambda x.t_2)(i(u), i(l)) }
      \infer1[\text{(canonical closure definition)}]{ h((\lambda x.t_1)(i(u), i(l))) \ ({\to_R})_c \ h((\lambda x.t_2)(i(u), i(l))) }.
    \end{prooftree}
  \]

  Computing $h$, we get $(\lambda x.h(t_1))(h(i(u)), h'(i(l))) \ ({\to_R})_c \ (\lambda x.h(t_2))(h(i(u)), h'(i(l)))$.

  As $i(u) \in Can$, $h(i(u)) = i(u)$.
  And also, because $i(l) \in CanList$, we get that $h'(i(l)) = i(l)$.
  Hence, 
  \begin{align*}
    &(\lambda x.h(t_1))(i(u), i(l)) = (\lambda x.i(t))(i(u), i(l)) = i(app_\lambda (x.t, u, l)) \\
    ({\to_R})_c \ &(\lambda x.h(t_2))(i(u), i(l)) = (\lambda x.i(t'))(i(u), i(l)) = i(app_\lambda (x.t', u, l))
  \end{align*}

  Therefore, by definition of $I$, we get that $(app_\lambda (x.t, u, l), app_\lambda (x.t', u, l)) \in I$.
\end{proof}

\begin{theorem}
  \label{i_step_pres}
  For every $\LamV$-terms $t, t'$,
  \[ t \to_{\beta} t' \implies i(t) \ ({\to_{\beta}})_c \ i(t') . \]
  % and also, for every $\LamV$-lists $l, l'$,
  % \[ l \to_{\beta} l' \implies i'(l) \ ({\to_{\beta}})_c \ i(l'). \]
\end{theorem}
\begin{proof}
  The proof proceeds by induction on the relation $\to_{\beta}$ of $\LamV$-expressions.
  
  \cref{i_subst_pres} deals with substitution preservation in the $\beta$-reduction cases.

  \cref{step_can_is_compatible} deals with all the compatibility cases.
\end{proof}

\begin{theorem}
  \label{p_step_pres}
  For every $t, t' \in Can$,
  \[ t \ ({\to_{\beta}})_c \ t' \implies p(t) \to_{\beta} p(t'). \]
  % and also, for every $l, l' \in CanList$,
  % \[ l \ ({\to_{\beta}})_c \ l' \implies p'(l) \to_{\beta} p(l'). \]
\end{theorem}
\begin{proof}
  The proof starts by inverting our hypothesis $t \ ({\to_{\beta}})_c \ t'$.
  The inversion provides that there exist $\LamM$-terms $t_0, t_0'$ such that $t_0 \to_{\beta} t_0'$ and $t = h(t_0)$ and $t' = h(t_0')$.
  The proof then proceeds by induction on the relation step $t_0 \to_{\beta} t_0'$.
  
  \cref{p_subst_pres} deals with substitution preservation in the $\beta$-reduction cases.

  \cref{compatibility_lemmas} is useful in some compatibility cases.
\end{proof}

% ---
% 123
% ---

\subsection{Isomorphism at the level of typed terms}

We start by establishing admissibility of the typing rules for the append and @ operations.

\begin{lemma}[Append admissibility]
  \label{append_admissibility}
  The following rule is admissible in $\LamV$:
  \[ \begin{prooftree}
      \hypo{ \Gamma ; A \vdash l : B }
      \hypo{ \Gamma ; B \vdash l' : C }
      \infer2{ \Gamma ; A \vdash l+l' : C } 
    \end{prooftree} . \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by induction on the list $l$.
\end{proof}

\begin{lemma}[@ admissibility]
  \label{app_admissibility}
  The following rule is admissible in $\LamV$:
  \[ \begin{prooftree}
      \hypo{ \Gamma \vdash t : A \supset B }
      \hypo{ \Gamma \vdash u : A }
      \hypo{ \Gamma ; B \vdash l : C }      
      \infer3{ \Gamma \vdash t@(u,l) : C } 
    \end{prooftree} . \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by inspection of $t$, using \cref{append_admissibility} when $t$ is an application. 
\end{proof}

We are now ready to prove the two theorems that provide the isomorphism of the canonical subsystem of $\LamM$ and system $\LamV$ at the typing level.

\begin{theorem}[$i$ admissibility]
  \label{i_admissibility}
    For every $\LamV$-term $t$ and $\LamV$-list $l$, the following rules are admissible:
  \[ \begin{prooftree}
      \hypo{ \Gamma \vdash t : A }
      \infer1{ \Gamma \vdash_c i(t) : A } 
    \end{prooftree}
    \qquad \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma ; A \vdash l : B }
      \infer1{ \Gamma ; A \vdash_c i(l) : B } 
    \end{prooftree}. \]
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the typing derivations of the premises.
\end{proof}


\begin{theorem}[$p$ admissibility]
  \label{p_admissibility}
  For every $t \in Can$ and $l \in CanList$, the following rules are admissible:
  \[ \begin{prooftree}
      \hypo{ \Gamma \vdash_c t : A }
      \infer1{ \Gamma \vdash p(t) : A } 
    \end{prooftree}
    \qquad \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma ; A \vdash_c l : B }
      \infer1{ \Gamma ; A \vdash p(l) : B } 
    \end{prooftree}. \]
\end{theorem}
\begin{proof}
  From~\cref{h_fixpoints} we have that $h(t) = t$ and $h'(l) = l$.
  Then, inverting~\cref{canonical_typing}, we have (in $\LamM$):
  \[ \Gamma \vdash t : A \qquad \qquad \qquad \Gamma ; A \vdash l : B . \]
  
  Thus, the proof proceeds easily by simultaneous induction on the above typing derivations of $\LamM$.

  \cref{app_admissibility} is crucial for the application case.
\end{proof}

Our argument for the isomorphism between the canonical subsystem in $\LamM$ and $\LamV$ ends here.
From now on, we will use the self contained representation, system $\LamV$, to talk about canonical terms.

% ---
% 123
% ---

\section{Conservativeness}

The result of conservativeness establishes the connection between reduction in $\LamV$ and in $\LamM$.

We start by proving a auxiliary result that connects the @ operation with list append.

\begin{lemma}
  \label{can_app_comm}
  For every $\LamV$-terms $t, u$, $\LamM$-term $v$ and $\LamM$-lists $l, l'$, the following equality holds.
  \[ (t@(u, p(l)))@(p(v), p(l')) = t@(u, p(l+(v::l'))) \]
\end{lemma}
\begin{proof}
  The proof proceeds by inspection of $\LamV$-term $t$ and uses the simple fact that $p(l+(v::l')) = p(l)+p(v)::p(l')$.
\end{proof}
  
\begin{theorem}[Conservativeness]
  \label{conservativeness}
  For every $\LamV$-terms $t$ and $t'$, we have:
  \[
    t \twoheadrightarrow_\beta t' \iff
    i(t) \twoheadrightarrow_{\beta h} i(t').
  \]
\end{theorem}
\begin{proof}
  $\boxed \implies~$
  Let $t$ and $t'$ be $\LamV$-terms.

  For this implication it suffices to mimic $\beta$ steps of the system $\LamV$ in the system $\LamM$.

  Case $t \to_{\beta_1} t'$:
  % https://q.uiver.app/#q=WzAsMTIsWzAsMiwiYXBwX3tcXGxhbWJkYX0oeC50LCB1LCBbXSkiXSxbMCw0LCJ0W3g6PXVdIl0sWzEsMSwiKFxcbGFtYmRhIHguIGkodCkpKGkodSksIGknKGwpKSJdLFsxLDUsImkodFt4Oj11XSkiXSxbMSwyLCJpKHQpW3ggOj0gaSh1KV0iXSxbMSw0LCJoKGkodClbeDo9aSh1KV0pIl0sWzAsMCwiKFxcdGV4dHtpbn0gXFwgXFx2ZWMgXFxsYW1iZGEpIl0sWzEsMCwiKFxcdGV4dHtpbn0gXFwgXFxsYW1iZGEgbSkiXSxbMCwzXSxbMiwzXSxbMiw0XSxbMiw1XSxbMCwyLCJpIiwxXSxbMSwzLCJpIiwxXSxbMiw0LCJfe1xcYmV0YV8xfSIsMl0sWzUsMywiIiwyLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNCw1LCJfaCIsMix7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6ImVwaSJ9fX1dLFswLDEsIl97XFxiZXRhXzF9IiwyXSxbOSwxMCwibGVtbWEiLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMTAsMTEsImxlbW1hIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
	{(\text{in} \ \LamV)} & {(\text{in} \ \LamM)} \\
	& {(\lambda x. i(t))(i(u), [])} \\
	{app_{\lambda}(x.t, u, [])} & {i(t)[x := i(u)]} \\
	{} && {} \\
	{t[x:=u]} & {h(i(t)[x:=i(u)])} & {} \\
	& {i(t[x:=u])} & {}
	\arrow["{_{\beta_1}}"', from=2-2, to=3-2]
	\arrow["i"{description}, maps to, from=3-1, to=2-2]
	\arrow["{_{\beta_1}}"', from=3-1, to=5-1]
	\arrow["{_h}"', two heads, from=3-2, to=5-2]
	\arrow["\text{\cref{h_is_multistep}}"{description}, draw=none, from=4-3, to=5-3]
	\arrow["i"{description}, maps to, from=5-1, to=6-2]
	\arrow[equals, from=5-2, to=6-2]
	\arrow["\text{\cref{i_subst_pres}}"{description}, draw=none, from=5-3, to=6-3]
      \end{tikzcd}\]
  
  Case $t \to_{\beta_2} t'$:
  % https://q.uiver.app/#q=WzAsMTUsWzEsMiwiKGkodClbeCA6PSBpKHUpXSkoaSh2KSwgaScobCkpIl0sWzAsMCwiXFxzbWFsbHsoXFx0ZXh0e2lufSBcXCBcXHZlYyBcXGxhbWJkYSl9Il0sWzEsMCwiXFxzbWFsbHsoXFx0ZXh0e2lufSBcXCBcXGxhbWJkYSBtKX0iXSxbMSwxLCIoXFxsYW1iZGEgeC4gaSh0KSkoaSh1KSwgaSh2KTo6aScobCkpIl0sWzEsMywiaChpKHQpW3ggOj0gaSh1KV0pKGkodiksIGknKGwpKSJdLFsxLDYsImkodFt4Oj11XUAodixsKSkiXSxbMSw1LCJhcHAoaSh0W3g6PXVdKSwgaSh2KSwgaScobCkpIl0sWzEsNCwiKGkodFt4IDo9IHVdKShpKHYpLCBpJyhsKSkiXSxbMCwyLCJhcHBfe1xcbGFtYmRhfSh4LnQsIHUsIHY6OmwpIl0sWzAsNSwidFt4Oj11XUAodiwgbCkiXSxbMiw1XSxbMiw0XSxbMiwzXSxbMiwyXSxbMiw2XSxbMywwLCJfe1xcYmV0YV8yfSJdLFswLDQsIl9oIiwwLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoiZXBpIn19fV0sWzQsNywiIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjMwLCJ0YXJnZXQiOjMwfSwibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNiw1LCIiLDEseyJzaG9ydGVuIjp7InNvdXJjZSI6MzAsInRhcmdldCI6MzB9LCJsZXZlbCI6Miwic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFs3LDYsIl9oIiwwLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoiZXBpIn19fV0sWzgsMywiaSIsMV0sWzksNSwiaSIsMV0sWzgsOSwiX3tcXGJldGFfMn0iXSxbMTEsMTAsImxlbW1hIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzEyLDExLCJsZW1tYSBcXCBpc3Vic3RwcmVzIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzEzLDEyLCJsZW1tYSIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6Im5vbmUifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFsxMCwxNCwibGVtbWEgXFwgaWFwcGNvbW0iLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XV0=
  \[\begin{tikzcd}
	{\small{(\text{in} \ \LamV)}} & {\small{(\text{in} \ \LamM)}} \\
	& {(\lambda x. i(t))(i(u), i(v)::i(l))} \\
	{app_{\lambda}(x.t, u, v::l)} & {(i(t)[x := i(u)])(i(v), i(l))} & {} \\
	& {h(i(t)[x := i(u)])(i(v), i(l))} & {} \\
	& {(i(t[x := u]))(i(v), i(l))} & {} \\
	{t[x:=u]@(v, l)} & {app(i(t[x:=u]), i(v), i(l))} & {} \\
	& {i(t[x:=u]@(v,l))} & {}
	\arrow["{_{\beta_2}}", from=2-2, to=3-2]
	\arrow["i"{description}, maps to, from=3-1, to=2-2]
	\arrow["{_{\beta_2}}", from=3-1, to=6-1]
	\arrow["{_h}", two heads, from=3-2, to=4-2]
	\arrow["\text{\cref{h_is_multistep}}"{description}, draw=none, from=3-3, to=4-3]
	\arrow[equals, from=4-2, to=5-2]
	\arrow["\text{\cref{i_subst_pres}}"{description}, draw=none, from=4-3, to=5-3]
	\arrow["{_h}", two heads, from=5-2, to=6-2]
	\arrow["\text{\cref{app_is_multistep}}"{description}, draw=none, from=5-3, to=6-3]
	\arrow["i"{description}, maps to, from=6-1, to=7-2]
	\arrow[equals, from=6-2, to=7-2]
	\arrow["\text{\cref{i_app_comm}}"{description}, draw=none, from=6-3, to=7-3]
      \end{tikzcd}\]
  
    $\boxed \Longleftarrow$
    Let $t$ and $t'$ be $\LamM$-terms.    
    
  For this implication, we first show how a reduction $t \to_{\beta h} t'$ in $\LamM$ is directly translated into a reduction $p(t) \to_{\beta} p(t')$ in $\LamV$. 
  
  Case $t \to_{\beta_1} t'$:
  % https://q.uiver.app/#q=WzAsMTAsWzAsMiwiKFxcbGFtYmRhIHgudCkodSwgW10pIl0sWzAsMywidFt4Oj11XSJdLFsxLDIsImFwcF97XFxsYW1iZGF9ICh4LnAodCksIHAodSksIFtdKSJdLFsxLDMsInAodClbeDo9cCh1KV0iXSxbMSw0LCJwKHRbeDo9dV0pIl0sWzEsMSwiKFxcbGFtYmRhIHgucCh0KSlAKHAodSksIFtdKSJdLFswLDAsIihcXHRleHR7aW59IFxcIFxcTGFtTSkiXSxbMSwwLCIoXFx0ZXh0e2lufSBcXCBcXExhbVYpIl0sWzIsM10sWzIsNF0sWzAsMSwiX3tcXGJldGFfMX0iXSxbMiwzLCJfe1xcYmV0YV8xfSJdLFszLDQsIiIsMix7ImxldmVsIjoyLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzAsNSwicCIsMV0sWzUsMiwiIiwxLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSw0LCJwIiwxXSxbOCw5LCJcXHRleHR7XFxjcmVme3Bfc3Vic3RfcHJlc319IiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
	{(\text{in} \ \LamM)} & {(\text{in} \ \LamV)} \\
	& {(\lambda x.p(t))@(p(u), [])} & {} \\
	{(\lambda x.t)(u, [])} & {app_{\lambda} (x.p(t), p(u), [])} & {} \\
	{t[x:=u]} & {p(t)[x:=p(u)]} & {} \\
	& {p(t[x:=u])} & {}
	\arrow[equals, from=2-2, to=3-2]
        \arrow["{\text{Def. of @}}"{description}, draw=none, from=2-3, to=3-3]
	\arrow["p"{description}, maps to, from=3-1, to=2-2]
	\arrow["{_{\beta_1}}", from=3-1, to=4-1]
	\arrow["{_{\beta_1}}", from=3-2, to=4-2]
	\arrow["p"{description}, maps to, from=4-1, to=5-2]
	\arrow[equals, from=4-2, to=5-2]
	\arrow["{\text{\cref{p_subst_pres}}}"{description}, draw=none, from=4-3, to=5-3]
      \end{tikzcd}\]

    Case $t \to_{\beta_2} t'$:
    % https://q.uiver.app/#q=WzAsMTAsWzAsMiwiKFxcbGFtYmRhIHgudCkodSwgdjo6bCkiXSxbMCwzLCJ0W3g6PXVdKHYsIGwpIl0sWzEsMiwiYXBwX3tcXGxhbWJkYX0gKHgucCh0KSwgcCh1KSwgcCcobCkpIl0sWzEsMywicCh0KVt4Oj1wKHUpXUAocCh2KSwgcCcobCkpIl0sWzEsNCwicCh0W3g6PXVdKUAocCh2KSwgcCcobCkpIl0sWzEsMSwiKFxcbGFtYmRhIHgucCh0KSlAKHAodSksIHAnKGwpKSJdLFswLDAsIihcXHRleHR7aW59IFxcIFxcTGFtTSkiXSxbMSwwLCIoXFx0ZXh0e2lufSBcXCBcXExhbVYpIl0sWzIsM10sWzIsNF0sWzAsMSwiX3tcXGJldGFfMn0iXSxbMiwzLCJfe1xcYmV0YV8yfSJdLFszLDQsIiIsMix7ImxldmVsIjoyLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzAsNSwicCIsMV0sWzUsMiwiIiwxLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSw0LCJwIiwxXSxbOCw5LCJcXHRleHR7XFxjcmVme2NvbXBhdGliaWxpdHlfbGVtbWFzfSBhbmQgXFxjcmVme3Bfc3Vic3RfcHJlc319IiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
    \[\begin{tikzcd}
	{(\text{in} \ \LamM)} & {(\text{in} \ \LamV)} \\
	& {(\lambda x.p(t))@(p(u), p(v)::p(l))} & {} \\
	{(\lambda x.t)(u, v::l)} & {app_{\lambda} (x.p(t), p(u), p(v)::p(l))} & {} \\
	{t[x:=u](v, l)} & {p(t)[x:=p(u)]@(p(v), p(l))} & {} \\
	& {p(t[x:=u])@(p(v), p(l))} & {}
	\arrow[equals, from=2-2, to=3-2]
        \arrow["{\text{Def. of @}}"{description}, draw=none, from=2-3, to=3-3]
	\arrow["p"{description}, maps to, from=3-1, to=2-2]
	\arrow["{_{\beta_2}}", from=3-1, to=4-1]
	\arrow["{_{\beta_2}}", from=3-2, to=4-2]
	\arrow["p"{description}, maps to, from=4-1, to=5-2]
	\arrow[equals, from=4-2, to=5-2]
	\arrow["{\text{\cref{p_subst_pres}}}"{description}, draw=none, from=4-3, to=5-3]
      \end{tikzcd}\]

    Case $t \to_h t'$:
    % https://q.uiver.app/#q=WzAsOCxbMCwxLCJ0KHUsIGwpKHUnLCBsJykiXSxbMCwyLCJ0KHUsIGwrKHUnOjpsJykpIl0sWzEsMSwiKHAodClAKHAodSksIHAnKGwpKSlAKHAodScpLCBwJyhsJykpIl0sWzEsMiwicCh0KUAocCh1KSwgcCcobCsodSc6OmwnKSkpIl0sWzEsMCwiKFxcdGV4dHtpbn0gXFwgXFxMYW1WKSJdLFswLDAsIihcXHRleHR7aW59IFxcIFxcTGFtTSkiXSxbMiwxXSxbMiwyXSxbMCwxLCJfaCJdLFswLDIsInAiLDFdLFsxLDMsInAiLDFdLFsyLDMsIiIsMSx7ImxldmVsIjoyLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzYsNywiXFx0ZXh0e1xcY3JlZnt1bmtub3duX2xlbW1hfX0iLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XV0=
    \[\begin{tikzcd}
	{(\text{in} \ \LamM)} & {(\text{in} \ \LamV)} \\
	{t(u, l)(u', l')} & {(p(t)@(p(u), p(l)))@(p(u'), p(l'))} & {} \\
	{t(u, l+(u'::l'))} & {p(t)@(p(u), p(l+(u'::l')))} & {}
	\arrow["p"{description}, maps to, from=2-1, to=2-2]
	\arrow["{_h}", from=2-1, to=3-1]
	\arrow[equals, from=2-2, to=3-2]
	\arrow["{\text{\cref{can_app_comm}}}"{description}, draw=none, from=2-3, to=3-3]
	\arrow["p"{description}, maps to, from=3-1, to=3-2]
      \end{tikzcd}\]

    % From these cases, we proved that:
    From the shown base cases, an easy induction on the relation $\to_{\beta h}$ proves for every $\LamM$-terms $t, t'$:
    \[ t \twoheadrightarrow_{\beta h} t' \implies p(t) \twoheadrightarrow_{\beta} p(t'). \]
    Thus, for every $\LamV$-terms $u, u'$, 
    \[ i(u) \twoheadrightarrow_{\beta h} i(u') \implies p(i(u)) = u \twoheadrightarrow_{\beta} p(i(u')) = u'. \]
  \end{proof}

As an immediate application of the conservativeness result just proved, we can derive subject reduction for $\LamV$ from $\LamM$ (already proved as \cref{type_preservation}).

\begin{corollary}[Subject Reduction for $\LamV$]
  Given $\LamV$-terms $t$ and $t'$, the follwing holds:
  \[
    \Gamma \vdash t : A \ \land \ t \to_{\beta} t' \implies \Gamma \vdash t' : A.
  \]
\end{corollary}
\begin{proof}
  The proof is shown in a derivation-like style.
  We use dashed lines for derivations that do not follow from typing rules or rules already proven admissible.
  \[ \begin{prooftree}      
      \hypo{ \Gamma \vdash t:A }
      \infer[left label=\cref{i_admissibility}]1{ \Gamma \vdash_c i(t):A }
      \infer[dashed,left label=*\cref{canonical_typing}]1{ \Gamma \vdash t_0:A }
      \infer[dashed]0[\cref{h_is_multistep}]{ t_0 \twoheadrightarrow_{h} h(t_0) }
      \infer[dashed]1[$\twoheadrightarrow_{h} \subset \twoheadrightarrow_{\beta h}$]{ t_0 \twoheadrightarrow_{\beta h} h(t_0) }
      \infer[dashed,left label=\cref{type_preservation2}]2{ \Gamma \vdash i(t):A }
      \hypo{ t \to_{\beta} t' }
      \infer[dashed]1[\cref{conservativeness}]{ i(t) \twoheadrightarrow_{\beta h} i(t') }
      \infer[dashed]2[\cref{type_preservation2}]{ \Gamma \vdash i(t'):A }
      \infer1[\cref{canonical_typing}]{ \Gamma \vdash_c h(i(t')):A }
      \infer[dashed]1[\cref{h_fixpoints}]{ \Gamma \vdash_c i(t'):A }
      \infer1[\cref{p_admissibility}]{ \Gamma \vdash p(i(t')):A }
      \infer[dashed]1[\cref{inversion_pi}]{ \Gamma \vdash t':A }
    \end{prooftree} \]
  *\cref{canonical_typing}: inverting this definition with $\Gamma \vdash_c i(t):A$ we get that there exists a $\LamM$-term $t_0$ such that $h(t_0) = i(t)$ and that $\Gamma \vdash t_0:A$.
\end{proof}

\section{Mechanisation in \textit{Rocq}}

The mechanisation for the system $\LamV$ also uses the \textit{Autosubst} library, and follows the same style of the mechanisation of the system $\LamM$, except for the nonstandard substitution operation (that we cover in more detail by the end of the chapter).

\subsection{\lst$Canonical.v$}

Most definitions for the canonical self-contained subsystem follow from the definitions for the system $\LamM$ with small adaptations.
In particular, this applies to the definitions of terms, lists, reduction and the typing relation.
\begin{lstlisting}[language=Coq]
(* syntax *)
Inductive term: Type :=
| Vari (x: var)
| Lamb (t: {bind term})
| VariApp (x: var) (u: term) (l: list term)
| LambApp (t: {bind term}) (u: term) (l: list term).
...
(* reduction relations *)
Inductive beta1: relation term :=
| Step_Beta1 (t: {bind term}) (t' u: term) :
  t' = t.[u .: ids] -> beta1 (LambApp t u []) t'.

Inductive beta2: relation term :=
| Step_Beta2 (t: {bind term}) (t' u v: term) l :
  t' = t.[u .: ids]@(v,l) -> beta2 (LambApp t u (v::l)) t'.

Definition step := comp (union _ beta1 beta2).
Definition step' := comp' (union _ beta1 beta2).

Definition multistep := clos_refl_trans_1n _ step.
Definition multistep' := clos_refl_trans_1n _ step'.
...
(* typing rules *)
Inductive sequent (Gamma: var->type) : term -> type -> Prop := 
| varAxiom (x: var) (A: type) :
  Gamma x = A -> sequent Gamma (Vari x) A
| Right (t: term) (A B: type) :
  sequent (A .: Gamma) t B -> sequent Gamma (Lamb t) (Arr A B)
| Left (x: var) (u: term) (l: list term) (A B C: type) :
  Gamma x = (Arr A B) -> sequent Gamma u A -> list_sequent Gamma B l C ->
  sequent Gamma (VariApp x u l) C
| KeyCut (t: {bind term}) (u: term) (l: list term) (A B C: type) :
  sequent (A .: Gamma) t B -> sequent Gamma u A -> list_sequent Gamma B l C ->
  sequent Gamma (LambApp t u l) C
with list_sequent (Gamma:var->type) : type -> (list term) -> type -> Prop :=
| nilAxiom (C: type) : list_sequent Gamma C [] C
| Lft (u: term) (l: list term) (A B C:type) :
  sequent Gamma u A -> list_sequent Gamma B l C ->
  list_sequent Gamma (Arr A B) (u :: l) C.
\end{lstlisting}

The formalisation of the step relations works as shown for the system $\LamM$ using a \lst$comp$ meta-relation for compatibility closure.
In the next subsection we describe in more detail the aproach used to define the substitution operation for this system.

This module also contains proofs for every compatibility lemma (recall~\cref{compatibility_lemmas}).
\begin{lstlisting}[language=Coq]
Section CompatibilityLemmas.
  Lemma step_comp_append1 :
    forall l1 l1', step' l1 l1' -> forall l2, step' (l1 ++ l2) (l1' ++ l2).
  Proof.
    intros l1 l1' H.
    induction H ; intros.
    - repeat rewrite<- app_comm_cons. 
      now constructor. 
    - repeat rewrite<- app_comm_cons.
      constructor. now apply IHcomp'.
  Qed.    
  ...
  Lemma step_comp_app2 :
    forall v u u' l, step u u' -> step v@(u,l) v@(u',l).
  ...
End CompatibilityLemmas.  
\end{lstlisting}

\subsection{\lst$CanonicalIsomorphism.v$}

This module contains every proof related to the isomorphism of the canonical subsystem in $\LamM$ and the system $\LamV$.

Let us see the statement of~\cref{step_can_is_compatible}:
\begin{lstlisting}[language=Coq]
Lemma step_can_is_compatible :
  Canonical.is_compatible
    (fun t t' => step_can (i t) (i t'))
    (fun l l' => step_can' (map i l) (map i l')).
Proof.
  split ; intros ; asimpl ; inversion H.
  ...
\end{lstlisting}

We prove every compatibility step by inverting first the definition of \lst$step_can$.
Despite being a bureocratic result, it helps simplifying further proofs (such as \cref{i_step_pres} shown below) and reveals some benefits of formalising the general predicate of compatibility \lst$is_compatible$.

\begin{lstlisting}[language=Coq]
Theorem i_step_pres :
  (forall (t t': Canonical.term),
      Canonical.step t t' -> step_can (i t) (i t'))
  /\
  (forall (l l': list Canonical.term),
      Canonical.step' l l' ->
      step_can' (map i l) (map i l')).
Proof.
  pose step_can_is_compatible as Hic.
  destruct Hic.
  apply Canonical.mut_comp_ind ; intros ; auto.
  ...
\end{lstlisting}

The mechanised proof shown above makes use of the automation provided by the \lst$auto$ tactic by strategically adding relevant lemmas to the proof context.
More specifically, the line \lst$ pose step_can_is_compatible as Hic$ adds to the proof context the fact that \lst$step_can$ is a compatible relation for $\LamV$-terms.

\subsection{\lst$Conservativeness.v$}

This module is only about the proof for the conservativeness theorem.
The mechanised theorem follows exactly the proof given diagramatically in~\cref{conservativeness}, divided into two parts, \lst$conservativeness1$ and \lst$conservativeness2$, for each of the two concerned implications.

\begin{lstlisting}[language=Coq]
Theorem conservativeness :
  forall t t', Canonical.multistep t t' <-> LambdaM.multistep (i t) (i t').
Proof.
  split.
  - intro H.
    induction H as [| t1 t2 t3].
    + constructor.
    + apply multistep_trans with (i t2) ; try easy.
      * now apply conservativeness1. 
  - intro H.
    rewrite<- (proj1 inversion2) with t.
    rewrite<- (proj1 inversion2) with t'.
    induction H as [| t1 t2 t3].
    + constructor.
    + apply multistep_trans with (p t2) ; try easy.
      * now apply conservativeness2. 
Qed.
\end{lstlisting}
  
\subsection{A closer look at the mechanisation}

\subsubsection{\textit{Autosubst} and a nonstandard substitution operation}

One of the most peculiar definitions in system $\LamV$ is the substitution operation (\cref{canonical_substitution}).
As referred before, we have an unusual behaviour for the constructor $app_v$.
In practice, on a substitution $app_v (x, u, l)[x:=t]$, there occurs an inspection of the term $t$ that dictates the result of the substitution operation.

As we are working with the \textit{Autosubst} library, we tried to automatically generate the substitution operation for our case.
But as expected, the \lst$derive$ tactic failed to give us the desired operation:
\begin{lstlisting}[language=Coq]
Subst_term =
(fix dummy (sigma : var -> term) (s : term) {struct s} : term :=
match s as t return (annot term t) with
   | Vari x => (fun x0: var => sigma x0) x
   | Lamb t => (fun t0: {bind term} => Lamb t0.[up sigma]) t
   | VariApp x u l => (fun (x0: var) (_: term) (_: list term) => sigma x0) x u l
   | LambApp t u l =>
       (fun (t0: {bind term}) (s0: term) (l0: list term) =>
        LambApp t0.[up sigma] s0.[sigma] l0..[sigma]) t u l
   end)
\end{lstlisting}

Therefore, we gave the proof assistant our dedicated definition (directly as a proof object, as seen below).
\begin{lstlisting}[language=Coq]
Definition app (t u: term) (l: list term): term :=
  match t with
  | Vari x => VariApp x u l
  | Lamb t' => LambApp t' u l
  | VariApp x u' l' => VariApp x u' (l' ++ u::l)
  | LambApp t' u' l' => LambApp t' u' (l' ++ u::l)
  end.
Notation "t '@(' u ',' l ')'" := (app t u l) (at level 9).
...
Instance Ids_term : Ids term. derive. Defined.
Instance Rename_term : Rename term. derive. Defined.
Instance Subst_term : Subst term. 
Proof.
  unfold Subst. fix inst 2. change _ with (Subst term) in inst.
  intros sigma s. change (annot term s). destruct s.
  - exact (sigma x).
  - exact (Lamb (subst (up sigma) t)).
  - exact ((sigma x)@(subst Ïƒ s, mmap (subst sigma) l)).
  - exact (LambApp (subst (up sigma) t) (subst sigma s) (mmap (subst sigma) l)).
Defined.
\end{lstlisting}

The downside to our approach was the need to manually prove every substitution lemma required by the \textit{Autosubst} instance \lst$SubstLemmas$.
However, proving such lemmas was crucial to enjoy the automation provided from the library for the mechanised inductive type of the $\LamV$-terms.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
