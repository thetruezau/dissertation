\chapter{Self-contained canonical system}
\label{c:canonical}

\section{The system $\LamV$}

\begin{definition}[Syntax of $\LamV$]
  The $\LamV$-terms and $\LamV$-lists are simultaneously defined by the following grammar:
  \begin{align*} 
    t, u \ &::= \ var(x) \ | \ \lambda x . t \ | \ app_{v}(x, u, l) \ | \ app_\lambda (x. t, u, l) \\
    l      &::= \ []\  | \ u :: l
  \end{align*}
\end{definition}

\begin{definition}
  Given $\LamV$-terms $t, u$ and $\LamV$-list $l$, the operation $t@(u, l)$ is defined by the following equations:
  \begin{align*}
    & var(x)@(u, l) = app_v(x, u, l), \\
    & (\lambda x. t)@(u, l) = app_\lambda (x. t, u, l), \\ 
    & app_v(x, u', l')@(u, l) = app_v(x, u', l'+(u::l)) \\
    & app_\lambda (x. t, u', l')@(u, l) = app_\lambda (x. t, u', l'+(u::l)),
  \end{align*}
  where the list append, $l + l'$, is defined simlarly as in $\LamM$.  
\end{definition}

\begin{definition}[Substitution for $\LamV$-terms]
  The substitution over a $\LamV$-term is mutually defined with the substitution over a $\LamV$-list as follows:
  \begin{align*}
  & var(x)[x := v] = v ; \\
  & var(y)[x := v] = y \text{, with } x \neq y ; \\
  & (\lambda y . t)[x := v] = \lambda y . (t[x := v]) ; \\
  & app_v(x, u, l)[x := v] = v @ (u[x := v], l[x := v]) ; \\
  & app_v(y, u, l)[x := v] = app_v(y, u[x := v], l[x := v]) \text{, with } x \neq y ; \\
  & app_\lambda (y . t, u, l)[x := v] = app_\lambda (y . t[x := v], u[x := v], l[x := v]) ; \\
  & ([])[x := v] = [] ; \\
  & (u::l)[x := v] = u[x := v] :: l[x := v] .
  \end{align*}
\end{definition}


\begin{definition}[Compatible Relation]
  Let $R$ and $R'$ be two binary relations on $\LamV$-terms and $\LamV$-lists respectively.
  We say they are compatible when they satisfy:
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (\lambda x . t, \lambda x . t') \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (app_\lambda (x.t, u, l), app_\lambda (x.t', u, l)) \in R } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (app_\lambda (x.t, u, l), app_\lambda (x.t, u', l)) \in R }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (app_\lambda (x.t, u, l), app_\lambda (x.t, u, l')) \in R } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (app_v (x, u, l), app_v (x, u', l)) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (app_v (x, u, l), app_v (x, u, l')) \in R } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (u::l, u'::l) \in R' } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (u::l, u::l') \in R' } 
    \end{prooftree}
  \]
\end{definition}


\begin{lemma}[Compatibility lemmas]
  \label{compatibility_lemmas}
  Let $R$ and $R'$ be two binary relations on $\LamV$-terms and $\LamV$-lists respectively.
  If $R$ and $R'$ are compatible, then they satisfy:
    \[
    \begin{prooftree}
      \hypo{ (l_1, l_1') \in R' }
      \infer1{ (l_1+l_2, l_1'+l_2) \in R' } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l_2, l_2') \in R' }
      \infer1{ (l_1+l_2, l_1+l_2') \in R' }
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (t@(u,l), t'@(u,l)) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (t@(u,l), t@(u',l)) \in R } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (t@(u,l), t@(u,l')) \in R } 
    \end{prooftree}
  \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by induction on lists for the append cases.

  For the compatibility cases of @ operation, proof follows by inspection of the principle argument and application of the append cases. 
\end{proof}

\begin{definition}[Reduction rules for $\LamV$-terms]  
  \begin{align*}
    & app_\lambda (x . t, u, []) \to_{\beta_1} t[x := u]
    \\
    & app_\lambda (x . t, u, v::l) \to_{\beta_2} t[x := u]@(v, l)
  \end{align*}
  % By abuse of notation, we introduce reduction rules with the notation of their compatible closure ($\to_R$).
\end{definition}


\begin{definition}[$\beta$-normal forms]
  We inductively define the sets of $\LamV$-terms and $\LamV$-lists in $\beta$-normal form, respectively NT and NL, as follows:
  \[
    \begin{prooftree}
      \infer0{ var(x) \in \text{NT} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ t \in \text{NT} }
      \infer1{ \lambda x . t \in \text{NT} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in \text{NT} } 
      \hypo{ l \in \text{NL} }
      \infer2{ app_v (x, u, l) \in \text{NT} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \infer0{ [] \in \text{NL} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in \text{NT} }
      \hypo{ l \in \text{NL} }
      \infer2{ u::l \in \text{NL} }
    \end{prooftree}.
  \]
\end{definition}


\begin{definition}[Typing Rules for $\LamV$-terms]
  \[
    \begin{prooftree}
      \infer0[Var]{ x:A, \Gamma \vdash var(x):A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ x:A, \Gamma \vdash t:B }
      \infer1[Abs]{ \Gamma \vdash \lambda x . t : A \supset B  } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ \Gamma, x:A \supset B \vdash u:A}
      \hypo{ \Gamma, x:A \supset B ; B \vdash l:C }	
      \infer2[VarApp]{ \Gamma, x:A \supset B \vdash app_v (x, u, l) : C } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ \Gamma, x:A \vdash t:B }
      \hypo{ \Gamma \vdash u:A }
      \hypo{ \Gamma ; B \vdash l : C }	
      \infer3[LamApp]{ \Gamma \vdash app_\lambda (x . t, u, l) : C } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \infer0[Nil]{ \Gamma ; A \vdash []:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash u:A }
      \hypo{ \Gamma ; B \vdash l:C }
      \infer2[Cons]{ \Gamma ; A \supset B \vdash  u::l : C } 
    \end{prooftree}
  \]
\end{definition}

% ---
% 123
% ---

\section{$\LamV$ as a subsystem of $\LamM$}

In this section we prove an isomorphism between $\LamV$ and the canonical terms in $\LamM$. 

\begin{definition}
  Consider the following maps $i$ and $p$:
  \begin{align*}
    i : \LamV \text{-terms} &\to Can \\
    var(x) &\mapsto x \\
    \lambda x . t &\mapsto \lambda x . i(t) \\
    app_v (x, u, l) &\mapsto x(i(u), i'(l)) \\
    app_\lambda (x. t, u, l) &\mapsto (\lambda x . i(t))(i(u), i'(l)),
  \end{align*}
  where $i'$ is simply defined as
  $i'([]) \mapsto []$ and $i'(u::l) = i(u)::i'(l)$;
  \begin{align*}
    p : \LamM \text{-terms} &\to \LamV \text{-terms} \\
    x &\mapsto var(x) \\
    \lambda x . t &\mapsto \lambda x . p(t) \\
    t(u, l) &\mapsto p(t)@(p(u), p'(l)),
  \end{align*}
  where $p'$ is simply defined as
  $p'([]) \mapsto []$ and $p'(u::l) = p(u)::p'(l)$.
\end{definition}

The following diagram summarizes the defined maps.

% https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZARgBoAGAXVJADcBDAGwFcYkQAdDtAWwCNgXRvX5R6AAh4BfEFNLpMufIRRli1Ok1bsuvAQGF6YGXIXY8BIuVLqaDFm0Sdu-QR1owAxuKEi+Ykw0YKABzeCJQADMAJwgeJGsQHAgkMhBhPhhGAAVFCxV0mEicEDstRxAAC1l5EBi4pAAmGmTUsod2LFL0+kycvOV2aKwQypLTOtj4xETWxGbNDqc0boys3PNBp2HR8copIA
\[
  \begin{tikzcd}
    & \pmb{\lambda m} \arrow[d, "h"] \arrow[ld, "p"'] \\
    \pmb{\vec \lambda} \arrow[r, "i"'] & Can                                      
  \end{tikzcd}
\]

% We show some useful lemmas for the following results.

\begin{lemma}
  \label{i_app_comm}
  Given $\LamV$-terms $t,u$ and $\LamV$-list $l$, 
  \[ i(t@(u,l)) = app(i(t), i(u), i'(l)). \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by inspection of the $\LamV$-term $t$. 
\end{proof}

% We now see that the defined maps establish a bijection between the $\LamV$-terms and the subsyntax of $\LamM$-terms in the set $Can$.

\subsection{Isomorphism at the level of terms}

\begin{theorem}
  \label{comm_i_p_h}
  \begin{align*}
    i \circ p &= h \\
    i' \circ p' &= h'    
  \end{align*}
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of the $\LamM$-term, using~\cref{i_app_comm} in the application case.
\end{proof}

\begin{corollary}
  \label{inversion_ip}
  \begin{align*}
    i \circ p|_{Can} &= id_{Can} \\
    i' \circ p'|_{CanList} &= id_{CanList}
  \end{align*}
\end{corollary}
\begin{proof}
  Each inversion is obtained via rewriting with~\cref{h_fixpoints} and then using~\cref{comm_i_p_h}.
\end{proof}

\begin{theorem}
  \label{inversion_pi}
  \begin{align*}
    p \circ i &= id_{\LamV \text{-terms}} \\
    p' \circ i' &= id_{\LamV \text{-terms}}    
  \end{align*}
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of the $\LamV$-term. 
\end{proof}

% ---
% ---

\subsection{Isomorphism at the level of reduction}

In our subsytem of canonical terms, the substitution is not closed for the substitution operation.
We have the following result that relates the two notions of substitution.

\begin{lemma}
  \label{i_subst_pres}
  For every $\LamV$-terms $t, u$,
  \[ i(t[x := u]) = h(i(t)[x := i(u)]) \]
  and also, for every $\LamV$-term $u$ and $\LamV$-list $l$,
  \[ i'(l[x := u]) = h'(i'(l)[x := i(u)]). \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of the $\LamV$-term $t$.

  For the case where $t = app_v (x, u, l)$, we use~\cref{i_app_comm} to rewrite the term $i(t[x := v]) = i(v@(u,l))$ as $app(i(v), i(u), i'(l))$.
\end{proof}

\begin{lemma}
  \label{p_subst_pres}
  For every $\LamM$-terms $t, u$,
  \[ p(t[x := u]) = p(t)[x := p(u)] \]
  and also, for every $\LamM$-term $u$ and $\LamM$-list $l$,
  \[ p'(l[x := u]) = p'(l)[x := p(u)]. \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of the $\LamM$-term $t$.
\end{proof}

The following technical lemma says that we can derive the compatibilty rules from the system $\LamV$ given the canonoical closure of compatible relation on $\LamM$.

\begin{lemma}
  \label{step_can_is_compatible}
  Let $R$ and $R'$ be two binary relations on $\LamM$-terms and $\LamM$-lists respectively.

  The following binary relations are compatible in $\LamV$:
  \begin{align*}
    I &= \{ (t, t') \ | \ i(t) \ {\to_R}_c \ i(t'), \text{for every $\LamV$-terms $t, t'$} \} \\
    I' &= \{ (l, l') \ | \ i'(l) \ {\to_{R'}}_c \ i'(l'), \text{for every $\LamV$-lists $l, l'$} \}
  \end{align*}
\end{lemma}
\begin{proof}
  We provide proof for one of the compatibility cases:
  \[ \begin{prooftree}
      \hypo{ (t, t') \in I }
      \infer1{ (app_\lambda (x.t, u, l), app_\lambda (x.t', u, l)) \in I }
    \end{prooftree} . \]

  From the definition of $I$, $(t, t') \in I \implies i(t) \ {\to_R}_c \ i(t')$.

  Then, from the definition of the canonical closure relation, we have that there exist $\LamM$-terms $t_1$ and $t_2$ such that $h(t_1) = i(t)$ and $h(t_2) = i(t')$ and $t_1 \to_R t_2$.

  We have:
  \[ \begin{prooftree}
      \hypo{ t_1 \to_R t_2 }
      \infer1[\text{(compatibility of $\to_R$)}]{ \lambda x.t_1 \to_R \lambda x.t_2 }
      \infer1[\text{(compatibility of $\to_R$)}]{ (\lambda x.t_1)(i(u), i'(l)) \to_R (\lambda x.t_2)(i(u), i'(l)) }
      \infer1[\text{(compatibility of $\to_R$)}]{ (\lambda x.t_1)(i(u), i'(l)) \to_R (\lambda x.t_2)(i(u), i'(l)) }
      \infer1[\text{(canonical closure definition)}]{ h((\lambda x.t_1)(i(u), i'(l))) \ {\to_R}_c \ h((\lambda x.t_2)(i(u), i'(l))) }.
    \end{prooftree} \]

  Computing $h$, we get $(\lambda x.h(t_1))(h(i(u)), h'(i'(l))) \ {\to_R}_c \ (\lambda x.h(t_2))(h(i(u)), h'(i'(l)))$.

  As $i(u) \in Can$, $h(i(u)) = i(u)$.
  And also, because $i'(l) \in CanList$, we get that $h'(i'(l)) = i'(l)$.
  \begin{align*}
    &(\lambda x.h(t_1))(i(u), i'(l)) = (\lambda x.i(t))(i(u), i'(l)) = i(app_\lambda (x.t, u, l)) \\
    {\to_R}_c \ &(\lambda x.h(t_2))(i(u), i'(l)) = (\lambda x.i(t'))(i(u), i'(l)) = i(app_\lambda (x.t', u, l))
  \end{align*}

  Therefore, by definition of $I$, we get that $(app_\lambda (x.t, u, l), app_\lambda (x.t', u, l)) \in I$.
\end{proof}

\begin{theorem}
  \label{i_step_pres}
  For every $\LamV$-terms $t, t'$,
  \[ t \to_{\beta} t' \implies i(t) {\to_{\beta}}_c i(t') \]
  and also, for every $\LamV$-lists $l, l'$,
  \[ l \to_{\beta} l' \implies i'(l) {\to_{\beta}}_c i(l'). \]
\end{theorem}
\begin{proof}
  The proof proceeds by simultaneous induction on the step relation of $\LamV$-terms.

  \cref{i_subst_pres} deals with substitution preservation in the $\beta$ reduction cases.

  \cref{step_can_is_compatible} deals with all the compatibility cases.
\end{proof}

\begin{theorem}
  \label{p_step_pres}
  For every $t, t' \in Can$,
  \[ t {\to_{\beta}}_c t' \implies p(t) \to_{\beta} p(t') \]
  and also, for every $l, l' \in CanList$,
  \[ l {\to_{\beta}}_c l' \implies p'(l) \to_{\beta} p(l'). \]
\end{theorem}
\begin{proof}
  The proof proceeds by simultaneous induction on the step relation of canonical terms.
  
  \cref{compatibility_lemmas} may be useful for compatibility steps.

  \cref{p_subst_pres} deals with substitution preservation in the $\beta$ reduction cases.  
\end{proof}

% ---
% 123
% ---

\subsection{Isomorphism at the level of typed terms}

\begin{lemma}[Append admissibility]
  \label{append_admissibility}
  The following rule is admissible in $\LamV$:
  \[ \begin{prooftree}
      \hypo{ \Gamma ; A \vdash l : B }
      \hypo{ \Gamma ; B \vdash l' : C }
      \infer2{ \Gamma ; A \vdash l+l' : C } 
    \end{prooftree} . \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by induction on the list $l$.
\end{proof}


\begin{lemma}[@ admissibility]
  \label{app_admissibility}
  The following rule is admissible in $\LamV$:
  \[ \begin{prooftree}
      \hypo{ \Gamma \vdash t : A \supset B }
      \hypo{ \Gamma \vdash u : A }
      \hypo{ \Gamma ; B \vdash l : C }      
      \infer3{ \Gamma \vdash t@(u,l) : C } 
    \end{prooftree} . \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by inspection of $t$, using \cref{append_admissibility} when $t$ is an application. 
\end{proof}


\begin{theorem}[$i$ admissibility]
  \label{i_admissibility}
    For every $\LamV$-term $t$ and $\LamV$-list $l$, the following rules are admissible:
  \[ \begin{prooftree}
      \hypo{ \Gamma \vdash t : A }
      \infer1{ \Gamma \vdash_c i(t) : A } 
    \end{prooftree}
    \qquad \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma ; A \vdash l : B }
      \infer1{ \Gamma ; A \vdash_c i'(l) : B } 
    \end{prooftree}. \]
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the typing rules of $\LamV$.
\end{proof}


\begin{theorem}[$p$ admissibility]
  \label{p_admissibility}
  For every $t \in Can$ and $l \in CanList$, the following rules are admissible:
  \[ \begin{prooftree}
      \hypo{ \Gamma \vdash_c t : A }
      \infer1{ \Gamma \vdash p(t) : A } 
    \end{prooftree}
    \qquad \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma ; A \vdash_c l : B }
      \infer1{ \Gamma ; A \vdash p'(l) : B } 
    \end{prooftree}. \]
\end{theorem}
\begin{proof}
  From~\cref{h_fixpoints} we have that $h(t) = t$ and $h'(l) = l$.

  Then, inverting~\cref{canonical_typing}, we have (in $\LamM$):
  \[ \Gamma \vdash t : A
    \qquad \qquad \qquad
    \Gamma ; A \vdash l : B . \]
  
  Therefore, the proof proceeds easily by simultaneous induction on the typing rules of $\LamM$.

  \cref{app_admissibility} is crucial for the application case.
\end{proof}

Our argument for the isomorphism between the canonical subsystem in $\LamM$ and $\LamV$ ends here.

From now on, we will use the self contained representation, system $\LamV$, to talk about canonical terms.

% ---
% 123
% ---

\section{Conservativeness}

The result of conservativeness establishes the connection between reduction in $\LamV$ and in $\LamM$.

\begin{theorem}[Conservativeness]
  \label{conservativeness}
  For every $\LamV$-terms $t$ and $t'$, we have:
  \[
    t \twoheadrightarrow_\beta t' \iff
    i(t) \twoheadrightarrow_{\beta h} i(t')
  \]
\end{theorem}
\begin{proof}
  $\boxed \implies~$
  Let $t$ and $t'$ be $\LamV$-terms.

  For this implication it suffices to mimic $\beta$ steps of the system $\LamV$ in the system $\LamM$.

  Case $t \to_{\beta_1} t'$:
  % https://q.uiver.app/#q=WzAsMTIsWzAsMiwiYXBwX3tcXGxhbWJkYX0oeC50LCB1LCBbXSkiXSxbMCw0LCJ0W3g6PXVdIl0sWzEsMSwiKFxcbGFtYmRhIHguIGkodCkpKGkodSksIGknKGwpKSJdLFsxLDUsImkodFt4Oj11XSkiXSxbMSwyLCJpKHQpW3ggOj0gaSh1KV0iXSxbMSw0LCJoKGkodClbeDo9aSh1KV0pIl0sWzAsMCwiKFxcdGV4dHtpbn0gXFwgXFx2ZWMgXFxsYW1iZGEpIl0sWzEsMCwiKFxcdGV4dHtpbn0gXFwgXFxsYW1iZGEgbSkiXSxbMCwzXSxbMiwzXSxbMiw0XSxbMiw1XSxbMCwyLCJpIiwxXSxbMSwzLCJpIiwxXSxbMiw0LCJfe1xcYmV0YV8xfSIsMl0sWzUsMywiIiwyLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNCw1LCJfaCIsMix7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6ImVwaSJ9fX1dLFswLDEsIl97XFxiZXRhXzF9IiwyXSxbOSwxMCwibGVtbWEiLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMTAsMTEsImxlbW1hIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
	{(\text{in} \ \LamV)} & {(\text{in} \ \LamM)} \\
	& {(\lambda x. i(t))(i(u), i'(l))} \\
	{app_{\lambda}(x.t, u, [])} & {i(t)[x := i(u)]} \\
	{} && {} \\
	{t[x:=u]} & {h(i(t)[x:=i(u)])} & {} \\
	& {i(t[x:=u])} & {}
	\arrow["{_{\beta_1}}"', from=2-2, to=3-2]
	\arrow["i"{description}, maps to, from=3-1, to=2-2]
	\arrow["{_{\beta_1}}"', from=3-1, to=5-1]
	\arrow["{_h}"', two heads, from=3-2, to=5-2]
	\arrow["\text{\cref{h_is_multistep}}"{description}, draw=none, from=4-3, to=5-3]
	\arrow["i"{description}, maps to, from=5-1, to=6-2]
	\arrow[equals, from=5-2, to=6-2]
	\arrow["\text{\cref{i_subst_pres}}"{description}, draw=none, from=5-3, to=6-3]
      \end{tikzcd}\]
  
  Case $t \to_{\beta_2} t'$:
  % https://q.uiver.app/#q=WzAsMTUsWzEsMiwiKGkodClbeCA6PSBpKHUpXSkoaSh2KSwgaScobCkpIl0sWzAsMCwiXFxzbWFsbHsoXFx0ZXh0e2lufSBcXCBcXHZlYyBcXGxhbWJkYSl9Il0sWzEsMCwiXFxzbWFsbHsoXFx0ZXh0e2lufSBcXCBcXGxhbWJkYSBtKX0iXSxbMSwxLCIoXFxsYW1iZGEgeC4gaSh0KSkoaSh1KSwgaSh2KTo6aScobCkpIl0sWzEsMywiaChpKHQpW3ggOj0gaSh1KV0pKGkodiksIGknKGwpKSJdLFsxLDYsImkodFt4Oj11XUAodixsKSkiXSxbMSw1LCJhcHAoaSh0W3g6PXVdKSwgaSh2KSwgaScobCkpIl0sWzEsNCwiKGkodFt4IDo9IHVdKShpKHYpLCBpJyhsKSkiXSxbMCwyLCJhcHBfe1xcbGFtYmRhfSh4LnQsIHUsIHY6OmwpIl0sWzAsNSwidFt4Oj11XUAodiwgbCkiXSxbMiw1XSxbMiw0XSxbMiwzXSxbMiwyXSxbMiw2XSxbMywwLCJfe1xcYmV0YV8yfSJdLFswLDQsIl9oIiwwLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoiZXBpIn19fV0sWzQsNywiIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjMwLCJ0YXJnZXQiOjMwfSwibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNiw1LCIiLDEseyJzaG9ydGVuIjp7InNvdXJjZSI6MzAsInRhcmdldCI6MzB9LCJsZXZlbCI6Miwic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFs3LDYsIl9oIiwwLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoiZXBpIn19fV0sWzgsMywiaSIsMV0sWzksNSwiaSIsMV0sWzgsOSwiX3tcXGJldGFfMn0iXSxbMTEsMTAsImxlbW1hIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzEyLDExLCJsZW1tYSBcXCBpc3Vic3RwcmVzIiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzEzLDEyLCJsZW1tYSIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6Im5vbmUifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFsxMCwxNCwibGVtbWEgXFwgaWFwcGNvbW0iLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XV0=
  \[\begin{tikzcd}
	{\small{(\text{in} \ \LamV)}} & {\small{(\text{in} \ \LamM)}} \\
	& {(\lambda x. i(t))(i(u), i(v)::i'(l))} \\
	{app_{\lambda}(x.t, u, v::l)} & {(i(t)[x := i(u)])(i(v), i'(l))} & {} \\
	& {h(i(t)[x := i(u)])(i(v), i'(l))} & {} \\
	& {(i(t[x := u]))(i(v), i'(l))} & {} \\
	{t[x:=u]@(v, l)} & {app(i(t[x:=u]), i(v), i'(l))} & {} \\
	& {i(t[x:=u]@(v,l))} & {}
	\arrow["{_{\beta_2}}", from=2-2, to=3-2]
	\arrow["i"{description}, maps to, from=3-1, to=2-2]
	\arrow["{_{\beta_2}}", from=3-1, to=6-1]
	\arrow["{_h}", two heads, from=3-2, to=4-2]
	\arrow["\text{\cref{h_is_multistep}}"{description}, draw=none, from=3-3, to=4-3]
	\arrow[equals, from=4-2, to=5-2]
	\arrow["\text{\cref{i_subst_pres}}"{description}, draw=none, from=4-3, to=5-3]
	\arrow["{_h}", two heads, from=5-2, to=6-2]
	\arrow["\text{\cref{app_is_multistep}}"{description}, draw=none, from=5-3, to=6-3]
	\arrow["i"{description}, maps to, from=6-1, to=7-2]
	\arrow[equals, from=6-2, to=7-2]
	\arrow["\text{\cref{i_app_comm}}"{description}, draw=none, from=6-3, to=7-3]
      \end{tikzcd}\]
  
    $\boxed \Longleftarrow$
    Let $t$ and $t'$ be $\LamM$-terms.    
    
  For this implication, we first show how a reduction $t \to_{\beta h} t'$ in $\LamM$ is directly translated to a reduction $p(t) \to_{\beta} p(t')$ in $\LamV$. 
  
  Case $t \to_{\beta_1} t'$:
  % https://q.uiver.app/#q=WzAsMTAsWzAsMiwiKFxcbGFtYmRhIHgudCkodSwgW10pIl0sWzAsMywidFt4Oj11XSJdLFsxLDIsImFwcF97XFxsYW1iZGF9ICh4LnAodCksIHAodSksIFtdKSJdLFsxLDMsInAodClbeDo9cCh1KV0iXSxbMSw0LCJwKHRbeDo9dV0pIl0sWzEsMSwiKFxcbGFtYmRhIHgucCh0KSlAKHAodSksIFtdKSJdLFswLDAsIihcXHRleHR7aW59IFxcIFxcTGFtTSkiXSxbMSwwLCIoXFx0ZXh0e2lufSBcXCBcXExhbVYpIl0sWzIsM10sWzIsNF0sWzAsMSwiX3tcXGJldGFfMX0iXSxbMiwzLCJfe1xcYmV0YV8xfSJdLFszLDQsIiIsMix7ImxldmVsIjoyLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzAsNSwicCIsMV0sWzUsMiwiIiwxLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSw0LCJwIiwxXSxbOCw5LCJcXHRleHR7XFxjcmVme3Bfc3Vic3RfcHJlc319IiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
	{(\text{in} \ \LamM)} & {(\text{in} \ \LamV)} \\
	& {(\lambda x.p(t))@(p(u), [])} \\
	{(\lambda x.t)(u, [])} & {app_{\lambda} (x.p(t), p(u), [])} \\
	{t[x:=u]} & {p(t)[x:=p(u)]} & {} \\
	& {p(t[x:=u])} & {}
	\arrow[equals, from=2-2, to=3-2]
	\arrow["p"{description}, maps to, from=3-1, to=2-2]
	\arrow["{_{\beta_1}}", from=3-1, to=4-1]
	\arrow["{_{\beta_1}}", from=3-2, to=4-2]
	\arrow["p"{description}, maps to, from=4-1, to=5-2]
	\arrow[equals, from=4-2, to=5-2]
	\arrow["{\text{\cref{p_subst_pres}}}"{description}, draw=none, from=4-3, to=5-3]
      \end{tikzcd}\]

    Case $t \to_{\beta_2} t'$:
    % https://q.uiver.app/#q=WzAsMTAsWzAsMiwiKFxcbGFtYmRhIHgudCkodSwgdjo6bCkiXSxbMCwzLCJ0W3g6PXVdKHYsIGwpIl0sWzEsMiwiYXBwX3tcXGxhbWJkYX0gKHgucCh0KSwgcCh1KSwgcCcobCkpIl0sWzEsMywicCh0KVt4Oj1wKHUpXUAocCh2KSwgcCcobCkpIl0sWzEsNCwicCh0W3g6PXVdKUAocCh2KSwgcCcobCkpIl0sWzEsMSwiKFxcbGFtYmRhIHgucCh0KSlAKHAodSksIHAnKGwpKSJdLFswLDAsIihcXHRleHR7aW59IFxcIFxcTGFtTSkiXSxbMSwwLCIoXFx0ZXh0e2lufSBcXCBcXExhbVYpIl0sWzIsM10sWzIsNF0sWzAsMSwiX3tcXGJldGFfMn0iXSxbMiwzLCJfe1xcYmV0YV8yfSJdLFszLDQsIiIsMix7ImxldmVsIjoyLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzAsNSwicCIsMV0sWzUsMiwiIiwxLHsibGV2ZWwiOjIsInN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMSw0LCJwIiwxXSxbOCw5LCJcXHRleHR7XFxjcmVme2NvbXBhdGliaWxpdHlfbGVtbWFzfSBhbmQgXFxjcmVme3Bfc3Vic3RfcHJlc319IiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
    \[\begin{tikzcd}
	{(\text{in} \ \LamM)} & {(\text{in} \ \LamV)} \\
	& {(\lambda x.p(t))@(p(u), p'(l))} \\
	{(\lambda x.t)(u, v::l)} & {app_{\lambda} (x.p(t), p(u), p'(l))} \\
	{t[x:=u](v, l)} & {p(t)[x:=p(u)]@(p(v), p'(l))} & {} \\
	& {p(t[x:=u])@(p(v), p'(l))} & {}
	\arrow[equals, from=2-2, to=3-2]
	\arrow["p"{description}, maps to, from=3-1, to=2-2]
	\arrow["{_{\beta_2}}", from=3-1, to=4-1]
	\arrow["{_{\beta_2}}", from=3-2, to=4-2]
	\arrow["p"{description}, maps to, from=4-1, to=5-2]
	\arrow[equals, from=4-2, to=5-2]
	\arrow["{\text{\cref{compatibility_lemmas} and \cref{p_subst_pres}}}"{description}, draw=none, from=4-3, to=5-3]
      \end{tikzcd}\]

    Case $t \to_h t'$:
    % https://q.uiver.app/#q=WzAsOCxbMCwxLCJ0KHUsIGwpKHUnLCBsJykiXSxbMCwyLCJ0KHUsIGwrKHUnOjpsJykpIl0sWzEsMSwiKHAodClAKHAodSksIHAnKGwpKSlAKHAodScpLCBwJyhsJykpIl0sWzEsMiwicCh0KUAocCh1KSwgcCcobCsodSc6OmwnKSkpIl0sWzEsMCwiKFxcdGV4dHtpbn0gXFwgXFxMYW1WKSJdLFswLDAsIihcXHRleHR7aW59IFxcIFxcTGFtTSkiXSxbMiwxXSxbMiwyXSxbMCwxLCJfaCJdLFswLDIsInAiLDFdLFsxLDMsInAiLDFdLFsyLDMsIiIsMSx7ImxldmVsIjoyLCJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzYsNywiXFx0ZXh0e1xcY3JlZnt1bmtub3duX2xlbW1hfX0iLDEseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XV0=
    \[\begin{tikzcd}
	{(\text{in} \ \LamM)} & {(\text{in} \ \LamV)} \\
	{t(u, l)(u', l')} & {(p(t)@(p(u), p'(l)))@(p(u'), p'(l'))} & {} \\
	{t(u, l+(u'::l'))} & {p(t)@(p(u), p'(l+(u'::l')))} & {}
	\arrow["p"{description}, maps to, from=2-1, to=2-2]
	\arrow["{_h}", from=2-1, to=3-1]
	\arrow[equals, from=2-2, to=3-2]
	\arrow["{\text{Simple induction on~$p(t)$}}"{description}, draw=none, from=2-3, to=3-3]
	\arrow["p"{description}, maps to, from=3-1, to=3-2]
      \end{tikzcd}\]

    From these cases, we proved that:
    \begin{align*}
      & t \twoheadrightarrow_{\beta h} t' \implies p(t) \twoheadrightarrow_{\beta} p(t'), \ \text{for every $\LamM$-terms $t, t'$} \\
      \text{(which implies)} \quad & i(t) \twoheadrightarrow_{\beta h} i(t') \implies p(i(t)) \twoheadrightarrow_{\beta} p(i(t')), \ \text{for every $\LamV$-terms $t, t'$} \\
      \text{(simplifying)} \quad & i(t) \twoheadrightarrow_{\beta h} i(t') \implies t \twoheadrightarrow_{\beta} t', \ \text{for every $\LamV$-terms $t, t'$}
    \end{align*}
  \end{proof}

As a corollary of conservativeness, we can derive subject reduction for $\LamV$ from $\LamM$.

\begin{corollary}[Subject Reduction for $\LamV$]
  Given $\LamV$-terms $t$ and $t'$, the follwing holds:
  \[
    \Gamma \vdash t : A \ \land \ t \to_{\beta} t' \implies \Gamma \vdash t' : A.
  \]
\end{corollary}
\begin{proof}
  The proof is shown in a derivation-like style.
  We use dashed lines for derivations that do not follow from typing rules or rules proven admissible.
  \[ \begin{prooftree}      
      \hypo{ \Gamma \vdash t:A }
      \infer[left label=\text{\cref{i_admissibility}}]1{ \Gamma \vdash_c i(t):A }
      \infer[dashed,left label=\text{Inversion of \cref{canonical_typing}}]1{ \Gamma \vdash t_0:A }
      \hypo{ t_0 \twoheadrightarrow_{h} h(t_0) }
      \infer[dashed,left label=\text{\cref{type_preservation} with $\twoheadrightarrow$}]2{ \Gamma \vdash i(t):A }
      \hypo{ t \to_{\beta} t' }
      \infer[dashed]1[\text{\cref{conservativeness}}]{ i(t) \twoheadrightarrow_{\beta h} i(t') }
      \infer[dashed]2[\text{\cref{type_preservation} with $\twoheadrightarrow$}]{ \Gamma \vdash i(t'):A }
      \infer1[\text{\cref{canonical_typing}}]{ \Gamma \vdash_c h(i(t')):A }
      \infer[dashed]1[\text{\cref{h_fixpoints}}]{ \Gamma \vdash_c i(t'):A }
      \infer1[\text{\cref{p_admissibility}}]{ \Gamma \vdash p(i(t')):A }
      \infer[dashed]1[\text{\cref{inversion_pi}}]{ \Gamma \vdash t':A }
    \end{prooftree} \]
\end{proof}

\section{Mechanisation in \textit{Rocq}}

The mechanisations for the system $\LamV$ follow the same style as the ones shown for the system $\LamM$ using the \textit{Autosubst} library, except for the non standard substitution operation.

\subsection{\lst$Canonical.v$}

Most definitions for the canonical self-contained subsystem follow exactly from the definitions for the system $\LamM$ with the corresponding adaptations.
\begin{lstlisting}[language=Coq]
(* syntax *)
Inductive term: Type :=
| Vari (x: var)
| Lamb (t: {bind term})
| VariApp (x: var) (u: term) (l: list term)
| LambApp (t: {bind term}) (u: term) (l: list term).
...
(* reduction relations *)
Inductive beta1: relation term :=
| Step_Beta1 (t: {bind term}) (t' u: term) :
  t' = t.[u .: ids] -> beta1 (LambApp t u []) t'.

Inductive beta2: relation term :=
| Step_Beta2 (t: {bind term}) (t' u v: term) l :
  t' = t.[u .: ids]@(v,l) -> beta2 (LambApp t u (v::l)) t'.

Definition step := comp (union _ beta1 beta2).
Definition step' := comp' (union _ beta1 beta2).

Definition multistep := clos_refl_trans_1n _ step.
Definition multistep' := clos_refl_trans_1n _ step'.
...
(* typing rules *)
Inductive sequent (Gamma: var->type) : term -> type -> Prop := 
| varAxiom (x: var) (A: type) :
  Gamma x = A -> sequent Gamma (Vari x) A
| Right (t: term) (A B: type) :
  sequent (A .: Gamma) t B -> sequent Gamma (Lamb t) (Arr A B)
| Left (x: var) (u: term) (l: list term) (A B C: type) :
  Gamma x = (Arr A B) -> sequent Gamma u A -> list_sequent Gamma B l C ->
  sequent Gamma (VariApp x u l) C
| KeyCut (t: {bind term}) (u: term) (l: list term) (A B C: type) :
  sequent (A .: Gamma) t B -> sequent Gamma u A -> list_sequent Gamma B l C ->
  sequent Gamma (LambApp t u l) C
with list_sequent (Gamma:var->type) : type -> (list term) -> type -> Prop :=
| nilAxiom (C: type) : list_sequent Gamma C [] C
| Lft (u: term) (l: list term) (A B C:type) :
  sequent Gamma u A -> list_sequent Gamma B l C ->
  list_sequent Gamma (Arr A B) (u :: l) C.
\end{lstlisting}

The mechanised step relations work as shown for the system $\LamM$ using a \lst$comp$ meta-relation for compatibility closure.
In the next subsection we describe in more detail the aproach used to define the substitution operation for this system.

This module also contains proofs for every compatibility lemma (recall~\cref{compatibility_lemmas}).
\begin{lstlisting}[language=Coq]
Section CompatibilityLemmas.
  Lemma step_comp_append1 :
    forall l1 l1', step' l1 l1' -> forall l2, step' (l1 ++ l2) (l1' ++ l2).
  Proof.
    intros l1 l1' H.
    induction H ; intros.
    - repeat rewrite<- app_comm_cons. 
      now constructor. 
    - repeat rewrite<- app_comm_cons.
      constructor. now apply IHcomp'.
  Qed.    
  ...
  Lemma step_comp_app2 :
    forall v u u' l, step u u' -> step v@(u,l) v@(u',l).
  ...
End CompatibilityLemmas.  
\end{lstlisting}

\subsection{\lst$CanonicalIsomorphism.v$}

This module contains proofs for every result dealing with the isomorphism of the canonical subsystem in $\LamM$ and the system $\LamV$.

\subsection{\lst$Conservativeness.v$}

This module is only about the proof for the theorem of conservativeness.

\subsection{A closer look at the mechanisation}

\subsubsection{\textit{Autosubst} and a non standard substitution operation}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
