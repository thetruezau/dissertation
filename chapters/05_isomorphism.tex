\chapter{The isomorphism $\Lam \cong \LamV$}
\label{c:isomorphism}
In~\cref{c:background}, the simply typed $\Lam$-calculus was introduced.

Now, we show an isomorphism between the system $\LamV$ introduced in the previous chapter and the simply typed $\Lam$-calculus.
This isomorphism will come at the level of syntax, reduction, typing rules and $\beta$-normal forms.

This is of great interest as $\LamV$ typing rules resemble a sequent calculus style.
Thus, we have a correspondence between natural deduction (typing rules of $\Lam$-calculus) and a fragment of sequent calculus.
The chapter is inspired in the works~\cite{LuisDychkoff} and~\cite[Chapter~4]{JCES2002}.
The following diagram summarizes what we will be achieved in this chapter.

% https://q.uiver.app/#q=WzAsNCxbMiwwLCJcXGJveGVke1xcdmVjIFxcbGFtYmRhfSJdLFsyLDIsIlxcYm94ZWR7XFxzbWFsbHtcXHZlYyBcXGJldGEtbmZzfX0iXSxbMCwwLCJcXGJveGVkXFxsYW1iZGEiXSxbMCwyLCJcXGJveGVke1xcc21hbGx7XFxiZXRhLW5mc319Il0sWzAsMSwiXFxkb3duYXJyb3dfe1xcdmVjIFxcYmV0YX0iLDFdLFsyLDMsIlxcZG93bmFycm93X1xcYmV0YSIsMV0sWzMsMSwiXFxjb25nIiwxLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoiYXJyb3doZWFkIn19fV0sWzIsMCwiXFxwc2kiLDEseyJvZmZzZXQiOi0yfV0sWzAsMiwiXFx0aGV0YSIsMSx7Im9mZnNldCI6LTJ9XV0=
\[\begin{tikzcd}
    {\boxed\lambda} && {\boxed{\vec \lambda}} \\
    \\
    {\boxed{\small{\beta-nfs}}} && {\boxed{\small{\vec \beta-nfs}}}
    \arrow["\psi"{description}, shift left=2, from=1-1, to=1-3]
    \arrow["{\downarrow_\beta}"{description}, from=1-1, to=3-1]
    \arrow["\theta"{description}, shift left=2, from=1-3, to=1-1]
    \arrow["{\downarrow_{\vec \beta}}"{description}, from=1-3, to=3-3]
    \arrow["\cong"{description}, <->, from=3-1, to=3-3]
  \end{tikzcd}\]

The $\vec \beta$ refers to the $\beta$-reduction steps in system $\LamV$ and is used in the diagram to create a clear distinction.

\section{Mappings $\theta$ and $\psi$}

\begin{definition}
  Consider the following maps $\theta$ and $\theta'$:
  \begin{align*}
    \theta : \LamV \text{-terms} &\to \Lam \text{-terms} \\
    var(x) &\mapsto x \\
    \lambda x . t &\mapsto \lambda x . \theta(t) \\
    app_v (x, u, l) &\mapsto \theta'(x, u::l) \\
    app_\lambda (x. t, u, l) &\mapsto \theta'(\lambda x . \theta(t), u::l)
  \end{align*}
  \begin{align*}
    \theta' : (\Lam \text{-terms} \times \LamV \text{-lists}) & \to \Lam \text{-terms} \\
    (M, []) &\mapsto M \\
    (M, u::l) &\mapsto \theta'(M \ \theta(u), l).
  \end{align*}
\end{definition}
  
\begin{definition}
  Consider the following map $\psi'$:
  \begin{align*}
    \psi' : (\Lam \text{-terms} \times \LamV \text{-lists}) &\to \LamV \text{-terms} \\
    (x, []) &\mapsto var(x) \\
    (x, u::l) &\mapsto app_v (x, u, l) \\
    (\lambda x . M, []) &\mapsto \lambda x . \psi(M) \\
    (\lambda x . M, u::l) &\mapsto app_\lambda (x . \psi(M), u, l) \\
    (M N, l) &\mapsto \psi'(M, \psi(N)::l),              
  \end{align*}
  where $\psi(M)$ is defined as $\psi'(M, [])$.
\end{definition}

\subsection{Bijection at the level of terms}

\begin{lemma}
  \label{theta_inversion_lemma}
  \begin{align*}
    \theta \circ \psi' &= \theta'    
  \end{align*}
\end{lemma}
\begin{proof}
  The proof proceeds by induction on the structure of $\Lam$-terms.
\end{proof}


\begin{theorem}
  \label{theta_psi_inversion}
  \begin{align*}
    \theta \circ \psi &= id_{\Lam \text{-terms}}
  \end{align*}
\end{theorem}
\begin{proof}
  The proof proceeds by induction on the structure of $\Lam$-terms and uses as lemma for the application case the~\cref{inversion_lemma}.
\end{proof}


\begin{theorem}
  \label{psi_theta_inversion}
  \begin{align*}
    \psi \circ \theta &= id_{\LamV \text{-terms}} \\
    \psi \circ \theta' &= \psi'    
  \end{align*}
\end{theorem}
\begin{proof}
  The proof proceeds by simultaneous induction on the structure of $\LamV$-terms and $\LamV$-lists.
\end{proof}


\subsection{Isomorphism at the level of reduction}

First, we need to introduce some lemmata that establish the preservation of substitution operations by the mappings $\theta, \theta'$ and $\psi'$.
% Proofs of lemmas will now be omitted as they are all formalized in the proof assistant and usually proceed routinely.

\begin{lemma}
  \label{theta_app_lemma}
  For every $\LamV$-terms $t, u$ and $\LamV$-list $l$,
  \[ \theta(t@(u, l)) = \theta'(\theta(t) \ \theta(u), l) \]
  and also, for every $\Lam$-term $M$, $\LamV$-term $u'$ and $\LamV$-lists $l, l'$,
  \[ \theta'(M, l+(u'::l')) = \theta'(\theta'(M, l) \ \theta(u'), l'). \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of the $\LamV$-term $t$ on the first proposition and on the structure of the $\LamV$-list $l$ on the second proposition.
\end{proof}

\begin{corollary}
  \label{psi_app_lemma}
  For every $\Lam$-term $M$, $\LamV$-term $u$ and $\LamV$-list $l$,
  \[ \psi'(M, u :: l) = \psi(M)@(u, l). \]
\end{corollary}
\begin{proof}
  The result follows as a corollary of~\cref{theta_app_lemma}, using~\cref{psi_theta_inversion} and~\cref{theta_inversion_lemma} to rewrite the left-hand side of the equality.
\end{proof}

\begin{lemma}
  \label{theta_subst_lemma}
  For every $\LamV$-terms $t, u$,
  \[ \theta(t[x := u]) = \theta(t)[x := \theta(u)] \]
  and also, for every $\Lam$-term $M$,  $\LamV$-term $u$ and $\LamV$-list $l$,
  \[ \theta'(M[x := \theta(u)], l[x := u]) = \theta'(M, l)[x := u]. \]
\end{lemma}
\begin{proof}
  The proof follows by simultaneous induction on the structure of $\LamV$-terms and -lists, using~\cref{theta_app_lemma}.
\end{proof}
  
\begin{lemma}
  \label{psi_subst_lemma}
  For every $\Lam$-terms $M, N$ and $\LamV$-list $l$,
  \[ \psi'(M[x := N], l[x := \psi(N)]) = \psi'(M, l)[x := \psi(N)]. \]
\end{lemma}
\begin{proof}
  The proof follows by simultaneous induction on the structure of $\LamV$-terms and -lists, using~\cref{psi_app_lemma}.
\end{proof}

Now, we can state the isomorphism at the level of reduction.

\begin{lemma}
  \label{theta_step_lemma}
  For every $\Lam$-terms $M, N$ and $\LamV$-list $l$,
  \[ M \to_{\beta} N \implies \theta'(M, l) \to_{\beta} \theta'(N, l). \]
\end{lemma}
\begin{proof}
  The proof follows easily by induction on the structure of the $\LamV$-list $l$.
\end{proof}

\begin{theorem}
  \label{theorem9}
  For every $\LamV$-terms $t, t'$,
  \[ t \to_{\beta} t' \implies \theta(t) \to_{\beta} \theta(t') \]
  and also, for every $\Lam$-term $M$ and $\LamV$-lists $l, l'$,
  \[ l \to_{\beta} l' \implies \theta'(M, l) \to_{\beta} \theta(M, l'). \]
\end{theorem}
\begin{proof}
  The proof proceeds by simultaneous induction on the structure of the step relation on $\LamV$-terms.

  \cref{theta_app_lemma} is useful for the cases of compatibility steps.

  \cref{theta_subst_lemma} is crucial for cases dealing with $\beta$ steps.
\end{proof}


\begin{theorem}
  \label{theorem10}
  For every $\Lam$-terms $M, N$ and $\LamV$-list $l$,
  \[ M \to_{\beta} N \implies \psi'(M, l) \to_{\beta} \psi(N, l). \]
\end{theorem}
\begin{proof}
  The proof proceeds by simultaneous induction on the structure if the step relation on $\Lam$-terms.

  \cref{psi_subst_lemma} is crucial for cases dealing with $\beta$ steps.
\end{proof}

\subsection{Isomorphism at the level of typed terms}

\begin{theorem}[$\theta$ admissibility]
  \label{theorem11}
  The following rules are admissible:
  \[ \begin{prooftree}
      \hypo{ \Gamma \vdash t : A }
      \infer1{ \Gamma \vdash \theta(t) : A } 
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash M : A }
      \hypo{ \Gamma ; A \vdash l : B }
      \infer2{ \Gamma \vdash \theta'(M, l) : B }.
    \end{prooftree} \]
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of the typing rules of $\LamV$-terms.
\end{proof}

\begin{theorem}[$\psi'$ admissibility]
  \label{theorem12}
  The following rules is admissible:
  \[ \begin{prooftree}
      \hypo{ \Gamma \vdash M : A }
      \hypo{ \Gamma ; A \vdash l : B }
      \infer2{ \Gamma \vdash \psi'(M, l) : B }.
    \end{prooftree} \]
\end{theorem}
\begin{proof}
  The proof proceeds easily by induction on the structure of the typing rules of $\Lam$-terms.
\end{proof}

\subsection{Bijection at the level of normal forms}

For the following results recall both~\cref{beta_nfs} and~\cref{beta_nfs_can}.
We prove both bijections directly and give a hint on how they could be proved using the claims that we have provided.
One can find similar results to this in~\cite{LuisDychkoff}.

\begin{theorem}
  \begin{align*}
    \psi \circ \theta |_{\text{NT}} &= id_{\text{NT}} \\
    \psi \circ \theta'|_{\text{NA} \times \text{NL}} &= \psi' |_{\text{NA} \times \text{NL}}
  \end{align*}
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of $\LamV$-terms in $\text{NT}$ and $\LamV$-lists in $\text{NL}$.
\end{proof}

\begin{theorem}
  \begin{align*}
    \theta \circ \psi |_{\text{NF}} &= id_{\text{NF}} \\
    \theta \circ \psi'|_{\text{NA} \times \text{NL}} &= \theta' |_{\text{NA} \times \text{NL}}
  \end{align*}
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of $\Lam$-terms in $\text{NF}$ and $\text{NA}$.
\end{proof}

Alternatively, we could prove that $M \in \text{NF} \implies \psi(M) \in \text{NT}$ and $t \in \text{NT} \implies \theta(t) \in \text{NF}$. Then, the shown theorems would automatically follow.

For example, from the assumption that $M \in \text{NF}$, using~\cref{beta_nfs_claim}, one gets that $M$ is irreducible by $\to_\beta$.
Then, from~\cref{theorem10}, $\psi(M)$ is also irreducible by $\to_\beta$ (in $\LamV$), which in turn means that $\psi(M) \in \text{NT}$ (by~\cref{beta_nfs_can_claim}).

\section{Mechanisation in \textit{Rocq}}

In this section we provide a brief description of the mechanisations, as they follow from many previous definitions.
Essentially, we just defined maps $\theta$ and $\psi$ and mechanised every result.

One detail that may be highlighted is the definition for maps $\theta$ and $\theta'$.
\begin{lstlisting}[language=Coq]
Fixpoint theta (t: Canonical.term) : Lambda.term :=
  match t with
  | Vari x => Var x
  | Lamb t => Lam (theta t)
  | VariApp x u l => fold_left (fun s v => App s (theta v)) (u::l) (Var x)
  | LambApp t u l => fold_left (fun s v => App s (theta v)) (u::l) (Lam (theta t))
  end.

Definition theta' (s: Lambda.term) (l: list Canonical.term) :
  Lambda.term := fold_left (fun s v => App s (theta v)) l s.
\end{lstlisting}

The mechanised objects that represents map $\theta'$ uses a higher order function on lists called \lst$fold_left$ that behaves exactly as $\theta'$, given the function \lst$(fun s v => App s (theta v))$ which folds the $\LamV$-list into a $\Lam$-term.

This was an undesired consequence of the use of polymorphic lists in the definition for $\LamV$-terms.
We could not define mutually recursive functions on the structure of the term and list because the proof assistant fails to recognise their termination.
Instead, we have to define these maps using higher order functtions.
In this specific case, we could even enjoy the generality of the \lst$fold_map$ function.

As the mechanised $\theta'$ is defined after $\theta$, we have to consistently fold the definition for $\theta'$ in proofs to make them goal more readable.
\begin{lstlisting}[language=Coq]
Lemma theta'_step_pres l :
  forall s s', Lambda.step s s' -> Lambda.step (theta' s l) (theta' s' l).
Proof.
  induction l as [| u l]; intros ; asimpl ; try easy.
  - fold (theta' (App s (theta u)) l).
    fold (theta' (App s' (theta u)) l).
    apply IHl. now constructor.
Qed.
\end{lstlisting}


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
