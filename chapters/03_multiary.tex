\chapter{Multiary $\Lam$-calculus and its canonical subsystem}
\label{c:multiary}

This chapter introduces the main system that was studied in this dissertation: the multiary $\Lam$-calculus ($\LamM$).
We introduce this system as the system $\pmb{\lambda \mathcal{P}h}$ studied in~\cite[Chapter~3]{JCES2002}.
This system can also be found as $\pmb{\lambda^m}$ in~\cite[Section~3]{JCESLuis}, as a subsystem of $\pmb{\lambda J^m}$.

We provide an alternative description for a subsystem of $h$-normal forms of $\LamM$ (corresponding to the system $\pmb{\lambda \mathcal{P}}$ from \cite[Chapter~3]{JCES2002}).
At the end of this chapter one can find a detailed overview of the mechanisation done in this dissertation of the multiary $\Lam$-calculus and its canonical subsystem.

\section{The system $\LamM$}

First, we introduce some standard definitions for our system, like the grammar for $\LamM$-terms, a typical append operation on lists and substitution operation.

\begin{definition}[$\LamM$-expressions]
  The $\LamM$-terms are simultaneously defined with $\LamM$-lists by the following grammar:  
  \begin{align*} 
    (\LamM \text{-terms}) && \hspace{-2cm} t, u, v &::= \ x \ | \ \lambda x . t \ | \ t(u, l) \ \\
    (\LamM \text{-lists}) && \hspace{-2cm} l       &::= \ []\  | \ u :: l.
  \end{align*}
  We will refer to the union of $\LamM$-terms and $\LamM$-lists as $\LamM$-expressions.
\end{definition}

\begin{definition}[Append]
  The append of two $\LamM$-lists, $l + l'$, is defined recursively on $l$ as follows:
  \begin{align*}
    [] + l'     &= l', \\
    (u::l) + l' &= u::(l + l').
  \end{align*}
\end{definition}

\begin{definition}[Substitution for $\LamM$-expressions]
  The substitution of a variable $x$ by a $\LamM$-term $v$ is mutually defined by recursion over $\LamM$-expressions as follows:  
  \begin{align*}
  & x[x := v] = v ; \\
  & y[x := v] = y \text{, with } x \neq y ; \\
  & (\lambda y . t)[x := v] = \lambda y . (t[x := v]) ; \\
  & t(u, l)[x := v] = t[x := v](u[x := v], l[x := v]) ; \\    
  & [][x := v] = [] ; \\
  & (u::l)[x := v] = u[x := v] :: l[x := v] .
  \end{align*}
\end{definition}

% ---

\begin{definition}[Reduction rules for $\LamM$-terms]
  Consider the following reduction rules for $\LamM$-terms.
  \begin{align*}
    (\beta_1) & \qquad (\lambda x . t)(u, [])   \to t[x := u] \\
    (\beta_2) & \qquad (\lambda x . t)(u, v::l) \to t[x := u](v, l) \\
    (h)       & \qquad t(u, l)(u', l')          \to t(u, l + (u'::l'))
  \end{align*}
  Of course, one may also interpret the given rules as binary relations on $\LamM$-terms.
  That way, we define a relation $\beta$ as the relation $\beta_1 \cup \beta_2$ and analogously a relation $\beta h$ as the relation $\beta \cup h$.
\end{definition}

% Therefore, we can make sense of the following definitions.

\begin{definition}[Compatible Relation]
  \label{compatible_relation}
  Let $R$ and $R'$ be two binary relations on $\LamM$-terms and $\LamM$-lists respectively.
  We say they are compatible when they satisfy:
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (\lambda x . t, \lambda x . t') \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (t(u, l), t'(u, l)) \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (t(u, l), t(u', l)) \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (t(u, l), t(u, l')) \in R } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (u::l, u'::l) \in R' } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (u::l, u::l') \in R' } 
    \end{prooftree}
  \]
\end{definition}

\begin{notation}
  We will use the same notation for relations introduced in \cref{c:background}.
  As the compatible closure induces two relations, one on terms and the other on lists, we will use the already familiar notation $\to_R$ for both these relations as we can get out of the context which one is being referenced.
\end{notation}
Then, we will have the induced relations $\to_\beta$ and $\to_{\beta h}$ on $\LamM$-expressions.
We may also refer to the multistep analogous relations $\twoheadrightarrow_\beta$ and $\twoheadrightarrow_{\beta h}$.

% ---

We turn now our attention to the typing system of $\LamM$.
Given that $\LamM$ has two syntactic categories of expressions, its typing system will deal with two different kinds of sequents.

\begin{definition}[Sequent]
  A sequent on terms~$\Gamma \vdash t:A$ is a triple of a context, a $\LamM$-term and a simple type.
  A sequent on lists~$\Gamma;A \vdash l:B$ is a quadruple of a context, a simple type, a $\LamM$-list and another simple type.
\end{definition}

\begin{definition}[Typing Rules for $\LamM$-terms]
  \[
    \begin{prooftree}
      \infer0[Var]{ x:A, \Gamma \vdash x:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ x:A, \Gamma \vdash t:B }
      \infer1[Abs]{ \Gamma \vdash \lambda x . t : A \supset B  } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ \Gamma \vdash t : A \supset B }
      \hypo{ \Gamma \vdash u : A }
      \hypo{ \Gamma ; B \vdash l : C }	
      \infer3[mApp]{ \Gamma \vdash t(u, l) : C } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \infer0[Nil]{ \Gamma ; A \vdash []:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash u:A }
      \hypo{ \Gamma ; B \vdash l:C }
      \infer2[Cons]{ \Gamma ; A \supset B \vdash  u::l : C } 
    \end{prooftree}
  \]
\end{definition}

As usual a sequent derivation is a tree-like structure, with root being the derived sequent and leaves being instances of the axioms (Var-rule or Nil-rule).

% --- 
% 123
% ---
% \section{Subject reduction for $\LamM$}

Now follow two necessary lemmas for the result of subject reduction that state the admissibility of substitution and append operations.

\begin{lemma}[Substitution is admissible]
  \label{type_substitution}
  The following rules are admissible:
  \[
    \begin{prooftree}
      \hypo{ \Gamma , x:B \vdash t:A }
      \hypo{ \Gamma \vdash u:B }
      \infer2{ \Gamma \vdash  t[x := u] : A }      
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma , x:B \ ; C \vdash l:A }
      \hypo{ \Gamma \vdash u:B }
      \infer2{ \Gamma ; C \vdash  l[x := u] : A }
    \end{prooftree}.
  \]
\end{lemma}
\begin{proof}
  The proof proceeds by simultaneous induction on the structure of the term $t$ and list $l$.
\end{proof}

\begin{lemma}[Append is admissible]
  \label{append_is_admissible}
  The following rule is admissible:
  \[
    \begin{prooftree}
      \hypo{ \Gamma ; C \vdash l:B }
      \hypo{ \Gamma ; B \vdash l':A }
      \infer2{ \Gamma ; C \vdash  l+l' : A }
    \end{prooftree}.
  \]
\end{lemma}
\begin{proof}
  The proof proceeds by induction on the structure of $l$.
\end{proof}

% ---

Subject reduction then states that any given term preserves its type upon $\beta h$ reduction.

\begin{theorem}[Subject reduction]
  \label{type_preservation}
  Given $\LamM$-terms $t$ and $t'$, the following holds:
  \[
    \Gamma \vdash t : A \ \land \ t \to_{\beta h} t' \implies \Gamma \vdash t' : A.
  \]
\end{theorem}
\begin{proof}
  The proof proceeds by induction on the structure of the relation $\to_{\beta h}$.

  \cref{type_substitution} is used to prove the case where $(t, t') \in \beta$.

  \cref{append_is_admissible} is used to prove the case $(t, t') \in h$.
\end{proof}

\begin{corollary}[Multistep subject reduction]
  \label{type_preservation2}
  Given $\LamM$-terms $t$ and $t'$, the following holds:
  \[
    \Gamma \vdash t : A \ \land \ t \twoheadrightarrow_{\beta h} t' \implies \Gamma \vdash t' : A.
  \]
\end{corollary}
\begin{proof}
  Trivial.
\end{proof}
  
Other classical results from $\Lam$-calculus - such as strong normalisation - could also be shown for system $\LamM$, but are not covered in this dissertation.
The confluence for this system is proven in \cref{c:isomorphism}.

% ---
% 123
% ---

\section{The canonical subsystem}

The canonical subsystem is a system within $\LamM$ containing only terms in $h$-normal form.
In this section we see how to equip canonical terms with an appropriate notion of $\beta$-reduction and appropriate typing rules.

\begin{definition}[$h$-normal form]
  We say that a $\LamM$-term $t$ is in $h$-normal form when there exists no $\LamM$-term $t'$ such that \[ t \to_h t' . \]
\end{definition}

\begin{definition}[Canonical expressions]
  \label{canonical_terms}
  We inductively define the subsets of $\LamM$-terms and $\LamM$-lists, respectively $Can$ and $CanList$, as follows:
  \[
    \begin{prooftree}
      \infer0{ x \in Can } 
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ t \in Can }
      \infer1{ \lambda x . t \in Can } 
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer2{ x(u, l) \in Can }
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ t \in Can } 
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer3{ (\lambda x. t)(u, l) \in Can }
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \infer0{ [] \in CanList } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer2{ u::l \in CanList }
    \end{prooftree}
  \]

  $\LamM$-terms $t \in Can$ are also called canonical terms.
  Analogously, $\LamM$-lists $l \in CanList$ are called canonical lists.
  Canonical expressions will refer to the set $Can \cup CanList$.
\end{definition}

Similar to what was done in \cref{c:background}, we leave a claim stating that the canonical terms are exactly the $\LamM$-terms in $h$-normal form.

\begin{claim}
  Given a $\LamM$-term $t$, the following are equivalent:

  (i) $t \in Can$.

  (ii) $t$ is in $h$-normal form.
\end{claim}

Now, we will describe how the canonical terms generate a subsystem.

First, we define the function $app : Can \times Can \times CanList \to Can$ that will behave as a multiary application constructor closed for the canonical terms.

\begin{definition}
  Given $t, u \in Can$ and $l \in CanList$, the operation $app(t, u, l)$ is defined by the following equations:
  \begin{align*}
    app(x, u, l)                      &= x(u, l), \\
    app(\lambda x. t, u, l)           &= (\lambda x. t)(u, l), \\ 
    app(x(u', l'), u, l)              &= x(u', l' + (u::l)) \\
    app((\lambda x. t)(u', l'), u, l) &= (\lambda x. t)(u', l'+(u::l)).
  \end{align*}  
\end{definition}

\begin{lemma}
  \label{app_is_multistep}
  Given $t, u \in Can$ and $l \in CanList$, 
  \[ t(u, l) \twoheadrightarrow_h app(t, u, l) \qquad \text{(in $\LamM$)}. \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by inspection of term $t$.

  For the cases where $t$ is not an application, we have an equality.
\end{proof}

Then, we define a function that collapses $\LamM$-terms to their $h$-normal form.

\begin{definition}
  Consider the following map $h : \LamM \text{-terms} \to Can$, recursively defined as follows:
  \begin{align*}
    h(x)            &= x \\
    h(\lambda x. t) &= \lambda x . h(t) \\
    h(t(u,l))       &= app(h(t), h(u), h(l)) \\
    h([])           &= [] \\
    h(u::l)         &= h(u)::h(l).
  \end{align*}
\end{definition}

\begin{proposition}[Map $h$ performs $\twoheadrightarrow_h$]
  \label{h_is_multistep}
  For every $\LamM$-term $t$, \[ t \twoheadrightarrow_h h(t), \]
  and also, for every $\LamM$-list $l$, \[ l \twoheadrightarrow_h h(l). \]
\end{proposition}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of $\LamM$-expressions.
  As map $h$ is defined using $app$, \cref{app_is_multistep} is crucial for the case where $t$ is an application. 
\end{proof}

With the following auxiliary result we can easily prove the confluence of $\twoheadrightarrow_h$.

\begin{lemma}[Map $h$ collapses $\to_h$]
  \label{h_collapse}
  For every $\LamM$-terms $t, t'$, \[ t \to_h t' \implies h(t) = h(t'). \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by induction on the structure of $t \to_h t'$.
\end{proof}

\begin{corollary}[Confluence of $\twoheadrightarrow_h$]
  For every $\LamM$-terms $t, t_1, t_2$,
  % https://tikzcd.yichuanshen.de/#N4Igdg9gJgpgziAXAbVABwnAlgFyxMJZARgBoAGAXVJADcBDAGwFcYkQcQBfU9TXfIRTlSxanSat2OAPrFuvEBmx4CRAEyjxDFm0QcZ6hXxWCiZddsl6QACwAUOAJTdxMKAHN4RUADMAThAAtkgiHBBIZHYw9FDSAO4QtjFQCDSM9ABGMIwACvyqQiD+WB62nDx+gSGIYTgRiJrRsQlJKQiVIAHBkTT1SADMNMkt+jiJI6nGXdVITf2IQ81xYxPt0901dQ1Lk62TaSCMWGA2UPRwyXFclFxAA
  \[\begin{tikzcd}
      & t \arrow[ld, two heads, "h"] \arrow[rd, two heads, "h"] \arrow[dd, two heads, dashed, "h"] & \\
      t_1 \arrow[rd, two heads, "h"] && t_2 \arrow[ld, two heads, "h"] \\
      & h(t) & 
    \end{tikzcd}\]
\end{corollary}
\begin{proof}
  Immediate by \cref{h_collapse,h_is_multistep}.
\end{proof}

The following theorem states that the canonical terms are invariant or fixpoints for map $h$.
Another way to look at this result is by saying that $h$ is surjective.

\begin{proposition}[Invariance of canonical terms by $h$]
  \label{h_fixpoints}
  For every $t \in Can$, \[ h(t) = t, \]
  and also, for every $l \in CanList$, \[ h(l) = l. \]
\end{proposition}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of canonical expressions.
\end{proof}

For the purpose of defining a subsystem of $\LamM$, we will see how to induce a reduction relation for these canonical expressions given a reduction relation on $\LamM$-expressions.

\begin{definition}[Canonical relation closure]
  \label{canonical_closure}
  Let $R$ and $R'$ be two binary relations on $\LamM$-terms and $\LamM$-lists respectively.
  We inductively define the relations $R_c$ and $R'_c$, on canonical terms and lists respectively, as follows:
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (h(t), h(t')) \in R_c } 
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (h'(l), h'(l')) \in R'_c } 
    \end{prooftree}.
  \]

  We call canonical relation closure of $R$ and $R'$ to the induced relations $R_c$ and $R'_c$.
\end{definition}

This definition allows us to define a concept of $\beta$-reduction for the canonical terms, namely~${(\to_\beta)}_c$, derived from the relation $\to_\beta$ in $\LamM$.
But this definition tells us little about the relation itself \dots an interesting question is: how does a $\beta$-reduction (as in the previous definition) behave on the canonical terms?

Given $t, u \in Can$, lets see how to reduce $(\lambda x . t)(u, [])$.
The definition of $(\to_\beta)_c$ stipulates: 
\[ \begin{prooftree}
    \hypo{ (\lambda x.t)(u, []) \to_\beta t[x := u] }
    \infer1[]{ h((\lambda x.t)(u, [])) \ (\to_\beta)_c \ h(t[x := u]) }
  \end{prooftree} \]
Given that $t, u \in Can$, we get that $(\lambda x.t)(u, []) \in Can$.
Therefore, from~\cref{h_fixpoints}, we get $(\lambda x.t)(u, []) \ (\to_\beta)_c \ h(t[x := u])$.

Furthermore, from this definition, we could even prove certain properties of $(\to_\beta)_c$, such as:
\[ \begin{prooftree}
    \hypo{ t \ (\to_\beta)_c \ t' }
    \infer1{ \lambda x.t \ (\to_\beta)_c \ \lambda x.t' }.
  \end{prooftree} \]

This follows from ``inverting'' $t \ (\to_\beta)_c \ t'$.
Firstly, one observes that there exist $\LamM$-terms $u, u'$ such that $h(u) = t$ and $h(u') = t'$ and $u \to_\beta u'$.
Then, 
\[ \begin{prooftree}
    \hypo{ u \to_\beta u' }
    \infer1[\text{(compatibility of $\to_\beta$)}]{ \lambda x.u \to_\beta \lambda x.u' }
    \infer1[\text{(\cref{canonical_closure})}]{ h(\lambda x.u) \ (\to_\beta)_c \ h(\lambda x.u') }
  \end{prooftree} \]

Lastly, simplifying $h$ and rewriting $h(u)$ and $h(u')$, we conclude that $\lambda x.t \ (\to_\beta)_c \ \lambda x.t'$.

We now conclude the presentation of the canonical subsystem in $\LamM$, by equipping canonical expressions with a typing relation, in the same spirit of~\cref{canonical_closure}.

\begin{definition}[Canonical typing closure]
  \label{canonical_typing}
  We define the derivable sequents for canonical expressions as follows:
  \[
    \begin{prooftree}
      \hypo{ \Gamma \vdash t:A }
      \infer1{ \Gamma \vdash_c h(t):A } 
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma ; A \vdash l:B }
      \infer1{ \Gamma ; A \vdash_c h'(l):B }.
    \end{prooftree}
  \]
\end{definition}

Also, from the previous definition, we may ask similar questions to those asked above about $\beta$-reduction for canonical expressions.
For example, given $t \in Can$, is the following rule admissible?
\[
  \begin{prooftree}
    \hypo{ x:A, \Gamma \vdash_c t:B }
    \infer1{ \Gamma \vdash_c \lambda x.t : A \supset B } 
  \end{prooftree}
\]

By inverting our assumption of $x:A, \Gamma \vdash_c t:B$, we get that there exists $t'$, such that $h(t') = t$ and $x:A, \Gamma \vdash t':B$ is derivable in $\LamM$. Then,
\[
  \begin{prooftree}
    \hypo{ x:A, \Gamma \vdash t':B }
    \infer1[Lam]{ \Gamma \vdash \lambda x . t' : A \supset B }
    \infer1[\text{(\cref{canonical_typing})}]{ \Gamma \vdash_c h(\lambda x . t') : A \supset B }
  \end{prooftree}
\]

And again, simplifying and rewriting $h$, we have derived the sequent $\Gamma \vdash_c \lambda x.t : A \supset B$.

Our presentation of the canonical subsystem of $\LamM$ does not exactly coincide with system $\pmb{\lambda \mathcal{P}}$ from~\cite[Chapter~3.1]{JCES2002}.
We define a subsystem of $\LamM$ by restricting our syntax of expressions via a map $h$.
Then, we introduce reduction and a typing relation by exclusively using map $h$.
Trivially, we get a subsystem with appropriate notions of reduction and typing but still preserving their expected behaviour (as seen above).

In our work, motivated by the task of mechanisation, we distinguish between a subsystem of $\LamM$ in the sense we have described before and an isomorphic system with its own syntax, substitution, reduction and typing rules (this is the system~$\LamV$ that will be covered in~\cref{c:canonical}).
We explain some details and motivations for this at the end of the next section.
% In the next chapter we will present a self-contained version of this subsystem and prove both representations are isomorphic.

% ---
% 123
% ---

\section{Mechanisation in \textit{Rocq}}

The mechanisation of the system $\LamM$ also crucially relies on the \textit{Autosubst} library, and essentially follows the style adopted for the mechanisation of the simply typed $\Lam$-calculus we have seen in~\cref{c:background}.

\subsection{\lst$LambdaM.v$}

This module contains the necessary definitions for the various aspects of the formalisation of system $\LamM$ performed in this dissertation.
The inductive type for the syntax of $\LamM$-terms is as follows.
\begin{lstlisting}[language=Coq]
Inductive term: Type :=
| Var (x: var)
| Lam (t: {bind term})
| mApp (t: term) (u: term) (l: list term).
\end{lstlisting}
Note that the definition for $\LamM$-lists is hidden under the polymorphic list type \lst$list term$.
We give more details on this option at the end of this section.

To mechanise the reduction relations, we first defined the notion of compatibility for binary relations on $\LamM$-expressions (as in~\cref{compatible_relation}) and then define the base step relations $\beta_1$, $\beta_2$ and $h$ separately.
That way we can distinguish between the notions of compatible closure of a base relation and of a relation being compatible.
This approach is more elaborated than the one presented for the simply typed $\Lam$-calculus and we also get into more details about these decisions at the end of this section.

\begin{lstlisting}[language=Coq]
Inductive beta1: relation term :=
| Step_Beta1 (t: {bind term}) (t' u: term) :
  t' = t.[u .: ids] -> beta1 (mApp (Lam t) u []) t'.

Inductive beta2: relation term :=
| Step_Beta2 (t: {bind term}) (t' u v: term) l :
  t' = t.[u .: ids] -> beta2 (mApp (Lam t) u (v::l)) (mApp t' v l).

Inductive H: relation term :=       
| Step_H (t u u': term) l l' l'' :
  l'' = l ++ (u'::l') -> H (mApp (mApp t u l) u' l') (mApp t u l'').

Definition step := comp (union _ (union _ beta1 beta2) H).
Definition step' := comp' (union _ (union _ beta1 beta2) H).

Definition multistep := clos_refl_trans_1n _ step.
Definition multistep' := clos_refl_trans_1n _ step'.
\end{lstlisting}

Here, \lst$comp$ and \lst$comp'$ are the polymorphic relations on $\LamM$-expressions that induce the compatibility closure.
We also note the use of the \lst$clos_refl_trans_1n$ polymorphic relation provided by the \textit{Rocq Prover} libraries that induces the reflexive and transitive closure of a given binary relation.

In this module, we also find the formalisation of the typing relation for $\LamM$, through an inductively defined relation, much in the style of what was done for the simply typed $\Lam$-calculus.
\begin{lstlisting}[language=Coq]
Inductive sequent (Gamma: var->type) : term -> type -> Prop := 
| varAxiom (x: var) (A: type) :
  Gamma x = A -> sequent Gamma (Var x) A
| Right (t: term) (A B: type) :
  sequent (A .: Gamma) t B -> sequent Gamma (Lam t) (Arr A B)
| HeadCut (t u: term) (l: list term) (A B C: type) :
  sequent Gamma t (Arr A B) -> sequent Gamma u A -> list_sequent Gamma B l C ->
  sequent Gamma (mApp t u l) C
with list_sequent (Gamma:var->type) : type -> (list term) -> type -> Prop :=
| nilAxiom (C: type) : list_sequent Gamma C [] C
| Lft (u: term) (l: list term) (A B C:type) :
  sequent Gamma u A -> list_sequent Gamma B l C ->
  list_sequent Gamma (Arr A B) (u :: l) C.
\end{lstlisting}

\subsection{\lst$TypePreservation.v$}

This module contains the proof of the subject reduction theorem (\cref{type_preservation}) and necessary lemmas to prove it (recall~\cref{type_substitution}).

\begin{lstlisting}[language=Coq]
Theorem type_preservation :
  (forall t t', step t t' -> forall Gamma A, sequent Gamma t A -> sequent Gamma t' A)
  /\
  (forall l l', step' l l' -> forall Gamma A B, list_sequent Gamma A l B ->
                                 list_sequent Gamma A l' B).
\end{lstlisting}

Using \textit{Autosubst}, we have to prove not only the preservation of types by the substitution operation but also by renamings.
We prove these results using the techniques in the tutorial~\cite{AutosubstManual}.

\begin{lstlisting}[language=Coq]
Lemma type_renaming :
  forall Γ,
    (forall t A, sequent Gamma t A ->
       forall Delta xi, Gamma = (xi >>> Delta) -> sequent Delta t.[ren xi] A)
    /\
    (forall A l B, list_sequent Γ A l B ->
       forall Delta xi, Gamma = (xi >>> Delta) -> list_sequent Delta A l..[ren xi] B).
...
Lemma type_substitution :
  forall Gamma, 
    (forall t A, sequent Gamma t A ->
       forall sigma Delta, (forall x, sequent Delta (sigma x) (Gamma x)) -> sequent Delta t.[sigma] A)
    /\
    (forall A l B, list_sequent Γ A l B ->
       forall sigma Delta, (forall x, sequent Delta (sigma x) (Gamma x)) -> list_sequent Delta A l..[sigma] B).
\end{lstlisting}

For what is worth, we could prove a simpler statement (similar to~\cref{type_substitution}) to formalise the subject reduction theorem.
Such lemma would look like (without the proposition for lists):
\begin{lstlisting}[language=Coq]
Lemma weak_type_substitution Gamma t A :
  sequent (B.:Gamma) t A -> sequent Gamma u B ->
  sequent Gamma t.[u.:sigma] A).
\end{lstlisting}

The used \textit{Autosubst} approach takes this notion of well-typed substitutions or context morphisms (see~\cite[Chapter~4]{AutosubstSchafer}) to generalise these lemmas.

As already mentioned, we use the combined induction principles (for $\LamM$-expressions) to prove the statements that are declared using a conjunction on terms and lists.

\subsection{\lst$IsCanonical.v$}

This module contains the necessary definitions for the formalisation of the canonical subsystem of $\LamM$.

First, we define a predicate \lst$is_canonical$ that constructively defines the canonical expressions in the style of~\cref{canonical_terms}.
\begin{lstlisting}[language=Coq]
Inductive is_canonical: term -> Prop :=
| cVar (x: var) :
  is_canonical (Var x)
| cLam (t: {bind term}) :
  is_canonical t -> is_canonical (Lam t)
| cVarApp (x: var) (u: term) (l: list term) :
  is_canonical u -> is_canonical_list l ->
  is_canonical (mApp (Var x) u l)
| cLamApp (t: {bind term}) (u: term) (l: list term) :
  is_canonical t -> is_canonical u -> is_canonical_list l ->
  is_canonical (mApp (Lam t) u l)
with is_canonical_list: list term -> Prop :=
| cNil : is_canonical_list []
| cCons (u: term) (l: list term) :
  is_canonical u -> is_canonical_list l ->
  is_canonical_list (u::l).
\end{lstlisting}

The module then contains definitions for the $app$ operation (called \lst$capp$ because append of lists in \textit{Rocq} is already called \lst$app$) and map $h$.
\begin{lstlisting}[language=Coq]
Definition capp (v u: term) (l: list term) : term :=
  match v with
  | Var x        => mApp v u l
  | Lam t        => mApp v u l
  | mApp t u' l' => mApp t u' (l' ++ (u::l))
  end.

Fixpoint h (t: term) :=
  match t with
  | Var x      => Var x
  | Lam t      => Lam (h t)
  | mApp t u l => capp (h t) (h u) (map h l)
  end.
\end{lstlisting}
In our definition, \lst$map h$ (which calls the \lst$map$ function from the \lst$List$ library) behaves exactly as the intended map $h$ when applied to lists.
% OMITING: Notice that this way we also avoid a mutually dependent definition.

In the \textit{Rocq Prover}, we need to formally prove that the $app$ operation and map $h$ are closed for canonical terms.
% Of course that in description we have of the subsystem we easily argue this informally.
Note that in the case of our description of the subsystem in the previous section, it is easy to informally argue about this.
For example, in our mechanisation, we have the following lemma.
\begin{lstlisting}[language=Coq]
Lemma capp_is_canonical t u l :
  is_canonical t -> is_canonical u -> is_canonical_list l ->
  is_canonical (capp t u l).
\end{lstlisting}

Then, we prove all the lemmas, propositions and theorems presented in the description of the canonical subsystem.
As an example, we show the mechanisation of~\cref{h_fixpoints}.
\begin{lstlisting}[language=Coq]
Proposition h_fixpoints :
  (forall t, is_canonical t -> h t = t)
  /\
  (forall l, is_canonical_list l -> map h l = l).
Proof.
  apply mut_is_canonical_ind ;
    intros ; asimpl ; repeat f_equal ; auto.
Qed.
\end{lstlisting}
In this proof we use the \lst$auto$ tactic to facilitate our work.
For routine proofs, we often found success when using these automated tactics.

The module ends with definitions for the reduction relation (recall~\cref{canonical_closure}) and typing rules (recall~\cref{canonical_typing}) for the canonical subsystem.
\begin{lstlisting}[language=Coq]
Inductive canonical_relation
  (R: relation term) : relation term :=
| Step_CanTerm t t' : R t t' -> canonical_relation R (h t) (h t').
Inductive canonical_list_relation
  (R: relation (list term)) : relation (list term) :=
| Step_CanList l l' : R l l' -> canonical_list_relation R (map h l) (map h l').

Definition step_can := canonical_relation step_beta.
Definition step_can' := canonical_list_relation step_beta'.
...
Inductive canonical_sequent (Gamma: var->type) :
  term -> type -> Prop :=
| Seq_CanTerm t A : sequent Gamma t A -> canonical_sequent Gamma (h t) A.
Inductive canonical_list_sequent (Gamma: var->type) :
  type -> list term -> type -> Prop :=
| Seq_CanList l A B : list_sequent Gamma A l B ->
                      canonical_list_sequent Gamma A (map h l) B.
\end{lstlisting}

\subsection{A closer look at the mechanisation}

In this part we take a closer look at some particular aspects of the mechanisation that deserve more attention.
The purpose is to show how some other options could arise and justify aspects of our approach that may look unusual.

\subsubsection{Mutually inductive types vs nested inductive types}

Creating a mutually inductive type for the syntax of $\LamM$ in \textit{Rocq} would be a simple task:
\begin{lstlisting}[language=Coq]
  Inductive term: Type :=
  | Var (x: var)
  | Lam (t: {bind term})
  | mApp (t: term) (u: term) (l: list)
  with list: Type :=
  | Nil
  | Cons (u: term) (l: list). 
\end{lstlisting}

However, as reported in the final section of~\cite{AutosubstSchafer}, \textit{Autosubst} offers no support for mutually inductive definitions.
The \lst$derive$ tactic would not generate the desired instances for the \lst$Rename$ and \lst$Subst$ classes, failing to iterate through the customized list type.

As we tried to keep the decision of using \textit{Autosubst}, there were two possible directions:
\begin{enumerate}
\item manually define every instance required and prove substitution lemmas;
\item remove the mutual dependency in the term definition.
\end{enumerate}

The first formalisation attempts followed the first option.
This meant that everything \textit{Autosubst} could provide automatically was done by hand.
For this, we closely followed the definitions given in \cite{AutosubstSchafer}.

% At some point, the idea of using the polymorphic list type provided by the \textit{Rocq} standard library came up.
% Inspecting the \textit{Autosubst} code repository, one can find that there is some support for these kinds of mutually inductive definitions.

After some closer inspection of the library source code, we found that there was native support for the use of types depending on polymorphic lists.
This way, there was no need of having a mutual inductive type for our terms.
% After some further inspection of the library source code, we noticed that nested inductive types that depend on lists are already supported by default.

% This is obtained by an auxiliary function, $mmap$, that iterates through lists of terms.
% \dots falar da funcao mmap? \dots

The downside of using nested inductive types in the \textit{Rocq Prover} is the generated induction principles.
This issue is already well documented in \cite[Chapter~14.3]{CoqArt}.
With this approach, we need to provide the dedicated induction principles to the proof assistant, presented below.

\begin{lstlisting}[language=Coq]
Section dedicated_induction_principle.
  Variable P : term -> Prop.
  Variable Q : list term -> Prop.
  Hypothesis HVar : forall x, P (Var x).
  Hypothesis HLam : forall t: {bind term}, P t -> P (Lam t).
  Hypothesis HmApp : forall t u l, P t -> P u -> Q l -> P (mApp t u l).
  Hypothesis HNil : Q [].
  Hypothesis HCons : forall u l, P u -> Q l -> Q (u::l).
  
  Proposition sim_term_ind : forall t, P t.
  Proof.
    fix rec 1. destruct t.
    - now apply HVar.
    - apply HLam. now apply rec.
    - apply HmApp.
      + now apply rec.
      + now apply rec.
      + assert (forall l, Q l). {
            fix rec' 1. destruct l0.
            - apply HNil.
            - apply HCons.
              + now apply rec.
              + now apply rec'. }          
        now apply H.
  Qed.      
  
  Proposition sim_list_ind : forall l, Q l.
  Proof.
    fix rec 1. destruct l.
    - now apply HNil.
    - apply HCons.
      + now apply sim_term_ind.
      + now apply rec.
  Qed.          
End dedicated_induction_principle.
\end{lstlisting}

\subsubsection{Formalising a compatible closure}

Defining reduction relations in $\Lam$-calculi like systems always involve the notion of compatibility closure, as we want to allow reduction to happen at the level of subterms.

We took inspiration from the definitions in the \lst$Relations$ libraries of the \textit{Rocq Prover}.
This library provides many definitions on binary relations.
For example, there is a predicate that transitive relations satisfy (in \lst$Relation_Definitions$) and there is also a higher order relation that constructs the transitive closure of a given relation (in \lst$Relation_Operations$).

\begin{lstlisting}[language=Coq]
Definition transitive : Prop := forall x y z:A, R x y -> R y z -> R x z.
...
Inductive clos_trans (x: A) : A -> Prop :=
| t_step (y:A) : R x y -> clos_trans x y
| t_trans (y z:A) : clos_trans x y -> clos_trans y z -> clos_trans x z.
\end{lstlisting}

We followed these definitions to define compatibility notions for the system $\LamM$ in a modular way.
We define the compatible closure from a given base relation on $\LamM$-terms as follows:

\begin{lstlisting}[language=Coq]
Section Compatibilty.
  Variable base : relation term.
  
  Inductive comp : relation term :=
  | Comp_Lam (t t': {bind term}) : comp t t' ->
                                   comp (Lam t) (Lam t')
  | Comp_mApp1 t t' u l : comp t t' ->
                          comp (mApp t u l) (mApp t' u l)
  | Comp_mApp2 t u u' l : comp u u' ->
                          comp (mApp t u l) (mApp t u' l)
  | Comp_mApp3 t u l l' : comp' l l' ->
                          comp (mApp t u l) (mApp t u l')
  | Step_Base t t' : base t t' -> comp t t'
  with comp' : relation (list term) :=
  | Comp_Head u u' l : comp u u' -> comp' (u::l) (u'::l)
  | Comp_Tail u l l' : comp' l l' -> comp' (u::l) (u::l').

  Scheme sim_comp_ind := Induction for comp Sort Prop
    with sim_comp_ind' := Induction for comp' Sort Prop.
  Combined Scheme mut_comp_ind from sim_comp_ind, sim_comp_ind'.
End Compatibilty.
\end{lstlisting}

Then, we also define a record type that contains the necessary predicates to be satisfied by a compatible relation.

\begin{lstlisting}[language=Coq]
Section IsCompatible.
  Variable R : relation term.
  Variable R' : relation (list term).

  Record is_compatible := {
      comp_lam : forall t t': {bind term}, R t t' -> R (Lam t) (Lam t') ;
      comp_mApp1 : forall t t' u l, R t t' -> R (mApp t u l) (mApp t' u l) ;
      comp_mApp2 : forall t u u' l, R u u' -> R (mApp t u l) (mApp t u' l) ;
      comp_mApp3 : forall t u l l', R' l l' -> R (mApp t u l) (mApp t u l') ;
      comp_head : forall u u' l, R u u' -> R' (u :: l) (u' :: l) ;
      comp_tail : forall u l l', R' l l' -> R' (u :: l) (u :: l')
    }.
End IsCompatible.
\end{lstlisting}

From these modular definitions, we can prove some interesting (yet bureaucratic) results, like:

\begin{lstlisting}[language=Coq]
Theorem comp_is_compatible B : is_compatible (comp B) (comp' B).
Proof.
  split ; autounfold ; intros ; constructor ; assumption.
Qed.

Theorem clos_refl_trans_pres_comp :
  forall R R', is_compatible R R' ->
    is_compatible (clos_refl_trans_1n _ R) (clos_refl_trans_1n _ R').
Proof.
  intros R R' H. destruct H. 
  split ; intros ; induction H ; econstructor ; eauto.
Qed.
\end{lstlisting}

This theorem states that if we have a compatible relation, its reflexive and transitive closure is still compatible.

An advantage of these modular definitions is that we can use them to increase automation in our proofs.
In the main theorem that we prove in the next chapter (bellow is part of it, named \lst$conservativeness2$), our proof starts by adding every compatibility step to our context.
As the auto tactic tries to match hypothesis in the context with the goal, the compatibility steps are then covered automatically.

\begin{lstlisting}[language=Coq]
Lemma conservativeness2 :
  (forall (t t': LambdaM.term), LambdaM.step t t' ->
    Canonical.multistep (p t) (p t'))
  /\
  (forall (l l': list LambdaM.term), LambdaM.step' l l' ->
    Canonical.multistep' (map p l) (map p l')).
Proof.
  pose Canonical.multistep_is_compatible as H.
  destruct H. (* unpacking record type *)
  apply LambdaM.mut_comp_ind ; intros ; asimpl ; auto.
  ...
\end{lstlisting}

% deveria mostrar como o exemplo em Rocq funciona?

% ---

\subsubsection{Formalising a subsystem}

A relevant part of our work was to find simple representations for subsystems in the proof assistant.

As we pointed out, the formalisation we have done for the canonical subsystem of $\LamM$ is non standard.
These ideas were motivated by the task of mechanising such subsystem.

Formalising the subset of terms using a predicate is an obvious way to proceed.
But we would also like to have a dedicated type for the extension of that predicate rather than just the predicate itself.
The \textit{Rocq Prover} provides such types, known as subset types (we refer to~\cite[Chapter~9.1]{CoqArt}).
Although these subset types are exactly what we wanted, they do not give us a great advantage on mechanisation tasks.
Using subset types rapidly becomes exhausting because of the need to always provide proof objects in every definition.

As an example, trying to define the one step $\beta$-relation as in~\cite[Chapter~3.1]{JCES2002} for the canonical subsystem mechanised using subset types, we would get (supposing we had a mechanised substitution operation):
\begin{lstlisting}[language=Coq]
Definition canonical := { u: term | is_canonical u }. 
Definition canonical_list := { l: list term | is_canonical_list l }.
...
Inductive can_step : canonical -> canonical -> Prop :=
| cStep_Beta1 (t u: term) (it: is_canonical t) (iu: is_canonical u)
  (t': canonical) i:
  i = (cLamApp t u []) it iu cNil ->
  t' = (exist _ t it).[(exist _ u iu) .: ids] ->
  can_step (exist _ (mApp (Lam t) u []) i) t'
...
| cStep_Lam t t' it it' i1 i2 :
  i1 = (cLam t) it ->
  i2 = (cLam t') it' ->
  can_step (exist _ t it) (exist _ t' it') ->
  can_step (exist _ (Lam t) i1) (exist _ (Lam t') i2)
...
\end{lstlisting}

So far, our approach on the formalisation of the canonical subsystem of $\LamM$ was to view it according to map $h$, that is, defining reduction and typification using this map.
However, we may also define a self-contained version of the canonical subsystem with its own syntax and definitions (in the spirit of~\cite[Chapter~3.1]{JCES2002}). % , by having no reference to any definition from system $\LamM$ and
Then, we may prove that both representations are in fact isomorphic.
That is the goal for~\cref{c:canonical}.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
