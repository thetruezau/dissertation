\chapter{Multiary $\Lam$-calculus and its canonical subsystem}
\label{c:multiary}

This chapter introduces the main system that was studied in this thesis: the multiary $\Lam$-calculus ($\LamM$).
We introduce this system as the system $\pmb{\lambda \mathcal{P}h}$ found in~\cite[Chapter~3]{JCES2002} and $\pmb{\lambda^m}$ found in~\cite{JCESLuis}.
We also give an alternative description for a subsystem of $h$-normal forms in $\LamM$ (corresponding to the system $\pmb{\lambda \mathcal{P}}$ found in~\cite[Chapter~3]{JCES2002}).
In the end of this chapter one can find a detailed overview of the mechanisations done.

\section{The system $\LamM$}

\begin{definition}[Syntax of $\LamM$]
  The $\LamM$-terms and $\LamM$-lists are simultaneously defined by the following grammar:  
  \begin{align*} 
    t, u \ &::= \ x \ | \ \lambda x . t \ | \ t(u, l) \ \\
    l      &::= \ []\  | \ u :: l.
  \end{align*}
\end{definition}

\begin{definition}[Append]
  The append of two $\LamM$-lists, $l + l'$, is recursively defined as follows:
  \begin{align*}
  & [] + l' = l', \\
  & (u::l) + l' = u::(l + l').
  \end{align*}
\end{definition}

\begin{definition}[Substitution for $\LamM$-terms]
  The substitution over a $\LamM$-term is mutually defined with the substitution over a $\LamM$-list as follows:  
  \begin{align*}
  & x[x := v] = v ; \\
  & y[x := v] = y \text{, with } x \neq y ; \\
  & (\lambda y . t)[x := v] = \lambda y . (t[x := v]) ; \\
  & t(u, l)[x := v] = t[x := v](u[x := v], l[x := v]) ; \\    
  & ([])[x := v] = [] ; \\ 
  & (u::l)[x := v] = u[x := v] :: l[x := v] .
  \end{align*}
\end{definition}

\begin{definition}[Compatible Relation]
  \label{compatible_relation}
  Let $R$ and $R'$ be two binary relations on $\LamM$-terms and $\LamM$-lists respectively.
  We say they are compatible when they satisfy:
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (\lambda x . t, \lambda x . t') \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (t(u, l), t'(u, l)) \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (t(u, l), t(u', l)) \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (t(u, l), t(u, l')) \in R } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (u::l, u'::l) \in R' } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (u::l, u::l') \in R' } 
    \end{prooftree}
  \]
\end{definition}

\begin{definition}[Reduction rules for $\LamM$-terms]  
  \begin{align*}
    & (\lambda x . t)(u, []) \to_{\beta_1} t[x := u]
    \\
    & (\lambda x . t)(u, v::l) \to_{\beta_2} t[x := u](v, l)
    \\
    & t(u, l)(u', l') \to_{h} t(u, l + (u'::l'))
  \end{align*}
  By abuse of notation, we introduced the reduction rules with the notation of their compatible closure ($\to_R$).
\end{definition}

\begin{remark}
  As the compatible closure induces two relations, one on terms and the other on lists, we will use the notation $\to_R$ for both these relations as we can get out of the context which one is being referenced.
\end{remark}

\begin{notation}
  The relation $\beta$ will denote the relation $\beta_1 \cup \beta_2$.
  The same for the relation $\beta h$ that will denote the relation $\beta \cup h$.
  Therefore, we will have the induced relations $\to_\beta$ and $\to_{\beta h}$ (and analogous multistep relations $\twoheadrightarrow_\beta$ and $\twoheadrightarrow_{\beta h}$).
\end{notation}

% ---

\begin{definition}[$\beta h$-normal forms]
  We inductively define the sets of $\LamM$-terms and $\LamM$-lists in $\beta h$-normal form, respectively NF and NL, as follows:
  \[
    \begin{prooftree}
      \infer0{ x \in \text{NF} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ t \in \text{NF} }
      \infer1{ \lambda x . t \in \text{NF} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in \text{NF} } 
      \hypo{ l \in \text{NL} }
      \infer2{ x(u, l) \in \text{NF} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \infer0{ [] \in \text{NL} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in \text{NF} }
      \hypo{ l \in \text{NL} }
      \infer2{ u::l \in \text{NL} }
    \end{prooftree}
  \]
\end{definition}

% ---

\begin{definition}[Typing Rules for $\LamM$-terms]
  \[
    \begin{prooftree}
      \infer0[Var]{ x:A, \Gamma \vdash x:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ x:A, \Gamma \vdash t:B }
      \infer1[Abs]{ \Gamma \vdash \lambda x . t : A \supset B  } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ \Gamma \vdash t : A \supset B }
      \hypo{ \Gamma \vdash u : A }
      \hypo{ \Gamma ; B \vdash l : C }	
      \infer3[mApp]{ \Gamma \vdash t(u, l) : C } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \infer0[Nil]{ \Gamma ; A \vdash []:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash u:A }
      \hypo{ \Gamma ; B \vdash l:C }
      \infer2[Cons]{ \Gamma ; A \supset B \vdash  u::l : C } 
    \end{prooftree}
  \]
\end{definition}

% --- 
% 123
% ---
% \section{Subject reduction for $\LamM$}

\begin{lemma}[Substitution Admissibility]
  \label{type_substitution}
  The following rules are admissible:
  \[
    \begin{prooftree}
      \hypo{ \Gamma , x:B \vdash t:A }
      \hypo{ \Gamma \vdash u:B }
      \infer2{ \Gamma \vdash  t[x := u] : A }      
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma , x:B \ ; C \vdash l:A }
      \hypo{ \Gamma \vdash u:B }
      \infer2{ \Gamma ; C \vdash  l[x := u] : A }
    \end{prooftree}
  \]
\end{lemma}
\begin{proof}
  The proof proceeds by simultaneous induction on the structure of the typing rules.
\end{proof}


\begin{lemma}[Append Admissibility]
  \label{append_is_admissible}
  The following rules is admissible:
  \[
    \begin{prooftree}
      \hypo{ \Gamma ; C \vdash l:B }
      \hypo{ \Gamma ; B \vdash l':A }
      \infer2{ \Gamma ; C \vdash  l+l' : A }
    \end{prooftree}
  \]
\end{lemma}
\begin{proof}
  The proof proceeds by induction on the structure of $l$.
\end{proof}


\begin{theorem}[Subject Reduction]
  \label{type_preservation}
  Given $\LamM$-terms $t$ and $t'$, the follwing holds:
  \[
    \Gamma \vdash t : A \ \land \ t \to_{\beta h} t' \implies \Gamma \vdash t' : A.
  \]
\end{theorem}
\begin{proof}
  The proof proceeds by simultaneous induction on the structure of the relation $\to_{\beta h}$.

  \cref{type_substitution} is used to prove the case $t \to_\beta t'$.

  \cref{append_is_admissible} is used to prove the case $t \to_h t'$.
\end{proof}

% ---
% 123
% ---

\section{The canonical subsystem}

As we have identified the $\beta h$-normal forms, we can also identify the set of $h$-normal forms, given by the following definition.

\begin{definition}[Canonical terms]
  \label{canonical_terms}
  We inductively define the sets of $\LamM$-terms and $\LamM$-lists in $h$-normal form, respectively $Can$ and $CanList$, as follows:
  \[
    \begin{prooftree}
      \infer0{ x \in Can } 
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ t \in Can }
      \infer1{ \lambda x . t \in Can } 
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer2{ x(u, l) \in Can }
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ t \in Can } 
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer3{ (\lambda x. t)(u, l) \in Can }
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \infer0{ [] \in CanList } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer2{ u::l \in CanList }
    \end{prooftree}
  \]

  We also call canonical terms to the $\LamM$-terms in the set $Can$.
\end{definition}

Now, we will describe how this class of terms in $\LamM$ generates a subsystem.

First, we define the function $app : Can \times Can \times Can \to Can$ that will behave as a multiary application constructor closed for the canonical terms.

\begin{definition}
  Given $t, u \in Can$ and $l \in CanList$, the operation $app(t, u, l)$ is defined by the following equations:
  \begin{align*}
    & app(x, u, l) = x(u, l), \\
    & app(\lambda x. t, u, l) = (\lambda x. t)(u, l), \\ 
    & app(x(u', l'), u, l) = x(u', l' + (u::l)) \\
    & app((\lambda x. t)(u', l'), u, l) = (\lambda x. t)(u', l'+(u::l)).
  \end{align*}  
\end{definition}

\begin{lemma}
  \label{app_is_multistep}
  For every $\LamM$-terms $t, u$, and $\LamM$-list $l$, 
  \[ t(u, l) \twoheadrightarrow_h app(t, u, l). \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by inspection of term $t$.
  For the cases where $t$ is not an application, we have an equality.
\end{proof}

Then, we can define a function that collapses $\LamM$-terms to their $h$-normal form.

\begin{definition}
  Consider the following map $h$:
  \begin{align*}
    h : \LamM \text{-terms} &\to Can \\
    x &\mapsto x \\
    \lambda x . t &\mapsto \lambda x . h(t) \\
    t(u,l) &\mapsto app(h(t), h(u), h'(l)),
  \end{align*}
  where $h'$ is simply defined as
  $h'([]) \mapsto []$ and $h'(u::l) = h(u)::h'(l)$.
\end{definition}

\begin{theorem}
  \label{h_is_multistep}
  For every $\LamM$-term $t$,
  \[ t \twoheadrightarrow_h h(t), \]
  and also, for every $\LamM$-list $l$,
  \[ l \twoheadrightarrow_h h'(l). \]
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of term $t$ and list $l$.

  As $h$ is defined using $app$, \cref{app_is_multistep} is crucial for the case where $t$ is an application. 
\end{proof}

\begin{theorem}[$h$ surjectivity]
  \label{h_is_surjective}
  For every $t \in Can$,
  \[ t = h(t). \]
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of the canonical term $t$.
\end{proof}

For the purpose of defining a subsystem of $\LamM$, we induce a reduction relation for these canonical terms given a reduction relation on the $\LamM$-terms and -lists.

\begin{definition}[Canonical closure]
  \label{canonical_closure}
  Let $R$ and $R'$ be two binary relations on $\LamM$-terms and $\LamM$-lists respectively.
  We inductively define the canonical closure of each relation as follows:
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (h(t), h(t')) \in R_c } 
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (h(l), h(l')) \in R'_c } 
    \end{prooftree}
  \]
\end{definition}

This definition allows us to define a closed $\beta$ reduction for the canonical terms, derived from the relation $\to_\beta$ in $\LamM$. This would result in the canonical relation ${(\to_\beta)}_c$. 

In the same manner, we introduce the typing rules for canonical terms.

\begin{definition}[Canonical typing rules]
  \label{canonical_typing}
  We inductively define the canonical typing rules, defined over every $\LamM$-term $t$ and $\LamM$-list $l$:
  \[
    \begin{prooftree}
      \hypo{ \Gamma \vdash t:A }
      \infer1{ \Gamma \vdash_c h(t):A } 
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma ; A \vdash l:B }
      \infer1{ \Gamma ; A \vdash_c h(l):B }.
    \end{prooftree}
  \]
\end{definition}

We conclude our presentation of the canonical subsystem of $\LamM$.
This presentation does not exaclty coincide with \cite{JCES2002}.
We still want present a self-contained version of this subsystem, that we will call $\LamV$.
We then prove that out self-contained version of the canonical terms is isomorphic to the susbsytem now described.

% ---
% 123
% ---

\section{Mechanisation in \textit{Rocq}}

The mechanisations for the system $\LamM$ follow the same style as the ones shown for the simply typed $\Lam$-calculus in~\cref{c:background} using the \textit{Autosubst} library.

\subsection{\lst$LambdaM.v$}

This module that contains the necessary definitions for the formalisations dealing with the system $\LamM$.
The inductive type for the syntax of $\LamM$-terms is as follows.
\begin{lstlisting}[language=Coq]
Inductive term: Type :=
| Var (x: var)
| Lam (t: {bind term})
| mApp (t: term) (u: term) (l: list term).
\end{lstlisting}

The definition for $\LamM$-lists is hidden under the polymorphic list type \lst$list term$.
We give more details on this in the end of this section.

Mechanising the reduction relations we first defined the notion of compatibility as in~\cref{compatible_relation} and then the base step relations $\beta_1$, $\beta_2$ and $h$ separately.
That way we introduce the notions of compatible relation and also of compatible closure.
This aproach is more elaborated than the one presented for the simply typed $\Lam$-calculus and we also get into more details about these decisions in the end of this section.

\begin{lstlisting}[language=Coq]
Inductive beta1: relation term :=
| Step_Beta1 (t: {bind term}) (t' u: term) :
  t' = t.[u .: ids] -> beta1 (mApp (Lam t) u []) t'.

Inductive beta2: relation term :=
| Step_Beta2 (t: {bind term}) (t' u v: term) l :
  t' = t.[u .: ids] -> beta2 (mApp (Lam t) u (v::l)) (mApp t' v l).

Inductive H: relation term :=       
| Step_H (t u u': term) l l' l'' :
  l'' = l ++ (u'::l') -> H (mApp (mApp t u l) u' l') (mApp t u l'').

Definition step := comp (union _ (union _ beta1 beta2) H).
Definition step' := comp' (union _ (union _ beta1 beta2) H).

Definition multistep := clos_refl_trans_1n _ step.
Definition multistep' := clos_refl_trans_1n _ step'.
\end{lstlisting}

Here, the \lst$comp$ and \lst$comp'$ are the polymorphic relations on $\LamM$-terms and -lists respectively that induce the compatibility closure.
We also note the use of the \lst$clos_refl_trans_1n$ polymorphic relation provided by the \textit{Rocq Prover} libraries that induces the reflexive and transitive closure of a given binary relation.

In this module, we have also the mechanised typing rules for $\LamM$, much in the style of what was done for the simply typed $\Lam$-calculus.
\begin{lstlisting}[language=Coq]
Inductive sequent (Gamma: var->type) : term -> type -> Prop := 
| varAxiom (x: var) (A: type) :
  Gamma x = A -> sequent Gamma (Var x) A
| Right (t: term) (A B: type) :
  sequent (A .: Gamma) t B -> sequent Gamma (Lam t) (Arr A B)
| HeadCut (t u: term) (l: list term) (A B C: type) :
  sequent Gamma t (Arr A B) -> sequent Gamma u A -> list_sequent Gamma B l C ->
  sequent Gamma (mApp t u l) C
with list_sequent (Gamma:var->type) : type -> (list term) -> type -> Prop :=
| nilAxiom (C: type) : list_sequent Gamma C [] C
| Lft (u: term) (l: list term) (A B C:type) :
  sequent Gamma u A -> list_sequent Gamma B l C ->
  list_sequent Gamma (Arr A B) (u :: l) C.
\end{lstlisting}

\subsection{\lst$IsCanonical.v$}

This module contains the necessary definitions for the formalisations dealing with the canonical subsystem of $\LamM$.

First, we define a predicate \lst$is_canonical$ that constructively defines the canonical terms in the style of~\cref{canonical_terms}.
\begin{lstlisting}[language=Coq]
Inductive is_canonical: term -> Prop :=
| cVar (x: var) :
  is_canonical (Var x)
| cLam (t: {bind term}) :
  is_canonical t -> is_canonical (Lam t)
| cVarApp (x: var) (u: term) (l: list term) :
  is_canonical u -> is_canonical_list l ->
  is_canonical (mApp (Var x) u l)
| cLamApp (t: {bind term}) (u: term) (l: list term) :
  is_canonical t -> is_canonical u -> is_canonical_list l ->
  is_canonical (mApp (Lam t) u l)
with is_canonical_list: list term -> Prop :=
| cNil : is_canonical_list []
| cCons (u: term) (l: list term) :
  is_canonical u -> is_canonical_list l ->
  is_canonical_list (u::l).
\end{lstlisting}

The module then contains defintions for the $app$ operation (called \lst$capp$ because append of lists in \textit{Rocq} is already called \lst$app$) and map $h$.
\begin{lstlisting}[language=Coq]
Definition capp (v u: term) (l: list term) : term :=
  match v with
  | Var x        => mApp v u l
  | Lam t        => mApp v u l
  | mApp t u' l' => mApp t u' (l' ++ (u::l))
  end.

Fixpoint h (t: term) :=
  match t with
  | Var x      => Var x
  | Lam t      => Lam (h t)
  | mApp t u l => capp (h t) (h u) (map h l)
  end.
\end{lstlisting}
In the definition of map $h$ we don't define map $h'$, as we use the \lst$map$ function from the \lst$List$ library.
The function \lst$map h$ behaves exactly as the intended map $h'$.
Notice that this way we also avoid a mutually dependent definition.

In the \textit{Rocq Prover}, we need to formally prove that the $app$ operation and map $h$ are closed for canonical terms.
Of course that in description we have of the subsystem we easily argue this informally. For example, in the mechanised results, we have the following lemma.
\begin{lstlisting}[language=Coq]
Lemma capp_is_canonical t u l :
  is_canonical t -> is_canonical u -> is_canonical_list l ->
  is_canonical (capp t u l).
\end{lstlisting}

Then, we prove every lemma and theorem presented in the description of the canonical subsystem.
As an example, we show the mechanisation of~\cref{h_is_surjective}.
\begin{lstlisting}[language=Coq]
Theorem h_is_surjective :
  (forall t, is_canonical t -> t = h t)
  /\
  (forall l, is_canonical_list l -> l = map h l).
Proof.
  apply mut_is_canonical_ind ;
    intros ; asimpl ; repeat f_equal ; auto.
Qed.
\end{lstlisting}
In this proof we use the \lst$auto$ tactic to facilitate our work.
For routine proofs, we often found success when using these automated tactics.

The module ends with definitions for the reduction relation (recall~\cref{canonical_closure}) and typing rules (recall~\cref{canonical_typing}) for the canonical subsystem.
\begin{lstlisting}[language=Coq]
Inductive canonical_relation
  (R: relation term) : relation term :=
| Step_CanTerm t t' : R t t' -> canonical_relation R (h t) (h t').
Inductive canonical_list_relation
  (R: relation (list term)) : relation (list term) :=
| Step_CanList l l' : R l l' -> canonical_list_relation R (map h l) (map h l').

Definition step_can := canonical_relation step_beta.
Definition step_can' := canonical_list_relation step_beta'.
...
Inductive canonical_sequent (Gamma: var->type) :
  term -> type -> Prop :=
| Seq_CanTerm t A : sequent Gamma t A -> canonical_sequent Gamma (h t) A.
Inductive canonical_list_sequent (Gamma: var->type) :
  type -> list term -> type -> Prop :=
| Seq_CanList l A B : list_sequent Gamma A l B ->
                      canonical_list_sequent Gamma A (map h l) B.
\end{lstlisting}

\subsection{A closer look at the mechanisation}

In this part we take a closer look at some particular aspects of the mechanisation that deserve more attention.
The purpose is to show how some other options could arise and justify unusual approaches.

\subsubsection{Mutually inductive types vs nested inductive types}

Creating a mutually inductive type for the syntax of $\LamM$ in \textit{Rocq} would be a simple task:
\begin{lstlisting}[language=Coq]
  Inductive term: Type :=
  | Var (x: var)
  | Lam (t: {bind term})
  | mApp (t: term) (u: term) (l: list)
  with list: Type :=
  | Nil
  | Cons (u: term) (l: list). 
\end{lstlisting}

However, as reported in the final section of~\cite{AutosubstSchafer}, \textit{Autosubst} offers no support for mutually inductive definitions.
The \lst$derive$ tactic would not generate the desired instances for the \lst$Rename$ and \lst$Subst$ classes, failing to iterate through the customized list type.

As we tried to keep the decision of using \textit{Autosubst}, there were two possible directions:
\begin{enumerate}
\item manually define every instance required and prove substitution lemmas;
\item remove the mutual dependency in the term definition.
\end{enumerate}

The first formalisation attempts followed the first option.
This meant that everything \textit{Autosubst} could provide automatically was done by hand.
For this, we closely followed the definitions given in \cite{AutosubstSchafer}.

% At some point, the idea of using the polymorphic list type provided by the \textit{Rocq} standard library came up.
% Inspecting the \textit{Autosubst} code repository, one can find that there is some support for these kinds of mutually inductive definitions.

After some closer inspection of the library source code, we found that there was native support for the use of types depending on polymorphic lists.
This way, there was no need of having a mutual inductive type for our terms.
% After some further inspection of the library source code, we noticed that nested inductive types that depend on lists are already supported by default.

% This is obtained by an auxiliary function, $mmap$, that iterates through lists of terms.
% \dots falar da funcao mmap? \dots

The downside of using nested inductive types in the \textit{Rocq Prover} is the generated induction principles.
This issue is already well documented in \cite[Chapter~14.3]{CoqArt}.
With this approach, we need to provide the dedicated induction principles to the proof assistant.

\begin{lstlisting}[language=Coq]
Section dedicated_induction_principle.
  Variable P : term -> Prop.
  Variable Q : list term -> Prop.
  Hypothesis HVar : forall x, P (Var x).
  Hypothesis HLam : forall t: {bind term}, P t -> P (Lam t).
  Hypothesis HmApp : forall t u l, P t -> P u -> Q l -> P (mApp t u l).
  Hypothesis HNil : Q [].
  Hypothesis HCons : forall u l, P u -> Q l -> Q (u::l).
  
  Proposition sim_term_ind : forall t, P t.
  Proof.
    fix rec 1. destruct t.
    - now apply HVar.
    - apply HLam. now apply rec.
    - apply HmApp.
      + now apply rec.
      + now apply rec.
      + assert (forall l, Q l). {
            fix rec' 1. destruct l0.
            - apply HNil.
            - apply HCons.
              + now apply rec.
              + now apply rec'. }          
        now apply H.
  Qed.      
  
  Proposition sim_list_ind : forall l, Q l.
  Proof.
    fix rec 1. destruct l.
    - now apply HNil.
    - apply HCons.
      + now apply sim_term_ind.
      + now apply rec.
  Qed.          
End dedicated_induction_principle.
\end{lstlisting}

\subsubsection{Formalising a subsystem}

% \begin{itemize}
% \item Carrgying a predicate
% \item Subset types in Coq
% \item A self contained representation
% \end{itemize}

A relevant part of the mechanisations done was to find simple representations for subsystems in the proof assitant.

As we pointed out, the formalisation we have done for the canonical subsystem of $\LamM$ is non standard.
These ideas were motivated by the task of mechanising such subsystem.

Formalising the subset of terms using a predicate is the obvious way to do it.
But we would also like to have a dedicated type for the extension of that predicate rather than just the predicate itself.
The \textit{Rocq Prover} provides such types, known as subset types (we refer to~\cite[Chapter~9.1]{CoqArt}).
Although these subset types are exactly what we wanted, they do not give us a great advantage on mechanisations.
Using subset types rapidly becomes exhausting because of the need to always provide proofs for every definition.

As an example, trying to define the substitution operation as in~\cite[Chapter~3.1]{JCES2002} for the canonical terms mechanised using subset types, we would get:
\begin{lstlisting}[language=Coq]
  (i hope i have this somewhere)
\end{lstlisting}

Our aproach for the formalisation of such subsystem was to think of the canonical subsystem using the map $h$ that $h$-normalises $\LamM$-terms (defining reduction and typification using map $h$).
After that, we could define a self-contained canonical system with its own syntax and definitions (in the spirit of~\cite[Chapter~3.1]{JCES2002}) and prove both representations are isomorphic.
That is the goal for the next chapter.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
