\chapter{Multiary $\Lam$-calculus and its canonical subsystem}
\label{c:multiary}

\section{The system $\LamM$}

\begin{definition}[$\LamM$-terms]
  The $\LamM$-terms are defined by the following grammar:  
  \begin{align*} 
    t, u \ &::= \ x \ | \ \lambda x . t \ | \ t(u, l) \ \\
    l      &::= \ []\  | \ u :: l.
  \end{align*}
\end{definition}

\begin{definition}[Append]
  The append of two $\LamM$-lists, $l + l'$, is recursively defined as follows:
  \begin{align*}
  & [] + l' = l', \\
  & (u::l) + l' = u::(l + l').
  \end{align*}
\end{definition}

\begin{definition}[Substitution for $\LamM$-terms]
  The substitution over a $\LamM$-term is mutually defined with the substitution over a $\LamM$-list as follows:  
  \begin{align*}
  & x[x := v] = v ; \\
  & y[x := v] = y \text{, with } x \neq y ; \\
  & (\lambda y . t)[x := v] = \lambda y . (t[x := v]) ; \\
  & t(u, l)[x := v] = t[x := v](u[x := v], l[x := v]) ; \\    
  & ([])[x := v] = [] ; \\ 
  & (u::l)[x := v] = u[x := v] :: l[x := v] .
  \end{align*}
\end{definition}

\begin{definition}[Compatible Relation]
  Let $R$ and $R'$ be two binary relations on $\LamM$-terms and $\LamM$-lists respectively.
  We say they are compatible when they satisfy:
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (\lambda x . t, \lambda x . t') \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (t(u, l), t'(u, l)) \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (t(u, l), t(u', l)) \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (t(u, l), t(u, l')) \in R } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (u::l, u'::l) \in R' } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (u::l, u::l') \in R' } 
    \end{prooftree}
  \]
\end{definition}

\begin{definition}[Reduction rules for $\LamM$-terms]  
  \begin{align*}
    & (\lambda x . t)(u, []) \to_{\beta_1} t[x := u]
    \\
    & (\lambda x . t)(u, v::l) \to_{\beta_2} t[x := u](v, l)
    \\
    & t(u, l)(u', l') \to_{h} t(u, l + (u'::l'))
  \end{align*}
  By abuse of notation, we introduced the reduction rules with the notation of their compatible closure ($\to_R$).
\end{definition}

\begin{remark}
  As the compatible closure induces two relations, one on terms and the other on lists, we will use the notation $\to_R$ for both these relations as we can get out of the context which one is being referenced.
\end{remark}

\begin{notation}
  The relation $\beta$ will denote the relation $\beta_1 \cup \beta_2$.
  The same for the relation $\beta h$ that will denote the relation $\beta \cup h$.
  Therefore, we will have the induced relations $\to_\beta$ and $\to_{\beta h}$ (and analogous multistep relations $\twoheadrightarrow_\beta$ and $\twoheadrightarrow_{\beta h}$).
\end{notation}

% ---

\begin{definition}[$\beta h$-normal forms]
  We inductively define the sets of $\LamM$-terms and $\LamM$-lists in $\beta h$-normal form, respectively NF and NL, as follows:
  \[
    \begin{prooftree}
      \infer0{ x \in \text{NF} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ t \in \text{NF} }
      \infer1{ \lambda x . t \in \text{NF} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in \text{NF} } 
      \hypo{ l \in \text{NL} }
      \infer2{ x(u, l) \in \text{NF} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \infer0{ [] \in \text{NL} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in \text{NF} }
      \hypo{ l \in \text{NL} }
      \infer2{ u::l \in \text{NL} }
    \end{prooftree}
  \]
\end{definition}

% ---

\begin{definition}[Typing Rules for $\LamM$-terms]
  \[
    \begin{prooftree}
      \infer0[Var]{ x:A, \Gamma \vdash x:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ x:A, \Gamma \vdash t:B }
      \infer1[Abs]{ \Gamma \vdash \lambda x . t : A \supset B  } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ \Gamma \vdash t : A \supset B }
      \hypo{ \Gamma \vdash u : A }
      \hypo{ \Gamma ; B \vdash l : C }	
      \infer3[mApp]{ \Gamma \vdash t(u, l) : C } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \infer0[Nil]{ \Gamma ; A \vdash []:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash u:A }
      \hypo{ \Gamma ; B \vdash l:C }
      \infer2[Cons]{ \Gamma ; A \supset B \vdash  u::l : C } 
    \end{prooftree}
  \]
\end{definition}

% ---
% 123
% ---

\section{The canonical subsystem}

As we have identified the $\beta h$-normal forms, we can also identify the set of $h$-normal forms, given by the following definition.

\begin{definition}[$h$-normal forms]
  We inductively define the sets of $\LamM$-terms and $\LamM$-lists in $h$-normal form, respectively $Can$ and $CanList$, as follows:
  \[
    \begin{prooftree}
      \infer0{ x \in Can } 
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ t \in Can }
      \infer1{ \lambda x . t \in Can } 
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer2{ x(u, l) \in Can }
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ t \in Can } 
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer3{ (\lambda x. t)(u, l) \in Can }
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \infer0{ [] \in CanList } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer2{ u::l \in CanList }
    \end{prooftree}
  \]

  We also call canonical terms to the $\LamM$-terms in the set $Can$.
\end{definition}

Now, we will describe how this class of terms in $\LamM$ generates a subsystem.

First, we define the function $app : Can \times Can \times Can \to Can$ that will behave as a multiary application constructor closed for the canonical terms.

\begin{definition}
  Given $t, u \in Can$ and $l \in CanList$, the operation $app(t, u, l)$ is defined by the following equations:
  \begin{align*}
    & app(x, u, l) = x(u, l), \\
    & app(\lambda x. t, u, l) = (\lambda x. t)(u, l), \\ 
    & app(x(u', l'), u, l) = x(u', l' + (u::l)) \\
    & app((\lambda x. t)(u', l'), u, l) = (\lambda x. t)(u', l'+(u::l)).
  \end{align*}  
\end{definition}

\begin{lemma}
  \label{app_is_multistep}
  For every $\LamM$-terms $t, u$, and $\LamM$-list $l$, 
  \[ t(u, l) \twoheadrightarrow_h app(t, u, l). \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by inspection of term $t$.
  For the cases where $t$ is not an application, we have an equality.
\end{proof}

Then, we can define a function that collapses $\LamM$-terms to their $h$-normal form.

\begin{definition}
  Consider the following map $h$:
  \begin{align*}
    h : \LamM \text{-terms} &\to Can \\
    x &\mapsto x \\
    \lambda x . t &\mapsto \lambda x . h(t) \\
    t(u,l) &\mapsto app(h(t), h(u), h'(l)),
  \end{align*}
  where $h'$ is simply defined as
  $h'([]) \mapsto []$ and $h'(u::l) = h(u)::h'(l)$.
\end{definition}

\begin{theorem}
  \label{h_is_multistep}
  For every $\LamM$-term $t$,
  \[ t \twoheadrightarrow_h h(t), \]
  and also, for every $\LamM$-list $l$,
  \[ l \twoheadrightarrow_h h'(l). \]
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of term $t$ and list $l$.

  As $h$ is defined using $app$, \cref{app_is_multistep} is crucial for the case where $t$ is an application. 
\end{proof}

\begin{theorem}[$h$ surjectivity]
  \label{h_is_surjective}
  For every $t \in Can$,
  \[ t = h(t). \]
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of the canonical term $t$.
\end{proof}

For the purpose of defining a subsystem of $\LamM$, we induce a reduction relation for these canonical terms given a reduction relation on the $\LamM$-terms and -lists.

\begin{definition}[Canonical Closure]
  Let $R$ and $R'$ be two binary relations on $\LamM$-terms and $\LamM$-lists respectively.
  We inductively define the canonical closure of each relation as follows:
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (h(t), h(t')) \in R_c } 
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (h(l), h(l')) \in R'_c } 
    \end{prooftree}
  \]
\end{definition}

In the same manner, we introduce the typing judgements for canonical terms.

\begin{definition}[Canonical Typing System]
  \label{canonical_typing}
  We inductively define the canonical type-assignement, defined over every $\LamM$-term $t$ and $\LamM$-list $l$:
  \[
    \begin{prooftree}
      \hypo{ \Gamma \vdash t:A }
      \infer1{ \Gamma \vdash_c h(t):A } 
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma ; A \vdash l:B }
      \infer1{ \Gamma ; A \vdash_c h(l):B }.
    \end{prooftree}
  \]
\end{definition}

We conclude our presentation of the canonical subsystem of $\LamM$.
This presentation does not exaclty coincide with \cite{JCES2002}.
We still want present a self-contained version of this subsystem, that we will call $\LamV$.
We then prove that out self-contained version of the canonical terms is isomorphic to the susbsytem now described.

% ---
% 123
% ---

\section{Subject reduction for $\LamM$}

\begin{lemma}[Substitution Admissibility]
  \label{type_substitution}
  The following rules are admissible:
  \[
    \begin{prooftree}
      \hypo{ \Gamma , x:B \vdash t:A }
      \hypo{ \Gamma \vdash u:B }
      \infer2{ \Gamma \vdash  t[x := u] : A }      
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma , x:B \ ; C \vdash l:A }
      \hypo{ \Gamma \vdash u:B }
      \infer2{ \Gamma ; C \vdash  l[x := u] : A }
    \end{prooftree}
  \]
\end{lemma}
\begin{proof}
  The proof proceeds by simultaneous induction on the structure of the typing rules.
\end{proof}


\begin{lemma}[Append Admissibility]
  \label{append_is_admissible}
  The following rules is admissible:
  \[
    \begin{prooftree}
      \hypo{ \Gamma ; C \vdash l:B }
      \hypo{ \Gamma ; B \vdash l':A }
      \infer2{ \Gamma ; C \vdash  l+l' : A }
    \end{prooftree}
  \]
\end{lemma}
\begin{proof}
  The proof proceeds by induction on the structure of $l$.
\end{proof}


\begin{theorem}[Subject Reduction]
  \label{type_preservation}
  Given $\LamM$-terms $t$ and $t'$, the follwing holds:
  \[
    \Gamma \vdash t : A \ \land \ t \to_{\beta h} t' \implies \Gamma \vdash t' : A.
  \]
\end{theorem}
\begin{proof}
  The proof proceeds by simultaneous induction on the structure of the relation $\to_{\beta h}$.

  $(i)$ We easily prove the case $t \to_\beta t'$ using substitution admissability in~\cref{type_substitution}.

  $(ii)$ We easily prove the case $t \to_h t'$ using append admissability in~\cref{append_admissibility}.
\end{proof}

% --- 
% 123
% ---

\section{Mechanisation in \textit{Rocq}}

\dots

\begin{lstlisting}[language=Coq]
(* syntax *)
Inductive term: Type :=
| Var (x: var)
| Lam (t: {bind term})
| mApp (t: term) (u: term) (l: list term).
...
(* reduction relations *)
Inductive beta1: relation term :=
| Step_Beta1 (t: {bind term}) (t' u: term) :
  t' = t.[u .: ids] -> beta1 (mApp (Lam t) u []) t'.

Inductive beta2: relation term :=
| Step_Beta2 (t: {bind term}) (t' u v: term) l :
  t' = t.[u .: ids] -> beta2 (mApp (Lam t) u (v::l)) (mApp t' v l).

Inductive H: relation term :=       
| Step_H (t u u': term) l l' l'' :
  l'' = l ++ (u'::l') -> H (mApp (mApp t u l) u' l') (mApp t u l'').

Definition step := comp (union _ (union _ beta1 beta2) H).
Definition step' := comp' (union _ (union _ beta1 beta2) H).

Definition multistep := clos_refl_trans_1n _ step.
Definition multistep' := clos_refl_trans_1n _ step'.
...
(* typing rules *)
Inductive sequent (Gamma: var->type) : term -> type -> Prop := 
| varAxiom (x: var) (A: type) :
  Gamma x = A -> sequent Gamma (Var x) A
| Right (t: term) (A B: type) :
  sequent (A .: Gamma) t B -> sequent Gamma (Lam t) (Arr A B)
| HeadCut (t u: term) (l: list term) (A B C: type) :
  sequent Gamma t (Arr A B) -> sequent Gamma u A -> list_sequent Gamma B l C ->
  sequent Gamma (mApp t u l) C

with list_sequent (Gamma:var->type) : type -> (list term) -> type -> Prop :=
| nilAxiom (C: type) : list_sequent Gamma C [] C
| Lft (u: term) (l: list term) (A B C:type) :
  sequent Gamma u A -> list_sequent Gamma B l C ->
  list_sequent Gamma (Arr A B) (u :: l) C.
\end{lstlisting}

\section{A closer look at the mechanisation}

In this section, we discuss several differences between the formalisations on the proof assistant and those presented on the literature.
As we have already discussed binding and de Bruijn notation, we are not taking this into account from now on.

\subsection{Mutually inductive types vs Nested inductive types}

% \begin{itemize}
% \item AUTOSUBST excavation for support
% \item induction principle and further proofs
% \item generalization or specification?
% \end{itemize}

Creating a mutually inductive definition for $\LamM$ in \textit{Rocq} is a simple task:

\begin{lstlisting}[language=Coq]
  Inductive term: Type :=
  | Var (x: var)
  | Lam (t: {bind term})
  | mApp (t: term) (u: term) (l: list)
  with list: Type :=
  | Nil
  | Cons (u: term) (l: list). 
\end{lstlisting}

However, as reported in the final section of \cite{AutosubstSchafer}, \textsc{Autosubst} offers no support for mutually inductive definitions.
The \lst$derive$ tactic would not generate the desired instances for the \lst$Rename$ and \lst$Subst$ classes, failing to iterate through the custom list type.

As we tried to keep the decision of using \textsc{Autosubst}, there were two possible directions:

\begin{enumerate}
\item Manually define every instance required and prove substitution lemmas;
\item Remove the mutual dependency in the term definition.
\end{enumerate}

The first formalisation attempts followed the first option.
This meant that everything \textit{Autosubst} could provide automatically was done by hand.
For this, we closely followed the definitions given in \cite{AutosubstSchafer}.

% At some point, the idea of using the polymorphic list type provided by the \textit{Rocq} standard library came up.
% Inspecting the \textit{Autosubst} code repository, one can find that there is some support for these kinds of mutually inductive definitions.

After some closer inspection of the library source code, we found that there was native support for the use of types depending on polymorphic lists.
This way, there was no need of having a mutual inductive type for our terms.
% After some further inspection of the library source code, we noticed that nested inductive types that depend on lists are already supported by default.

% This is obtained by an auxiliary function, $mmap$, that iterates through lists of terms.
% \dots falar da funcao mmap? \dots

The downside of using nested inductive types in the \textit{Rocq Prover} is the generated induction principles.
This issue is already well documented in \cite{CoqArt}.
With this approach, we need to provide the dedicated induction principles to the proof assistant.

\begin{lstlisting}[language=Coq]
Section dedicated_induction_principle.
  Variable P : term -> Prop.
  Variable Q : list term -> Prop.
  Hypothesis HVar : forall x, P (Var x).
  Hypothesis HLam : forall t: {bind term}, P t -> P (Lam t).
  Hypothesis HmApp : forall t u l, P t -> P u -> Q l -> P (mApp t u l).
  Hypothesis HNil : Q [].
  Hypothesis HCons : forall u l, P u -> Q l -> Q (u::l).
  
  Proposition sim_term_ind : forall t, P t.
  Proof.
    fix rec 1. destruct t.
    - now apply HVar.
    - apply HLam. now apply rec.
    - apply HmApp.
      + now apply rec.
      + now apply rec.
      + assert (forall l, Q l). {
            fix rec' 1. destruct l0.
            - apply HNil.
            - apply HCons.
              + now apply rec.
              + now apply rec'. }          
        now apply H.
  Qed.      
  
  Proposition sim_list_ind : forall l, Q l.
  Proof.
    fix rec 1. destruct l.
    - now apply HNil.
    - apply HCons.
      + now apply sim_term_ind.
      + now apply rec.
  Qed.          
End dedicated_induction_principle.
\end{lstlisting}

\dots

\subsection{Formalising a subsystem}

% \begin{itemize}
% \item Carrgying a predicate
% \item Subset types in Coq
% \item A self contained representation
% \end{itemize}

A relevant part of the mechanisation, was to represent subsystems in the proof assistant in a simple way.
We isolate a subsyntax of $\LamM$ by defining a predicate over its terms:

\begin{lstlisting}[language=Coq]
Inductive is_canonical: term -> Prop :=
| cVar (x: var) : is_canonical (Var x)
| cLam (t: {bind term}) : is_canonical t -> is_canonical (Lam t)                                                      
| cVarApp (x: var) (u: term) (l: list term) :
  is_canonical u -> is_canonical_list l -> is_canonical (mApp (Var x) u l)
| cLamApp (t: {bind term}) (u: term) (l: list term) :
  is_canonical t -> is_canonical u -> is_canonical_list l ->
  is_canonical (mApp (Lam t) u l)
  
with is_canonical_list: list term -> Prop :=
| cNil : is_canonical_list []
| cCons (u: term) (l: list term) :
  is_canonical u -> is_canonical_list l -> is_canonical_list (u::l).
\end{lstlisting}

This is the same idea that we introduced when inductively defining the sets of $\LamM$-terms $Can$ and of $\LamM$-lists $CanList$.

\subsubsection{Digression over subset types}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
