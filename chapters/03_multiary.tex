\chapter{Multiary $\Lam$-calculus and its canonical subsystem}
\label{c:multiary}

This chapter introduces the main system that was studied in this dissertation: the multiary $\Lam$-calculus ($\LamM$).
We introduce this system as the system $\pmb{\lambda \mathcal{P}h}$ studied in~\cite[Chapter~3]{JCES2002}.
This system can also be found as $\pmb{\lambda^m}$ in~\cite[Section~3]{JCESLuis}, as a subsystem of $\pmb{\lambda J^m}$.

We provide an alternative description for a subsystem of $h$-normal forms of $\LamM$ (corresponding to the system $\pmb{\lambda \mathcal{P}}$ found in~\cite[Chapter~3]{JCES2002}).
At the end of this chapter one can find a detailed overview of the mechanisation done in this dissertation of the multiary $\Lam$-calculus and subsystems.

\section{The system $\LamM$}

First, we introduce some standard definitions for our system, like the grammar for $\LamM$-terms, a typical append operation on lists and substitution operation.

\begin{definition}[$\LamM$-terms]
  The $\LamM$-terms are simultaneously defined with $\LamM$-lists by the following grammar:  
  \begin{align*} 
    (\LamM \text{-terms}) && t, u, v &::= \ x \ | \ \lambda x . t \ | \ t(u, l) \ \\
    (\LamM \text{-lists}) && l       &::= \ []\  | \ u :: l.
  \end{align*}
\end{definition}

\begin{definition}[Append]
  The append of two $\LamM$-lists, $l + l'$, is defined recursively on $l$ as follows:
  \begin{align*}
    [] + l'     &= l', \\
    (u::l) + l' &= u::(l + l').
  \end{align*}
\end{definition}

\begin{definition}[Substitution for $\LamM$-terms]
  The substitution of a variable $x$ by a $\LamM$-term $v$ is mutually defined by recursion with the substitution over a $\LamM$-list as follows:  
  \begin{align*}
  & x[x := v] = v ; \\
  & y[x := v] = y \text{, with } x \neq y ; \\
  & (\lambda y . t)[x := v] = \lambda y . (t[x := v]) ; \\
  & t(u, l)[x := v] = t[x := v](u[x := v], l[x := v]) ; \\    
  & [][x := v] = [] ; \\
  & (u::l)[x := v] = u[x := v] :: l[x := v] .
  \end{align*}
\end{definition}

\begin{definition}[Compatible Relation]
  \label{compatible_relation}
  Let $R$ and $R'$ be two binary relations on $\LamM$-terms and $\LamM$-lists respectively.
  We say they are compatible when they satisfy:
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (\lambda x . t, \lambda x . t') \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (t(u, l), t'(u, l)) \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (t(u, l), t(u', l)) \in R } 
    \end{prooftree}
    \quad \ \
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (t(u, l), t(u, l')) \in R } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ (u, u') \in R }
      \infer1{ (u::l, u'::l) \in R' } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (u::l, u::l') \in R' } 
    \end{prooftree}
  \]
\end{definition}

\begin{definition}[Reduction rules for $\LamM$-terms]  
  \begin{align*}
    & (\lambda x . t)(u, []) \to_{\beta_1} t[x := u]
    \\
    & (\lambda x . t)(u, v::l) \to_{\beta_2} t[x := u](v, l)
    \\
    & t(u, l)(u', l') \to_{h} t(u, l + (u'::l'))
  \end{align*}
  By abuse of notation, we introduced the reduction rules with the notation of their compatible closure ($\to_R$).
\end{definition}

\begin{remark}
  As the compatible closure induces two relations, one on terms and the other on lists, we will use the notation $\to_R$ for both these relations as we can get out of the context which one is being referenced.
\end{remark}

\begin{notation}
  The relation $\beta$ will denote the relation $\beta_1 \cup \beta_2$.
  The same for the relation $\beta h$ that will denote the relation $\beta \cup h$.
  Therefore, we will have the induced relations $\to_\beta$ and $\to_{\beta h}$ (and analogous multistep relations $\twoheadrightarrow_\beta$ and $\twoheadrightarrow_{\beta h}$).
\end{notation}

% ---

\begin{comment}
\begin{definition}[$\beta h$-normal forms]
  We inductively define the sets of $\LamM$-terms and $\LamM$-lists in $\beta h$-normal form, respectively NF and NL, as follows:
  \[
    \begin{prooftree}
      \infer0{ x \in \text{NF} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ t \in \text{NF} }
      \infer1{ \lambda x . t \in \text{NF} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in \text{NF} } 
      \hypo{ l \in \text{NL} }
      \infer2{ x(u, l) \in \text{NF} }
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \infer0{ [] \in \text{NL} } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in \text{NF} }
      \hypo{ l \in \text{NL} }
      \infer2{ u::l \in \text{NL} }
    \end{prooftree}
  \]
\end{definition}
\end{comment}

% ---

The typing system of system $\LamM$ provides rules to derive two different kinds of sequents.

\begin{definition}[Sequent]
  A sequent on terms~$\Gamma \vdash t:A$ is a triple of a context, a $\LamM$-term and a simple type.
  A sequent on lists~$\Gamma;A \vdash l:B$ is a quadruple of a context, a simple type, a $\LamM$-list and another simple type.
\end{definition}


\begin{definition}[Typing Rules for $\LamM$-terms]
  \[
    \begin{prooftree}
      \infer0[Var]{ x:A, \Gamma \vdash x:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ x:A, \Gamma \vdash t:B }
      \infer1[Abs]{ \Gamma \vdash \lambda x . t : A \supset B  } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{ \Gamma \vdash t : A \supset B }
      \hypo{ \Gamma \vdash u : A }
      \hypo{ \Gamma ; B \vdash l : C }	
      \infer3[mApp]{ \Gamma \vdash t(u, l) : C } 
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \infer0[Nil]{ \Gamma ; A \vdash []:A } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ \Gamma \vdash u:A }
      \hypo{ \Gamma ; B \vdash l:C }
      \infer2[Cons]{ \Gamma ; A \supset B \vdash  u::l : C } 
    \end{prooftree}
  \]
\end{definition}

% --- 
% 123
% ---
% \section{Subject reduction for $\LamM$}

Now we present classical results about the system $\LamM$, which culminate in the theorem of subject reduction.

\begin{lemma}%[Substitution Admissibility]
  \label{type_substitution}
  The following rules are admissible:
  \[
    \begin{prooftree}
      \hypo{ \Gamma , x:B \vdash t:A }
      \hypo{ \Gamma \vdash u:B }
      \infer2{ \Gamma \vdash  t[x := u] : A }      
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma , x:B \ ; C \vdash l:A }
      \hypo{ \Gamma \vdash u:B }
      \infer2{ \Gamma ; C \vdash  l[x := u] : A }
    \end{prooftree}.
  \]
\end{lemma}
\begin{proof}
  The proof proceeds by simultaneous induction on the structure of the typing rules.
\end{proof}

\begin{lemma}%[Append Admissibility]
  \label{append_is_admissible}
  The following rule is admissible:
  \[
    \begin{prooftree}
      \hypo{ \Gamma ; C \vdash l:B }
      \hypo{ \Gamma ; B \vdash l':A }
      \infer2{ \Gamma ; C \vdash  l+l' : A }
    \end{prooftree}.
  \]
\end{lemma}
\begin{proof}
  The proof proceeds by induction on the structure of $l$.
\end{proof}


\begin{theorem}[Subject Reduction]
  \label{type_preservation}
  Given $\LamM$-terms $t$ and $t'$, the follwing holds:
  \[
    \Gamma \vdash t : A \ \land \ t \to_{\beta h} t' \implies \Gamma \vdash t' : A.
  \]
\end{theorem}
\begin{proof}
  The proof proceeds by simultaneous induction on the structure of the relation $\to_{\beta h}$.

  \cref{type_substitution} is used to prove the case $t \to_\beta t'$.

  \cref{append_is_admissible} is used to prove the case $t \to_h t'$.
\end{proof}

% ---
% 123
% ---

\section{The canonical subsystem}

We identify the set of $\LamM$-terms in $h$-normal form through the following inductive definition.

\begin{definition}[Canonical terms]
  \label{canonical_terms}
  We inductively define the sets of $\LamM$-terms and $\LamM$-lists in $h$-normal form, respectively $Can$ and $CanList$, as follows:
  \[
    \begin{prooftree}
      \infer0{ x \in Can } 
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ t \in Can }
      \infer1{ \lambda x . t \in Can } 
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer2{ x(u, l) \in Can }
    \end{prooftree}
    \quad
    \begin{prooftree}
      \hypo{ t \in Can } 
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer3{ (\lambda x. t)(u, l) \in Can }
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \infer0{ [] \in CanList } 
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{ u \in Can }            
      \hypo{ l \in CanList }
      \infer2{ u::l \in CanList }
    \end{prooftree}
  \]

  $\LamM$-terms $t \in Can$ are also called canonical terms.
\end{definition}

Now, we will describe how this subset of terms in $\LamM$ generates a subsystem.

First, we define the function $app : Can \times Can \times Can \to Can$ that will behave as a multiary application constructor closed for the canonical terms.

\begin{definition}
  Given $t, u \in Can$ and $l \in CanList$, the operation $app(t, u, l)$ is defined by the following equations:
  \begin{align*}
    & app(x, u, l) = x(u, l), \\
    & app(\lambda x. t, u, l) = (\lambda x. t)(u, l), \\ 
    & app(x(u', l'), u, l) = x(u', l' + (u::l)) \\
    & app((\lambda x. t)(u', l'), u, l) = (\lambda x. t)(u', l'+(u::l)).
  \end{align*}  
\end{definition}

\begin{lemma}
  \label{app_is_multistep}
  Given $t, u \in Can$ and $l \in CanList$, 
  \[ t(u, l) \twoheadrightarrow_h app(t, u, l) \qquad \text{(in $\LamM$)}. \]
\end{lemma}
\begin{proof}
  The proof proceeds easily by inspection of term $t$.

  For the cases where $t$ is not an application, we have an equality.
\end{proof}

Then, we can define a function that collapses $\LamM$-terms to their $h$-normal form.

\begin{definition}
  Consider the following map $h$:
  \begin{align*}
    h : \LamM \text{-terms} &\to Can \\
    x &\mapsto x \\
    \lambda x . t &\mapsto \lambda x . h(t) \\
    t(u,l) &\mapsto app(h(t), h(u), h'(l)),
  \end{align*}
  where $h'$ is simply defined as
  $h'([]) \mapsto []$ and $h'(u::l) = h(u)::h'(l)$.
\end{definition}

\begin{theorem}
  \label{h_is_multistep}
  For every $\LamM$-term $t$,
  \[ t \twoheadrightarrow_h h(t), \]
  and also, for every $\LamM$-list $l$,
  \[ l \twoheadrightarrow_h h'(l). \]
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of term $t$ and list $l$.

  As $h$ is defined using $app$, \cref{app_is_multistep} is crucial for the case where $t$ is an application. 
\end{proof}

The following theorem states that the canonical terms are fixpoints for map $h$.
Another way to look at this result is by saying that $h$ is surjective.

\begin{theorem}[$h$ fixpoints]
  \label{h_fixpoints}
  For every $t \in Can$, \[ h(t) = t. \]
\end{theorem}
\begin{proof}
  The proof proceeds easily by simultaneous induction on the structure of the canonical term $t$.
\end{proof}

For the purpose of defining a subsystem of $\LamM$, we induce a reduction relation for these canonical terms given a reduction relation on the $\LamM$-terms and -lists.

\begin{definition}%[Canonical relation closure]
  \label{canonical_closure}
  Let $R$ and $R'$ be two binary relations on $\LamM$-terms and $\LamM$-lists respectively.
  We inductively define the relations $R_c$ and $R'_c$ as follows:
  \[
    \begin{prooftree}
      \hypo{ (t, t') \in R }
      \infer1{ (h(t), h(t')) \in R_c } 
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ (l, l') \in R' }
      \infer1{ (h'(l), h'(l')) \in R'_c } 
    \end{prooftree}.
  \]

  We call canonical relation closure to the induced relations $R_c$ and $R'_c$.
\end{definition}

This definition allows us to define a $\beta$-reduction closed for the canonical terms, ${(\to_\beta)}_c$, derived from the relation $\to_\beta$ in $\LamM$.
But this definition tells us nothing about the relation itself \dots an interesting question is: how does this $\beta$-reduction behaves on canonical terms?

Given $t, u \in Can$, how do we reduce the canonical term $(\lambda x . t)(u, [])$ according to $(\to_\beta)_c$~?
\[ \begin{prooftree}
    \hypo{ (\lambda x.t)(u, []) \to_\beta t[x := u] }
    \infer1[]{ h((\lambda x.t)(u, [])) \ (\to_\beta)_c \ h(t[x := u]) }
  \end{prooftree} \]

Given that $t, u \in Can$, we get that $(\lambda x.t)(u, []) \in Can$.
Therefore, from~\cref{h_fixpoints}, we get that $(\lambda x.t)(u, []) \ (\to_\beta)_c \ h(t[x := u])$.

Furthermore, from this definition, we could even prove certain properties of $(\to_\beta)_c$.

For example:
\[ \begin{prooftree}
    \hypo{ t \ (\to_\beta)_c \ t' }
    \infer1{ \lambda x.t \ (\to_\beta)_c \ \lambda x.t' }.
  \end{prooftree} \]

This follows from inverting $t \ (\to_\beta)_c \ t'$.
This is, there exist $\LamM$-terms $u, u'$ such that $h(u) = t$ and $h(u') = t'$ and $u \to_\beta u'$.
\[ \begin{prooftree}
    \hypo{ u \to_\beta u' }
    \infer1[\text{(compatibility of $\to_\beta$)}]{ \lambda x.u \to_\beta \lambda x.u' }
    \infer1[\text{(\cref{canonical_closure})}]{ h(\lambda x.u) \ (\to_\beta)_c \ h(\lambda x.u') }
  \end{prooftree} \]
Simplifying $h$ and rewriting $h(u)$ and $h(u')$ we conclude that $\lambda x.t \ (\to_\beta)_c \ \lambda x.t'$.

In the same spirit of~\cref{canonical_closure}, we introduce the canonical typing closure.

\begin{definition}%[Canonical typing closure]
  \label{canonical_typing}
  We inductively define the derivable sequents for canonical terms as follows:
  \[
    \begin{prooftree}
      \hypo{ \Gamma \vdash t:A }
      \infer1{ \Gamma \vdash_c h(t):A } 
    \end{prooftree}
    \qquad \qquad
    \begin{prooftree}
      \hypo{ \Gamma ; A \vdash l:B }
      \infer1{ \Gamma ; A \vdash_c h'(l):B }.
    \end{prooftree}
  \]
\end{definition}

Also, from the previous definition, we may ask the same questions.
For example, given $t \in Can$, is the following rule admissible?
\[
  \begin{prooftree}
    \hypo{ x:A, \Gamma \vdash_c t:B }
    \infer1{ \Gamma \vdash_c \lambda x.t : A \supset B } 
  \end{prooftree}
\]

By inverting our assumption of $x:A, \Gamma \vdash_c t:B$, we get that there exists $t'$, such that $h(t') = t$ and $x:A, \Gamma \vdash t':B$ is derivable in $\LamM$.

Then,
\[
  \begin{prooftree}
    \hypo{ x:A, \Gamma \vdash t':B }
    \infer1[Lam]{ \Gamma \vdash \lambda x . t' : A \supset B }
    \infer1[\text{(\cref{canonical_typing})}]{ \Gamma \vdash_c h(\lambda x . t') : A \supset B }
  \end{prooftree}
\]

And again, simplifying and rewriting $h$, we have derived the sequent $\Gamma \vdash_c \lambda x.t : A \supset B$.

We conclude our presentation of the canonical subsystem of $\LamM$.
This presentation does not exaclty coincide with system $\pmb{\lambda \mathcal{P}}$ from~\cite[Chapter~3.1]{JCES2002}.

In our work, motivated by the task of mechanising these systems, we distinguish between a subsystem of $\LamM$ in the sense we have described here and an isomorphic system with its own syntax, substitution, reduction and typing rules (this is the system~$\LamV$ that will be covered in~\cref{c:canonical}).
We explain some details and motivations for this at the end of the next section.
% In the next chapter we will present a self-contained version of this subsystem and prove both representations are isomorphic.

% ---
% 123
% ---

\section{Mechanisation in \textit{Rocq}}

The mechanisations for the system $\LamM$ follow almost the same style as the ones shown for the simply typed $\Lam$-calculus in~\cref{c:background} using the \textit{Autosubst} library.

\subsection{\lst$LambdaM.v$}

This module that contains the necessary definitions for the formalisations dealing with the system $\LamM$.
The inductive type for the syntax of $\LamM$-terms is as follows.
\begin{lstlisting}[language=Coq]
Inductive term: Type :=
| Var (x: var)
| Lam (t: {bind term})
| mApp (t: term) (u: term) (l: list term).
\end{lstlisting}

The definition for $\LamM$-lists is hidden under the polymorphic list type \lst$list term$.
We give more details for this option at the end of this section.

To mechanise the reduction relations, we first defined the notion of compatibility as in~\cref{compatible_relation} and then the base step relations $\beta_1$, $\beta_2$ and $h$ separately.
That way we introduce the notions of compatible relation and also of compatible closure.
This aproach is more elaborated than the one presented for the simply typed $\Lam$-calculus and we also get into more details about these decisions at the end of this section.

\begin{lstlisting}[language=Coq]
Inductive beta1: relation term :=
| Step_Beta1 (t: {bind term}) (t' u: term) :
  t' = t.[u .: ids] -> beta1 (mApp (Lam t) u []) t'.

Inductive beta2: relation term :=
| Step_Beta2 (t: {bind term}) (t' u v: term) l :
  t' = t.[u .: ids] -> beta2 (mApp (Lam t) u (v::l)) (mApp t' v l).

Inductive H: relation term :=       
| Step_H (t u u': term) l l' l'' :
  l'' = l ++ (u'::l') -> H (mApp (mApp t u l) u' l') (mApp t u l'').

Definition step := comp (union _ (union _ beta1 beta2) H).
Definition step' := comp' (union _ (union _ beta1 beta2) H).

Definition multistep := clos_refl_trans_1n _ step.
Definition multistep' := clos_refl_trans_1n _ step'.
\end{lstlisting}

Here, the \lst$comp$ and \lst$comp'$ are the polymorphic relations on $\LamM$-terms and -lists respectively that induce the compatibility closure.
We also note the use of the \lst$clos_refl_trans_1n$ polymorphic relation provided by the \textit{Rocq Prover} libraries that induces the reflexive and transitive closure of a given binary relation.

In this module, we have also the mechanised typing rules for $\LamM$, much in the style of what was done for the simply typed $\Lam$-calculus.
\begin{lstlisting}[language=Coq]
Inductive sequent (Gamma: var->type) : term -> type -> Prop := 
| varAxiom (x: var) (A: type) :
  Gamma x = A -> sequent Gamma (Var x) A
| Right (t: term) (A B: type) :
  sequent (A .: Gamma) t B -> sequent Gamma (Lam t) (Arr A B)
| HeadCut (t u: term) (l: list term) (A B C: type) :
  sequent Gamma t (Arr A B) -> sequent Gamma u A -> list_sequent Gamma B l C ->
  sequent Gamma (mApp t u l) C
with list_sequent (Gamma:var->type) : type -> (list term) -> type -> Prop :=
| nilAxiom (C: type) : list_sequent Gamma C [] C
| Lft (u: term) (l: list term) (A B C:type) :
  sequent Gamma u A -> list_sequent Gamma B l C ->
  list_sequent Gamma (Arr A B) (u :: l) C.
\end{lstlisting}

\subsection{\lst$TypePreservation.v$}

This module contains proof for~\cref{type_preservation} and necessary lemmas to prove it (recall~\cref{type_substitution}).

\begin{lstlisting}[language=Coq]
Theorem type_preservation :
  (forall t t', step t t' -> forall Gamma A, sequent Gamma t A -> sequent Gamma t' A)
  /\
  (forall l l', step' l l' -> forall Gamma A B, list_sequent Gamma A l B ->
                                 list_sequent Gamma A l' B).
\end{lstlisting}

Using \textit{Autosubst}, we have to prove not only the preservation of types by the substitution operation but also by renamings.
We prove these results using the techniques in the tutorial of~\cite{AutosubstManual}.

\begin{lstlisting}[language=Coq]
Lemma type_renaming :
  forall Γ,
    (forall t A, sequent Gamma t A ->
       forall Delta xi, Gamma = (xi >>> Delta) -> sequent Delta t.[ren xi] A)
    /\
    (forall A l B, list_sequent Γ A l B ->
       forall Delta xi, Gamma = (xi >>> Delta) -> list_sequent Delta A l..[ren xi] B).
...
Lemma type_substitution :
  forall Gamma, 
    (forall t A, sequent Gamma t A ->
       forall sigma Delta, (forall x, sequent Delta (sigma x) (Gamma x)) -> sequent Delta t.[sigma] A)
    /\
    (forall A l B, list_sequent Γ A l B ->
       forall sigma Delta, (forall x, sequent Delta (sigma x) (Gamma x)) -> list_sequent Delta A l..[sigma] B).
\end{lstlisting}

For what is worth, we could prove a simpler statement (similar to~\cref{type_substitution}) to use as lemma for the subject reduction theorem.
Such lemma would look like (without the proposition for lists):
\begin{lstlisting}[language=Coq]
Lemma weak_type_substitution Gamma t A :
  sequent (B.:Gamma) t A -> sequent Gamma u B ->
  sequent Gamma t.[u.:sigma] A).
\end{lstlisting}

The used \textit{Autosubst} aproach takes this notion of well-typed substitutions or context morphisms (see~\cite[Chapter~4]{AutosubstSchafer}) to generalise these lemmas.

As already mentioned, we use the combined induction principles for the proofs and need to declare the propositions using a conjunction on terms and lists.

\subsection{\lst$IsCanonical.v$}

This module contains the necessary definitions for the formalisations dealing with the canonical subsystem of $\LamM$.

First, we define a predicate \lst$is_canonical$ that constructively defines the canonical terms in the style of~\cref{canonical_terms}.
\begin{lstlisting}[language=Coq]
Inductive is_canonical: term -> Prop :=
| cVar (x: var) :
  is_canonical (Var x)
| cLam (t: {bind term}) :
  is_canonical t -> is_canonical (Lam t)
| cVarApp (x: var) (u: term) (l: list term) :
  is_canonical u -> is_canonical_list l ->
  is_canonical (mApp (Var x) u l)
| cLamApp (t: {bind term}) (u: term) (l: list term) :
  is_canonical t -> is_canonical u -> is_canonical_list l ->
  is_canonical (mApp (Lam t) u l)
with is_canonical_list: list term -> Prop :=
| cNil : is_canonical_list []
| cCons (u: term) (l: list term) :
  is_canonical u -> is_canonical_list l ->
  is_canonical_list (u::l).
\end{lstlisting}

The module then contains defintions for the $app$ operation (called \lst$capp$ because append of lists in \textit{Rocq} is already called \lst$app$) and map $h$.
\begin{lstlisting}[language=Coq]
Definition capp (v u: term) (l: list term) : term :=
  match v with
  | Var x        => mApp v u l
  | Lam t        => mApp v u l
  | mApp t u' l' => mApp t u' (l' ++ (u::l))
  end.

Fixpoint h (t: term) :=
  match t with
  | Var x      => Var x
  | Lam t      => Lam (h t)
  | mApp t u l => capp (h t) (h u) (map h l)
  end.
\end{lstlisting}
In the definition of map $h$ we don't define map $h'$, as we use the \lst$map$ function from the \lst$List$ library.
The function \lst$map h$ behaves exactly as the intended map $h'$.
Notice that this way we also avoid a mutually dependent definition.

In the \textit{Rocq Prover}, we need to formally prove that the $app$ operation and map $h$ are closed for canonical terms.
Of course that in description we have of the subsystem we easily argue this informally. For example, in the mechanised results, we have the following lemma.
\begin{lstlisting}[language=Coq]
Lemma capp_is_canonical t u l :
  is_canonical t -> is_canonical u -> is_canonical_list l ->
  is_canonical (capp t u l).
\end{lstlisting}

Then, we prove every lemma and theorem presented in the description of the canonical subsystem.
As an example, we show the mechanisation of~\cref{h_fixpoints}.
\begin{lstlisting}[language=Coq]
Theorem h_fixpoints :
  (forall t, is_canonical t -> h t = t)
  /\
  (forall l, is_canonical_list l -> map h l = l).
Proof.
  apply mut_is_canonical_ind ;
    intros ; asimpl ; repeat f_equal ; auto.
Qed.
\end{lstlisting}
In this proof we use the \lst$auto$ tactic to facilitate our work.
For routine proofs, we often found success when using these automated tactics.

The module ends with definitions for the reduction relation (recall~\cref{canonical_closure}) and typing rules (recall~\cref{canonical_typing}) for the canonical subsystem.
\begin{lstlisting}[language=Coq]
Inductive canonical_relation
  (R: relation term) : relation term :=
| Step_CanTerm t t' : R t t' -> canonical_relation R (h t) (h t').
Inductive canonical_list_relation
  (R: relation (list term)) : relation (list term) :=
| Step_CanList l l' : R l l' -> canonical_list_relation R (map h l) (map h l').

Definition step_can := canonical_relation step_beta.
Definition step_can' := canonical_list_relation step_beta'.
...
Inductive canonical_sequent (Gamma: var->type) :
  term -> type -> Prop :=
| Seq_CanTerm t A : sequent Gamma t A -> canonical_sequent Gamma (h t) A.
Inductive canonical_list_sequent (Gamma: var->type) :
  type -> list term -> type -> Prop :=
| Seq_CanList l A B : list_sequent Gamma A l B ->
                      canonical_list_sequent Gamma A (map h l) B.
\end{lstlisting}

\subsection{A closer look at the mechanisation}

In this part we take a closer look at some particular aspects of the mechanisation that deserve more attention.
The purpose is to show how some other options could arise and justify unusual approaches.

\subsubsection{Mutually inductive types vs nested inductive types}

Creating a mutually inductive type for the syntax of $\LamM$ in \textit{Rocq} would be a simple task:
\begin{lstlisting}[language=Coq]
  Inductive term: Type :=
  | Var (x: var)
  | Lam (t: {bind term})
  | mApp (t: term) (u: term) (l: list)
  with list: Type :=
  | Nil
  | Cons (u: term) (l: list). 
\end{lstlisting}

However, as reported in the final section of~\cite{AutosubstSchafer}, \textit{Autosubst} offers no support for mutually inductive definitions.
The \lst$derive$ tactic would not generate the desired instances for the \lst$Rename$ and \lst$Subst$ classes, failing to iterate through the customized list type.

As we tried to keep the decision of using \textit{Autosubst}, there were two possible directions:
\begin{enumerate}
\item manually define every instance required and prove substitution lemmas;
\item remove the mutual dependency in the term definition.
\end{enumerate}

The first formalisation attempts followed the first option.
This meant that everything \textit{Autosubst} could provide automatically was done by hand.
For this, we closely followed the definitions given in \cite{AutosubstSchafer}.

% At some point, the idea of using the polymorphic list type provided by the \textit{Rocq} standard library came up.
% Inspecting the \textit{Autosubst} code repository, one can find that there is some support for these kinds of mutually inductive definitions.

After some closer inspection of the library source code, we found that there was native support for the use of types depending on polymorphic lists.
This way, there was no need of having a mutual inductive type for our terms.
% After some further inspection of the library source code, we noticed that nested inductive types that depend on lists are already supported by default.

% This is obtained by an auxiliary function, $mmap$, that iterates through lists of terms.
% \dots falar da funcao mmap? \dots

The downside of using nested inductive types in the \textit{Rocq Prover} is the generated induction principles.
This issue is already well documented in \cite[Chapter~14.3]{CoqArt}.
With this approach, we need to provide the dedicated induction principles to the proof assistant.

\begin{lstlisting}[language=Coq]
Section dedicated_induction_principle.
  Variable P : term -> Prop.
  Variable Q : list term -> Prop.
  Hypothesis HVar : forall x, P (Var x).
  Hypothesis HLam : forall t: {bind term}, P t -> P (Lam t).
  Hypothesis HmApp : forall t u l, P t -> P u -> Q l -> P (mApp t u l).
  Hypothesis HNil : Q [].
  Hypothesis HCons : forall u l, P u -> Q l -> Q (u::l).
  
  Proposition sim_term_ind : forall t, P t.
  Proof.
    fix rec 1. destruct t.
    - now apply HVar.
    - apply HLam. now apply rec.
    - apply HmApp.
      + now apply rec.
      + now apply rec.
      + assert (forall l, Q l). {
            fix rec' 1. destruct l0.
            - apply HNil.
            - apply HCons.
              + now apply rec.
              + now apply rec'. }          
        now apply H.
  Qed.      
  
  Proposition sim_list_ind : forall l, Q l.
  Proof.
    fix rec 1. destruct l.
    - now apply HNil.
    - apply HCons.
      + now apply sim_term_ind.
      + now apply rec.
  Qed.          
End dedicated_induction_principle.
\end{lstlisting}

\subsubsection{Formalising a compatible closure}

Defining reductions in $\Lam$-calculus like systems always involve the notion of compatiblity closure, as we want to define reductions also in the subterms of a term.

We took inspiration from the definitions in the \lst$Relations$ libraries of the \textit{Rocq Prover}.
This library provides many definitions on binary relations.
For example, there is a predicate that transitive relations satisfy (in \lst$Relation_Definitions$) and there is also a higher order relation that constructs the transitive closure of a given relation (in \lst$Relation_Operations$).

\begin{lstlisting}[language=Coq]
Definition transitive : Prop := forall x y z:A, R x y -> R y z -> R x z.
...
Inductive clos_trans (x: A) : A -> Prop :=
| t_step (y:A) : R x y -> clos_trans x y
| t_trans (y z:A) : clos_trans x y -> clos_trans y z -> clos_trans x z.
\end{lstlisting}

We followed these definitions to define compatibility notions for the system $\LamM$ in a modular way.
We define the compatible closure from a given base relation on $\LamM$-terms as follows:

\begin{lstlisting}[language=Coq]
Section Compatibilty.
  Variable base : relation term.
  
  Inductive comp : relation term :=
  | Comp_Lam (t t': {bind term}) : comp t t' ->
                                   comp (Lam t) (Lam t')
  | Comp_mApp1 t t' u l : comp t t' ->
                          comp (mApp t u l) (mApp t' u l)
  | Comp_mApp2 t u u' l : comp u u' ->
                          comp (mApp t u l) (mApp t u' l)
  | Comp_mApp3 t u l l' : comp' l l' ->
                          comp (mApp t u l) (mApp t u l')
  | Step_Base t t' : base t t' -> comp t t'
  with comp' : relation (list term) :=
  | Comp_Head u u' l : comp u u' -> comp' (u::l) (u'::l)
  | Comp_Tail u l l' : comp' l l' -> comp' (u::l) (u::l').

  Scheme sim_comp_ind := Induction for comp Sort Prop
    with sim_comp_ind' := Induction for comp' Sort Prop.
  Combined Scheme mut_comp_ind from sim_comp_ind, sim_comp_ind'.
End Compatibilty.
\end{lstlisting}

Then, we also define a record type that contains the necessary predicates to be satisfied by a compatible relation.

\begin{lstlisting}[language=Coq]
Section IsCompatible.
  Variable R : relation term.
  Variable R' : relation (list term).

  Record is_compatible := {
      comp_lam : forall t t': {bind term}, R t t' -> R (Lam t) (Lam t') ;
      comp_mApp1 : forall t t' u l, R t t' -> R (mApp t u l) (mApp t' u l) ;
      comp_mApp2 : forall t u u' l, R u u' -> R (mApp t u l) (mApp t u' l) ;
      comp_mApp3 : forall t u l l', R' l l' -> R (mApp t u l) (mApp t u l') ;
      comp_head : forall u u' l, R u u' -> R' (u :: l) (u' :: l) ;
      comp_tail : forall u l l', R' l l' -> R' (u :: l) (u :: l')
    }.
End IsCompatible.
\end{lstlisting}

From these modular definitions, we can prove some interesting (yet bureaucratic) results, like:

\begin{lstlisting}[language=Coq]
Theorem comp_is_compatible B : is_compatible (comp B) (comp' B).
Proof.
  split ; autounfold ; intros ; constructor ; assumption.
Qed.

Theorem clos_refl_trans_pres_comp :
  forall R R', is_compatible R R' ->
    is_compatible (clos_refl_trans_1n _ R) (clos_refl_trans_1n _ R').
Proof.
  intros R R' H. destruct H. 
  split ; intros ; induction H ; econstructor ; eauto.
Qed.
\end{lstlisting}

This theorem states that if we have a compatible relation, its reflexive and transitive closure is still compatible.

An advantage of these modular definitions is that we can use them to increase automation in our proofs.
In the main theorem that we prove in the next chapter, our proof starts by adding every compatibility step to our context.
As the auto tactic tries to match hypothesis in the context with the goal, the compatibility steps are then covered automatically.

\begin{lstlisting}[language=Coq]
Lemma conservativeness2 :
  (forall (t t': LambdaM.term), LambdaM.step t t' ->
    Canonical.multistep (p t) (p t'))
  /\
  (forall (l l': list LambdaM.term), LambdaM.step' l l' ->
    Canonical.multistep' (map p l) (map p l')).
Proof.
  pose Canonical.multistep_is_compatible as H.
  destruct H. (* unpacking record type *)
  apply LambdaM.mut_comp_ind ; intros ; asimpl ; auto.
  ...
\end{lstlisting}

% deveria mostrar como o exemplo em Rocq funciona?

% ---

\subsubsection{Formalising a subsystem}

A relevant part of our work was to find simple representations for subsystems in the proof assistant.

As we pointed out, the formalisation we have done for the canonical subsystem of $\LamM$ is non standard.
These ideas were motivated by the task of mechanising such subsystem.

Formalising the subset of terms using a predicate is the obvious way to do it.
But we would also like to have a dedicated type for the extension of that predicate rather than just the predicate itself.
The \textit{Rocq Prover} provides such types, known as subset types (we refer to~\cite[Chapter~9.1]{CoqArt}).
Although these subset types are exactly what we wanted, they do not give us a great advantage on mechanisations.
Using subset types rapidly becomes exhausting because of the need to always provide proof objects in every definition.

As an example, trying to define the one step $\beta$-relation as in~\cite[Chapter~3.1]{JCES2002} for the canonical subsystem mechanised using subset types, we would get (supposing we had a mechanised substitution operation):
\begin{lstlisting}[language=Coq]
Definition canonical := { u: term | is_canonical u }. 
Definition canonical_list := { l: list term | is_canonical_list l }.
...
Inductive can_step : canonical -> canonical -> Prop :=
| cStep_Beta1 (t u: term) (it: is_canonical t) (iu: is_canonical u)
  (t': canonical) i:
  i = (cLamApp t u []) it iu cNil ->
  t' = (exist _ t it).[(exist _ u iu) .: ids] ->
  can_step (exist _ (mApp (Lam t) u []) i) t'
...
| cStep_Lam t t' it it' i1 i2 :
  i1 = (cLam t) it ->
  i2 = (cLam t') it' ->
  can_step (exist _ t it) (exist _ t' it') ->
  can_step (exist _ (Lam t) i1) (exist _ (Lam t') i2)
...
\end{lstlisting}

Our aproach on the formalisation of such subsystem was to think of the canonical subsystem according to map $h$ (defining reduction and typification using this map).
After that, we may define a self-contained canonical system with its own syntax and definitions (in the spirit of~\cite[Chapter~3.1]{JCES2002}).
We do this with no reference to any definition from system $\LamM$ and prove that both representations are in fact isomorphic.
That is the goal for~\cref{c:canonical}.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
