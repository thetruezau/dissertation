\chapter{Introduction}
\label{c:intro}

This dissertation presents a mechanisation in the \textit{Rocq Prover} \cite{RocqManual} of a multiary $\Lam$-calculus system \cite{JCESLuis} and some of its associated metatheory.

\section{Motivation}
We can explain what motivated our work by asking ourselves: ``Why mechanise?'', ``Why mechanise metatheory?'' and ``Why the multiary $\Lam$-calculus?''.

Before addressing these questions formally, we could just say that mechanising mathematics is an enjoyable task.
And that could be all we say about our motivation.
Even if our work in mathematics had no application or direct consequences, the fun of mechanising it with a proof assistant would be a good enough motivation.
Mechanising mathematics is like a computer game for a mathematician.

\paragraph{Why mechanise?}
By mechanisation we mean a formal representation of a mathematical object (and this includes mathematical proofs) using a proof assistant.
Such proof assistants have attracted the attention of mathematicians because of the reliability and automation they provide for writing computer-verified proofs~\cite{FourColourThm}.
There has also been an increasing interest by engineers in the use of such tools for the security guarantees achieved when formally proving properties about computer programmes~\cite{CompCert}.

One could even argue that any work of mechanisation is useful, because it will:
\begin{enumerate}
\item result in a mechine-checked work,
\item expose the difficulties behind any mathematical formalisation,
\item provide automation for routine and tedious parts,
\item potentially allow some theory to be extended with less cost.
\end{enumerate}

Some of the mentioned items may even be highlighted when the mechanisation refers to metatheory.

\paragraph{Why mechanise metatheory?}
It is often argued that metatheoretical proofs \textit{``are long, contain few essential insights, and have a lot of tedious but error-prone cases''}~\cite{AutosubstSchafer}.
This inherent complexity and potential for human error provide fertile ground for computer verification and automation of proofs.
Furthermore, formalising a system using a proof assistant enhances its reusability.
Research on the mechanisation of metatheory also gained some popularity in the past 20 years~\cite{POPLmark, POPLmarkReloaded}, facilitating significantly computer developments of this kind.
% Ultimately, adopting computer verification for proofs in metatheory is fast

\paragraph{Why the multiary $\Lam$-calculus?}
In the beginning of~\cite[Chapter~7.3]{CurryHoward}, one is confronted with a natural question: \textit{``Natural deduction proofs correspond to $\Lam$-terms with types, and Hilbert style proofs correspond to combinators with types. What do sequent calculus proofs correspond to?''}.
This question has its starting point in the well-known Curry-Howard isomorphism, that relates natural deduction proofs with $\Lam$-terms with types, as said above.

Many alternatives are given in the aforementioned book, but there exists no intent in carefully matching the process of cut-elimination with normalisation.
In~\cite{Herbelin1994}, Herbelin introduced a multiary $\Lam$-calculus (with explicit substitutions) called $\overline{\pmb \lambda}$, whose typing rules correspond to a fragment of the sequent calculus and every explicit reduction rule behaves as cut-elimination.
The term multiary comes from the fact that applicative terms have a list of arguments ($t [u_1, u_2, \dots, u_k]$) instead of a single argument (as in $(((t u_1) u_2) \dots u_k)$).

We are interested in the study of a multiary $\Lam$-calculus \cite{JCES2002, JCESLuis} (here named $\LamM$) that is slightly different from $\overline{\pmb \lambda}$ by removing the use of explicit substitutions and having an application with an exposed argument $t(u, l)$ instead of $t l$.

Studying the computational meaning behind the sequent calculus is one of the main motivations for considering such systems, since we extend our understanding of the Curry-Howard isomorphism.
As an example of the meaning of this, we can see that a system with typing rules similar to the sequent calculus is closer to a Krivine abstract machine implementation - \textit{``Then the second rule of Krivine abstract machine reads as a cut between an implication which has been introduced on the right and an implication which has been introduced on the left. We are here in the world of sequent calculi, not of natural deduction.''} \cite{Curien2000}.

\section{Objectives and contributions}
The theoretical objectives for this dissertation are the study of:
\begin{enumerate}
\item system $\LamM$, reduction rules, typing rules and standard results like subject reduction;
\item the canonical subsystem of $\LamM$;
\item the conservativeness of the canonical subsystem over $\LamM$;
\item the isomorphism between the canonical subsystem and the simply typed $\Lam$-calculus.
\end{enumerate}

We say theoretical objectives because the complete objective is to mechanise each of the mentioned items.
The practical objectives - in the sense of the mechanisation task - of this dissertation are first to understand the proof assistant in order to fully develop a mechanisation of the definitions and proofs that were studied using pen and paper.
Concretely, we have the objective of understanding how to use the \textit{Rocq Prover} to define systems that deal with variable binding, to define subsystems, to define typing rules, to prove isomorphisms and so on.

A last and challenging objective related to the mechanisation is to formalise every definition and proof as close as possible to the pen-and-paper versions, assuring clean and simple presentations.

Our contributions with this dissertation are a mechanised version of the system $\LamM$ - including the result of subject reduction, the theorem of conservativeness, an isomorphism of its subsystem with the simply typed $\Lam$-calculus and confluence results derived from $\Lam$-calculus - within the \textit{Rocq Prover}.
We know of no other works formalising this metatheory.
This formalised body of work provides a computer-verified and highly accessible foundation for future developments and can be found in an open-source \textit{GitHub} repository \footnote{\href{https://github.com/thetruezau/LambdaM}{https://github.com/thetruezau/LambdaM}}.

\section{Document structure}

An overview of our work can be illustrated by the following figure. % in \cref{roadmap}.
% ------------------------------------------------------------
\begin{figure}[h]
% https://q.uiver.app/#q=WzAsNixbMywwLCJcXGJveGVke1xcbGFtYmRhIG19Il0sWzIsMSwiXFxib3hlZHtcXHZlYyBcXGxhbWJkYX0iXSxbNCwxLCJcXGJveGVke0Nhbn0iXSxbMCwxLCJcXGJveGVkXFxsYW1iZGEiXSxbMiwyLCJcXGJveGVke1xcdmVjXFxiZXRhLW5mc30iXSxbMCwyLCJcXGJveGVke1xcYmV0YS1uZnN9Il0sWzAsMiwiaCJdLFswLDEsInAiLDJdLFsxLDIsImkiLDJdLFszLDEsIlxccHNpIiwyLHsib2Zmc2V0IjoxfV0sWzEsMywiXFx0aGV0YSIsMix7Im9mZnNldCI6MX1dLFsxLDQsIiIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzMsNSwiIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbNSw0LCIiLDEseyJzdHlsZSI6eyJ0YWlsIjp7Im5hbWUiOiJhcnJvd2hlYWQifX19XV0=
\[\begin{tikzcd}
	&&& {\boxed{\LamM}} \\
	{\boxed{\Lam}} && {\boxed{\LamV}} && {\boxed{Can}} \\
	{\boxed{\beta-nfs}} && {\boxed{\vec\beta-nfs}}
	\arrow["p"', from=1-4, to=2-3]
	\arrow["h", from=1-4, to=2-5]
	\arrow["\psi"', shift right, from=2-1, to=2-3]
	\arrow[dashed, no head, from=2-1, to=3-1]
	\arrow["\theta"', shift right, from=2-3, to=2-1]
	\arrow["i"', from=2-3, to=2-5]
	\arrow[dashed, no head, from=2-3, to=3-3]
	\arrow[<->, from=3-1, to=3-3]
      \end{tikzcd}\]
    \caption{Roadmap of systems and relationships} \label{roadmap}
\end{figure}
% --------------------

This document is organised as follows:

\paragraph{\Cref{c:background}} serves as an introduction to the simply typed $\Lam$-calculus with two different presentations: first, a standard approach that uses variable names and $\alpha$-congruence and a second one that uses indices for the names of variables (also called de~Bruijn syntax).
A brief introduction to $\beta$-normal forms ($\beta$-nfs) is given.
By the end of the chapter one finds mechanised definitions and proofs using the \textit{Rocq Prover} as a way to introduce many concepts used along the dissertation (including a formalisation of the simply typed $\Lam$-calculus using \textit{Autosubst}).

\paragraph{\Cref{c:multiary}} introduces the system $\LamM$ and its canonical subsystem (we use the name $Can$ for the subset of terms in this subsystem).
A last section provides a walk-through of the mechanised definitions and proofs.

\paragraph{\Cref{c:canonical}} independently presents a new system called $\LamV$, that is isomorphic to the introduced canonical subsystem of $\LamM$.
Using this system, we will state the theorem of conservativeness.
The $\vec \beta$-normal forms ($\vec \beta$-nfs) in this system are also introduced.
A last section includes an outline of the mechanisation.
 
\paragraph{\Cref{c:isomorphism}} is about the isomorphism between the simply typed $\Lam$-calculus and system $\LamV$.
Using this isomorphism, we will derive the confluence for $\LamV$ and $\LamM$.
Some considerations about the formalised definitions are left for a final section.

\paragraph{\Cref{c:conclusions}} lists our contributions, discusses our approaches in comparison to some related work, and points towards possible future work.

% Every \textit{Rocq Prover} module/script referred throughout this document may be found in the previously mentioned \textit{GitHub} repository.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../dissertation"
%%% End:
